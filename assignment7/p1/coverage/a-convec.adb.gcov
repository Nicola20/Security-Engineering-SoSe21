        -:    0:Source:/home/philipp/opt/GNAT/2021/lib/gcc/x86_64-pc-linux-gnu/10.3.1/adainclude/a-convec.adb
        -:    0:Graph:/mnt/c/wsl_share/1_FS_Master/Security_Engineering/Security-Engineering-SoSe21/assignment7/p1/bin/graphalg_test_tg.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:------------------------------------------------------------------------------
        -:    2:--                                                                          --
        -:    3:--                         GNAT LIBRARY COMPONENTS                          --
        -:    4:--                                                                          --
        -:    5:--                A D A . C O N T A I N E R S . V E C T O R S               --
        -:    6:--                                                                          --
        -:    7:--                                 B o d y                                  --
        -:    8:--                                                                          --
        -:    9:--          Copyright (C) 2004-2021, Free Software Foundation, Inc.         --
        -:   10:--                                                                          --
        -:   11:-- GNAT is free software;  you can  redistribute it  and/or modify it under --
        -:   12:-- terms of the  GNU General Public License as published  by the Free Soft- --
        -:   13:-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
        -:   14:-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
        -:   15:-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
        -:   16:-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
        -:   17:--                                                                          --
        -:   18:--                                                                          --
        -:   19:--                                                                          --
        -:   20:--                                                                          --
        -:   21:--                                                                          --
        -:   22:-- You should have received a copy of the GNU General Public License and    --
        -:   23:-- a copy of the GCC Runtime Library Exception along with this program;     --
        -:   24:-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
        -:   25:-- <http://www.gnu.org/licenses/>.                                          --
        -:   26:--                                                                          --
        -:   27:-- This unit was originally developed by Matthew J Heaney.                  --
        -:   28:------------------------------------------------------------------------------
        -:   29:
        -:   30:with Ada.Containers.Generic_Array_Sort;
        -:   31:with Ada.Unchecked_Deallocation;
        -:   32:
        -:   33:with System; use type System.Address;
        -:   34:with System.Put_Images;
        -:   35:
        -:   36:package body Ada.Containers.Vectors with
        -:   37:  SPARK_Mode => Off
        -:   38:is
        -:   39:
        -:   40:   pragma Warnings (Off, "variable ""Busy*"" is not referenced");
        -:   41:   pragma Warnings (Off, "variable ""Lock*"" is not referenced");
        -:   42:   --  See comment in Ada.Containers.Helpers
        -:   43:
        -:   44:   procedure Free is
        -:   45:     new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);
        -:   46:
        -:   47:   procedure Append_Slow_Path
        -:   48:     (Container : in out Vector;
        -:   49:      New_Item  : Element_Type;
        -:   50:      Count     : Count_Type);
        -:   51:   --  This is the slow path for Append. This is split out to minimize the size
        -:   52:   --  of Append, because we have Inline (Append).
        -:   53:
        -:   54:   ---------
        -:   55:   -- "&" --
        -:   56:   ---------
        -:   57:
        -:   58:   --  We decide that the capacity of the result of "&" is the minimum needed
        -:   59:   --  -- the sum of the lengths of the vector parameters. We could decide to
        -:   60:   --  make it larger, but we have no basis for knowing how much larger, so we
        -:   61:   --  just allocate the minimum amount of storage.
        -:   62:
    #####:   63:   function "&" (Left, Right : Vector) return Vector is
        -:   64:   begin
    #####:   65:      return Result : Vector do
    #####:   66:         Reserve_Capacity (Result, Length (Left) + Length (Right));
    #####:   67:         Append_Vector (Result, Left);
    #####:   68:         Append_Vector (Result, Right);
        -:   69:      end return;
        -:   70:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__Oconcat.212:
    #####:   63:   function "&" (Left, Right : Vector) return Vector is
        -:   64:   begin
    #####:   65:      return Result : Vector do
    #####:   66:         Reserve_Capacity (Result, Length (Left) + Length (Right));
    #####:   67:         Append_Vector (Result, Left);
    #####:   68:         Append_Vector (Result, Right);
        -:   69:      end return;
        -:   70:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__Oconcat.341:
    #####:   63:   function "&" (Left, Right : Vector) return Vector is
        -:   64:   begin
    #####:   65:      return Result : Vector do
    #####:   66:         Reserve_Capacity (Result, Length (Left) + Length (Right));
    #####:   67:         Append_Vector (Result, Left);
    #####:   68:         Append_Vector (Result, Right);
        -:   69:      end return;
        -:   70:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__Oconcat.571:
    #####:   63:   function "&" (Left, Right : Vector) return Vector is
        -:   64:   begin
    #####:   65:      return Result : Vector do
    #####:   66:         Reserve_Capacity (Result, Length (Left) + Length (Right));
    #####:   67:         Append_Vector (Result, Left);
    #####:   68:         Append_Vector (Result, Right);
        -:   69:      end return;
        -:   70:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__Oconcat.700:
    #####:   63:   function "&" (Left, Right : Vector) return Vector is
        -:   64:   begin
    #####:   65:      return Result : Vector do
    #####:   66:         Reserve_Capacity (Result, Length (Left) + Length (Right));
    #####:   67:         Append_Vector (Result, Left);
    #####:   68:         Append_Vector (Result, Right);
        -:   69:      end return;
        -:   70:   end "&";
------------------
        -:   71:
    #####:   72:   function "&" (Left  : Vector; Right : Element_Type) return Vector is
        -:   73:   begin
    #####:   74:      return Result : Vector do
    #####:   75:         Reserve_Capacity (Result, Length (Left) + 1);
    #####:   76:         Append_Vector (Result, Left);
    #####:   77:         Append (Result, Right);
        -:   78:      end return;
        -:   79:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__Oconcat__2.210:
    #####:   72:   function "&" (Left  : Vector; Right : Element_Type) return Vector is
        -:   73:   begin
    #####:   74:      return Result : Vector do
    #####:   75:         Reserve_Capacity (Result, Length (Left) + 1);
    #####:   76:         Append_Vector (Result, Left);
    #####:   77:         Append (Result, Right);
        -:   78:      end return;
        -:   79:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__Oconcat__2.339:
    #####:   72:   function "&" (Left  : Vector; Right : Element_Type) return Vector is
        -:   73:   begin
    #####:   74:      return Result : Vector do
    #####:   75:         Reserve_Capacity (Result, Length (Left) + 1);
    #####:   76:         Append_Vector (Result, Left);
    #####:   77:         Append (Result, Right);
        -:   78:      end return;
        -:   79:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__Oconcat__2.569:
    #####:   72:   function "&" (Left  : Vector; Right : Element_Type) return Vector is
        -:   73:   begin
    #####:   74:      return Result : Vector do
    #####:   75:         Reserve_Capacity (Result, Length (Left) + 1);
    #####:   76:         Append_Vector (Result, Left);
    #####:   77:         Append (Result, Right);
        -:   78:      end return;
        -:   79:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__Oconcat__2.698:
    #####:   72:   function "&" (Left  : Vector; Right : Element_Type) return Vector is
        -:   73:   begin
    #####:   74:      return Result : Vector do
    #####:   75:         Reserve_Capacity (Result, Length (Left) + 1);
    #####:   76:         Append_Vector (Result, Left);
    #####:   77:         Append (Result, Right);
        -:   78:      end return;
        -:   79:   end "&";
------------------
        -:   80:
    #####:   81:   function "&" (Left  : Element_Type; Right : Vector) return Vector is
        -:   82:   begin
    #####:   83:      return Result : Vector do
    #####:   84:         Reserve_Capacity (Result, 1 + Length (Right));
    #####:   85:         Append (Result, Left);
    #####:   86:         Append_Vector (Result, Right);
        -:   87:      end return;
        -:   88:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__Oconcat__3.208:
    #####:   81:   function "&" (Left  : Element_Type; Right : Vector) return Vector is
        -:   82:   begin
    #####:   83:      return Result : Vector do
    #####:   84:         Reserve_Capacity (Result, 1 + Length (Right));
    #####:   85:         Append (Result, Left);
    #####:   86:         Append_Vector (Result, Right);
        -:   87:      end return;
        -:   88:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__Oconcat__3.337:
    #####:   81:   function "&" (Left  : Element_Type; Right : Vector) return Vector is
        -:   82:   begin
    #####:   83:      return Result : Vector do
    #####:   84:         Reserve_Capacity (Result, 1 + Length (Right));
    #####:   85:         Append (Result, Left);
    #####:   86:         Append_Vector (Result, Right);
        -:   87:      end return;
        -:   88:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__Oconcat__3.567:
    #####:   81:   function "&" (Left  : Element_Type; Right : Vector) return Vector is
        -:   82:   begin
    #####:   83:      return Result : Vector do
    #####:   84:         Reserve_Capacity (Result, 1 + Length (Right));
    #####:   85:         Append (Result, Left);
    #####:   86:         Append_Vector (Result, Right);
        -:   87:      end return;
        -:   88:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__Oconcat__3.696:
    #####:   81:   function "&" (Left  : Element_Type; Right : Vector) return Vector is
        -:   82:   begin
    #####:   83:      return Result : Vector do
    #####:   84:         Reserve_Capacity (Result, 1 + Length (Right));
    #####:   85:         Append (Result, Left);
    #####:   86:         Append_Vector (Result, Right);
        -:   87:      end return;
        -:   88:   end "&";
------------------
        -:   89:
    #####:   90:   function "&" (Left, Right : Element_Type) return Vector is
        -:   91:   begin
    #####:   92:      return Result : Vector do
    #####:   93:         Reserve_Capacity (Result, 1 + 1);
    #####:   94:         Append (Result, Left);
    #####:   95:         Append (Result, Right);
        -:   96:      end return;
        -:   97:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__Oconcat__4.206:
    #####:   90:   function "&" (Left, Right : Element_Type) return Vector is
        -:   91:   begin
    #####:   92:      return Result : Vector do
    #####:   93:         Reserve_Capacity (Result, 1 + 1);
    #####:   94:         Append (Result, Left);
    #####:   95:         Append (Result, Right);
        -:   96:      end return;
        -:   97:   end "&";
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__Oconcat__4.335:
    #####:   90:   function "&" (Left, Right : Element_Type) return Vector is
        -:   91:   begin
    #####:   92:      return Result : Vector do
    #####:   93:         Reserve_Capacity (Result, 1 + 1);
    #####:   94:         Append (Result, Left);
    #####:   95:         Append (Result, Right);
        -:   96:      end return;
        -:   97:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__Oconcat__4.565:
    #####:   90:   function "&" (Left, Right : Element_Type) return Vector is
        -:   91:   begin
    #####:   92:      return Result : Vector do
    #####:   93:         Reserve_Capacity (Result, 1 + 1);
    #####:   94:         Append (Result, Left);
    #####:   95:         Append (Result, Right);
        -:   96:      end return;
        -:   97:   end "&";
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__Oconcat__4.694:
    #####:   90:   function "&" (Left, Right : Element_Type) return Vector is
        -:   91:   begin
    #####:   92:      return Result : Vector do
    #####:   93:         Reserve_Capacity (Result, 1 + 1);
    #####:   94:         Append (Result, Left);
    #####:   95:         Append (Result, Right);
        -:   96:      end return;
        -:   97:   end "&";
------------------
        -:   98:
        -:   99:   ---------
        -:  100:   -- "=" --
        -:  101:   ---------
        -:  102:
    #####:  103:   overriding function "=" (Left, Right : Vector) return Boolean is
        -:  104:   begin
    #####:  105:      if Left.Last /= Right.Last then
    #####:  106:         return False;
        -:  107:      end if;
        -:  108:
    #####:  109:      if Left.Length = 0 then
    #####:  110:         return True;
        -:  111:      end if;
        -:  112:
    #####:  113:      declare
        -:  114:         --  Per AI05-0022, the container implementation is required to detect
        -:  115:         --  element tampering by a generic actual subprogram.
        -:  116:
    #####:  117:         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);
    #####:  118:         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);
        -:  119:      begin
    #####:  120:         for J in Index_Type range Index_Type'First .. Left.Last loop
    #####:  121:            if Left.Elements.EA (J) /= Right.Elements.EA (J) then
    #####:  122:               return False;
        -:  123:            end if;
    #####:  124:         end loop;
    #####:  125:      end;
        -:  126:
    #####:  127:      return True;
        -:  128:   end "=";
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__Oeq__2.204:
    #####:  103:   overriding function "=" (Left, Right : Vector) return Boolean is
        -:  104:   begin
    #####:  105:      if Left.Last /= Right.Last then
    #####:  106:         return False;
        -:  107:      end if;
        -:  108:
    #####:  109:      if Left.Length = 0 then
    #####:  110:         return True;
        -:  111:      end if;
        -:  112:
    #####:  113:      declare
        -:  114:         --  Per AI05-0022, the container implementation is required to detect
        -:  115:         --  element tampering by a generic actual subprogram.
        -:  116:
    #####:  117:         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);
    #####:  118:         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);
        -:  119:      begin
    #####:  120:         for J in Index_Type range Index_Type'First .. Left.Last loop
    #####:  121:            if Left.Elements.EA (J) /= Right.Elements.EA (J) then
    #####:  122:               return False;
        -:  123:            end if;
    #####:  124:         end loop;
    #####:  125:      end;
        -:  126:
    #####:  127:      return True;
        -:  128:   end "=";
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__Oeq__2.333:
    #####:  103:   overriding function "=" (Left, Right : Vector) return Boolean is
        -:  104:   begin
    #####:  105:      if Left.Last /= Right.Last then
    #####:  106:         return False;
        -:  107:      end if;
        -:  108:
    #####:  109:      if Left.Length = 0 then
    #####:  110:         return True;
        -:  111:      end if;
        -:  112:
    #####:  113:      declare
        -:  114:         --  Per AI05-0022, the container implementation is required to detect
        -:  115:         --  element tampering by a generic actual subprogram.
        -:  116:
    #####:  117:         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);
    #####:  118:         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);
        -:  119:      begin
    #####:  120:         for J in Index_Type range Index_Type'First .. Left.Last loop
    #####:  121:            if Left.Elements.EA (J) /= Right.Elements.EA (J) then
    #####:  122:               return False;
        -:  123:            end if;
    #####:  124:         end loop;
    #####:  125:      end;
        -:  126:
    #####:  127:      return True;
        -:  128:   end "=";
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__Oeq__2.563:
    #####:  103:   overriding function "=" (Left, Right : Vector) return Boolean is
        -:  104:   begin
    #####:  105:      if Left.Last /= Right.Last then
    #####:  106:         return False;
        -:  107:      end if;
        -:  108:
    #####:  109:      if Left.Length = 0 then
    #####:  110:         return True;
        -:  111:      end if;
        -:  112:
    #####:  113:      declare
        -:  114:         --  Per AI05-0022, the container implementation is required to detect
        -:  115:         --  element tampering by a generic actual subprogram.
        -:  116:
    #####:  117:         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);
    #####:  118:         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);
        -:  119:      begin
    #####:  120:         for J in Index_Type range Index_Type'First .. Left.Last loop
    #####:  121:            if Left.Elements.EA (J) /= Right.Elements.EA (J) then
    #####:  122:               return False;
        -:  123:            end if;
    #####:  124:         end loop;
    #####:  125:      end;
        -:  126:
    #####:  127:      return True;
        -:  128:   end "=";
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__Oeq__2.692:
    #####:  103:   overriding function "=" (Left, Right : Vector) return Boolean is
        -:  104:   begin
    #####:  105:      if Left.Last /= Right.Last then
    #####:  106:         return False;
        -:  107:      end if;
        -:  108:
    #####:  109:      if Left.Length = 0 then
    #####:  110:         return True;
        -:  111:      end if;
        -:  112:
    #####:  113:      declare
        -:  114:         --  Per AI05-0022, the container implementation is required to detect
        -:  115:         --  element tampering by a generic actual subprogram.
        -:  116:
    #####:  117:         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);
    #####:  118:         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);
        -:  119:      begin
    #####:  120:         for J in Index_Type range Index_Type'First .. Left.Last loop
    #####:  121:            if Left.Elements.EA (J) /= Right.Elements.EA (J) then
    #####:  122:               return False;
        -:  123:            end if;
    #####:  124:         end loop;
    #####:  125:      end;
        -:  126:
    #####:  127:      return True;
        -:  128:   end "=";
------------------
        -:  129:
        -:  130:   ------------
        -:  131:   -- Adjust --
        -:  132:   ------------
        -:  133:
    #####:  134:   procedure Adjust (Container : in out Vector) is
        -:  135:   begin
        -:  136:      --  If the counts are nonzero, execution is technically erroneous, but
        -:  137:      --  it seems friendly to allow things like concurrent "=" on shared
        -:  138:      --  constants.
        -:  139:
    #####:  140:      Zero_Counts (Container.TC);
        -:  141:
    #####:  142:      if Container.Last = No_Index then
    #####:  143:         Container.Elements := null;
    #####:  144:         return;
        -:  145:      end if;
        -:  146:
        -:  147:      declare
    #####:  148:         L  : constant Index_Type := Container.Last;
    #####:  149:         EA : Elements_Array renames
    #####:  150:                Container.Elements.EA (Index_Type'First .. L);
        -:  151:
        -:  152:      begin
    #####:  153:         Container.Elements := null;
        -:  154:
        -:  155:         --  Note: it may seem that the following assignment to Container.Last
        -:  156:         --  is useless, since we assign it to L below. However this code is
        -:  157:         --  used in case 'new Elements_Type' below raises an exception, to
        -:  158:         --  keep Container in a consistent state.
        -:  159:
    #####:  160:         Container.Last := No_Index;
    #####:  161:         Container.Elements := new Elements_Type'(L, EA);
    #####:  162:         Container.Last := L;
        -:  163:      end;
        -:  164:   end Adjust;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__adjust__2.202:
    #####:  134:   procedure Adjust (Container : in out Vector) is
        -:  135:   begin
        -:  136:      --  If the counts are nonzero, execution is technically erroneous, but
        -:  137:      --  it seems friendly to allow things like concurrent "=" on shared
        -:  138:      --  constants.
        -:  139:
    #####:  140:      Zero_Counts (Container.TC);
        -:  141:
    #####:  142:      if Container.Last = No_Index then
    #####:  143:         Container.Elements := null;
    #####:  144:         return;
        -:  145:      end if;
        -:  146:
        -:  147:      declare
    #####:  148:         L  : constant Index_Type := Container.Last;
    #####:  149:         EA : Elements_Array renames
    #####:  150:                Container.Elements.EA (Index_Type'First .. L);
        -:  151:
        -:  152:      begin
    #####:  153:         Container.Elements := null;
        -:  154:
        -:  155:         --  Note: it may seem that the following assignment to Container.Last
        -:  156:         --  is useless, since we assign it to L below. However this code is
        -:  157:         --  used in case 'new Elements_Type' below raises an exception, to
        -:  158:         --  keep Container in a consistent state.
        -:  159:
    #####:  160:         Container.Last := No_Index;
    #####:  161:         Container.Elements := new Elements_Type'(L, EA);
    #####:  162:         Container.Last := L;
        -:  163:      end;
        -:  164:   end Adjust;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__adjust__2.331:
    #####:  134:   procedure Adjust (Container : in out Vector) is
        -:  135:   begin
        -:  136:      --  If the counts are nonzero, execution is technically erroneous, but
        -:  137:      --  it seems friendly to allow things like concurrent "=" on shared
        -:  138:      --  constants.
        -:  139:
    #####:  140:      Zero_Counts (Container.TC);
        -:  141:
    #####:  142:      if Container.Last = No_Index then
    #####:  143:         Container.Elements := null;
    #####:  144:         return;
        -:  145:      end if;
        -:  146:
        -:  147:      declare
    #####:  148:         L  : constant Index_Type := Container.Last;
    #####:  149:         EA : Elements_Array renames
    #####:  150:                Container.Elements.EA (Index_Type'First .. L);
        -:  151:
        -:  152:      begin
    #####:  153:         Container.Elements := null;
        -:  154:
        -:  155:         --  Note: it may seem that the following assignment to Container.Last
        -:  156:         --  is useless, since we assign it to L below. However this code is
        -:  157:         --  used in case 'new Elements_Type' below raises an exception, to
        -:  158:         --  keep Container in a consistent state.
        -:  159:
    #####:  160:         Container.Last := No_Index;
    #####:  161:         Container.Elements := new Elements_Type'(L, EA);
    #####:  162:         Container.Last := L;
        -:  163:      end;
        -:  164:   end Adjust;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__adjust__2.561:
    #####:  134:   procedure Adjust (Container : in out Vector) is
        -:  135:   begin
        -:  136:      --  If the counts are nonzero, execution is technically erroneous, but
        -:  137:      --  it seems friendly to allow things like concurrent "=" on shared
        -:  138:      --  constants.
        -:  139:
    #####:  140:      Zero_Counts (Container.TC);
        -:  141:
    #####:  142:      if Container.Last = No_Index then
    #####:  143:         Container.Elements := null;
    #####:  144:         return;
        -:  145:      end if;
        -:  146:
        -:  147:      declare
    #####:  148:         L  : constant Index_Type := Container.Last;
    #####:  149:         EA : Elements_Array renames
    #####:  150:                Container.Elements.EA (Index_Type'First .. L);
        -:  151:
        -:  152:      begin
    #####:  153:         Container.Elements := null;
        -:  154:
        -:  155:         --  Note: it may seem that the following assignment to Container.Last
        -:  156:         --  is useless, since we assign it to L below. However this code is
        -:  157:         --  used in case 'new Elements_Type' below raises an exception, to
        -:  158:         --  keep Container in a consistent state.
        -:  159:
    #####:  160:         Container.Last := No_Index;
    #####:  161:         Container.Elements := new Elements_Type'(L, EA);
    #####:  162:         Container.Last := L;
        -:  163:      end;
        -:  164:   end Adjust;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__adjust__2.690:
    #####:  134:   procedure Adjust (Container : in out Vector) is
        -:  135:   begin
        -:  136:      --  If the counts are nonzero, execution is technically erroneous, but
        -:  137:      --  it seems friendly to allow things like concurrent "=" on shared
        -:  138:      --  constants.
        -:  139:
    #####:  140:      Zero_Counts (Container.TC);
        -:  141:
    #####:  142:      if Container.Last = No_Index then
    #####:  143:         Container.Elements := null;
    #####:  144:         return;
        -:  145:      end if;
        -:  146:
        -:  147:      declare
    #####:  148:         L  : constant Index_Type := Container.Last;
    #####:  149:         EA : Elements_Array renames
    #####:  150:                Container.Elements.EA (Index_Type'First .. L);
        -:  151:
        -:  152:      begin
    #####:  153:         Container.Elements := null;
        -:  154:
        -:  155:         --  Note: it may seem that the following assignment to Container.Last
        -:  156:         --  is useless, since we assign it to L below. However this code is
        -:  157:         --  used in case 'new Elements_Type' below raises an exception, to
        -:  158:         --  keep Container in a consistent state.
        -:  159:
    #####:  160:         Container.Last := No_Index;
    #####:  161:         Container.Elements := new Elements_Type'(L, EA);
    #####:  162:         Container.Last := L;
        -:  163:      end;
        -:  164:   end Adjust;
------------------
        -:  165:
        -:  166:   ------------
        -:  167:   -- Append --
        -:  168:   ------------
        -:  169:
    #####:  170:   procedure Append
        -:  171:     (Container : in out Vector;
        -:  172:      New_Item  : Element_Type;
        -:  173:      Count     : Count_Type)
        -:  174:   is
        -:  175:   begin
        -:  176:      --  In the general case, we pass the buck to Insert, but for efficiency,
        -:  177:      --  we check for the usual case where Count = 1 and the vector has enough
        -:  178:      --  room for at least one more element.
        -:  179:
    #####:  180:      if Count = 1
    #####:  181:        and then Container.Elements /= null
    #####:  182:        and then Container.Last /= Container.Elements.Last
        -:  183:      then
    #####:  184:         TC_Check (Container.TC);
        -:  185:
        -:  186:         --  Increment Container.Last after assigning the New_Item, so we
        -:  187:         --  leave the Container unmodified in case Finalize/Adjust raises
        -:  188:         --  an exception.
        -:  189:
    #####:  190:         declare
    #####:  191:            New_Last : constant Index_Type := Container.Last + 1;
        -:  192:         begin
    #####:  193:            Container.Elements.EA (New_Last) := New_Item;
    #####:  194:            Container.Last := New_Last;
        -:  195:         end;
        -:  196:
        -:  197:      else
    #####:  198:         Append_Slow_Path (Container, New_Item, Count);
        -:  199:      end if;
    #####:  200:   end Append;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__append__2.200:
    #####:  170:   procedure Append
        -:  171:     (Container : in out Vector;
        -:  172:      New_Item  : Element_Type;
        -:  173:      Count     : Count_Type)
        -:  174:   is
        -:  175:   begin
        -:  176:      --  In the general case, we pass the buck to Insert, but for efficiency,
        -:  177:      --  we check for the usual case where Count = 1 and the vector has enough
        -:  178:      --  room for at least one more element.
        -:  179:
    #####:  180:      if Count = 1
    #####:  181:        and then Container.Elements /= null
    #####:  182:        and then Container.Last /= Container.Elements.Last
        -:  183:      then
    #####:  184:         TC_Check (Container.TC);
        -:  185:
        -:  186:         --  Increment Container.Last after assigning the New_Item, so we
        -:  187:         --  leave the Container unmodified in case Finalize/Adjust raises
        -:  188:         --  an exception.
        -:  189:
    #####:  190:         declare
    #####:  191:            New_Last : constant Index_Type := Container.Last + 1;
        -:  192:         begin
    #####:  193:            Container.Elements.EA (New_Last) := New_Item;
    #####:  194:            Container.Last := New_Last;
        -:  195:         end;
        -:  196:
        -:  197:      else
    #####:  198:         Append_Slow_Path (Container, New_Item, Count);
        -:  199:      end if;
    #####:  200:   end Append;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__append__2.329:
    #####:  170:   procedure Append
        -:  171:     (Container : in out Vector;
        -:  172:      New_Item  : Element_Type;
        -:  173:      Count     : Count_Type)
        -:  174:   is
        -:  175:   begin
        -:  176:      --  In the general case, we pass the buck to Insert, but for efficiency,
        -:  177:      --  we check for the usual case where Count = 1 and the vector has enough
        -:  178:      --  room for at least one more element.
        -:  179:
    #####:  180:      if Count = 1
    #####:  181:        and then Container.Elements /= null
    #####:  182:        and then Container.Last /= Container.Elements.Last
        -:  183:      then
    #####:  184:         TC_Check (Container.TC);
        -:  185:
        -:  186:         --  Increment Container.Last after assigning the New_Item, so we
        -:  187:         --  leave the Container unmodified in case Finalize/Adjust raises
        -:  188:         --  an exception.
        -:  189:
    #####:  190:         declare
    #####:  191:            New_Last : constant Index_Type := Container.Last + 1;
        -:  192:         begin
    #####:  193:            Container.Elements.EA (New_Last) := New_Item;
    #####:  194:            Container.Last := New_Last;
        -:  195:         end;
        -:  196:
        -:  197:      else
    #####:  198:         Append_Slow_Path (Container, New_Item, Count);
        -:  199:      end if;
    #####:  200:   end Append;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__append__2.559:
    #####:  170:   procedure Append
        -:  171:     (Container : in out Vector;
        -:  172:      New_Item  : Element_Type;
        -:  173:      Count     : Count_Type)
        -:  174:   is
        -:  175:   begin
        -:  176:      --  In the general case, we pass the buck to Insert, but for efficiency,
        -:  177:      --  we check for the usual case where Count = 1 and the vector has enough
        -:  178:      --  room for at least one more element.
        -:  179:
    #####:  180:      if Count = 1
    #####:  181:        and then Container.Elements /= null
    #####:  182:        and then Container.Last /= Container.Elements.Last
        -:  183:      then
    #####:  184:         TC_Check (Container.TC);
        -:  185:
        -:  186:         --  Increment Container.Last after assigning the New_Item, so we
        -:  187:         --  leave the Container unmodified in case Finalize/Adjust raises
        -:  188:         --  an exception.
        -:  189:
    #####:  190:         declare
    #####:  191:            New_Last : constant Index_Type := Container.Last + 1;
        -:  192:         begin
    #####:  193:            Container.Elements.EA (New_Last) := New_Item;
    #####:  194:            Container.Last := New_Last;
        -:  195:         end;
        -:  196:
        -:  197:      else
    #####:  198:         Append_Slow_Path (Container, New_Item, Count);
        -:  199:      end if;
    #####:  200:   end Append;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__append__2.688:
    #####:  170:   procedure Append
        -:  171:     (Container : in out Vector;
        -:  172:      New_Item  : Element_Type;
        -:  173:      Count     : Count_Type)
        -:  174:   is
        -:  175:   begin
        -:  176:      --  In the general case, we pass the buck to Insert, but for efficiency,
        -:  177:      --  we check for the usual case where Count = 1 and the vector has enough
        -:  178:      --  room for at least one more element.
        -:  179:
    #####:  180:      if Count = 1
    #####:  181:        and then Container.Elements /= null
    #####:  182:        and then Container.Last /= Container.Elements.Last
        -:  183:      then
    #####:  184:         TC_Check (Container.TC);
        -:  185:
        -:  186:         --  Increment Container.Last after assigning the New_Item, so we
        -:  187:         --  leave the Container unmodified in case Finalize/Adjust raises
        -:  188:         --  an exception.
        -:  189:
    #####:  190:         declare
    #####:  191:            New_Last : constant Index_Type := Container.Last + 1;
        -:  192:         begin
    #####:  193:            Container.Elements.EA (New_Last) := New_Item;
    #####:  194:            Container.Last := New_Last;
        -:  195:         end;
        -:  196:
        -:  197:      else
    #####:  198:         Append_Slow_Path (Container, New_Item, Count);
        -:  199:      end if;
    #####:  200:   end Append;
------------------
        -:  201:
        -:  202:   -------------------
        -:  203:   -- Append_Vector --
        -:  204:   -------------------
        -:  205:
    #####:  206:   procedure Append_Vector (Container : in out Vector; New_Item : Vector) is
        -:  207:   begin
    #####:  208:      if Is_Empty (New_Item) then
    #####:  209:         return;
    #####:  210:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  211:         raise Constraint_Error with "vector is already at its maximum length";
        -:  212:      else
    #####:  213:         Insert_Vector (Container, Container.Last + 1, New_Item);
        -:  214:      end if;
        -:  215:   end Append_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__append_vector.199:
    #####:  206:   procedure Append_Vector (Container : in out Vector; New_Item : Vector) is
        -:  207:   begin
    #####:  208:      if Is_Empty (New_Item) then
    #####:  209:         return;
    #####:  210:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  211:         raise Constraint_Error with "vector is already at its maximum length";
        -:  212:      else
    #####:  213:         Insert_Vector (Container, Container.Last + 1, New_Item);
        -:  214:      end if;
        -:  215:   end Append_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__append_vector.328:
    #####:  206:   procedure Append_Vector (Container : in out Vector; New_Item : Vector) is
        -:  207:   begin
    #####:  208:      if Is_Empty (New_Item) then
    #####:  209:         return;
    #####:  210:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  211:         raise Constraint_Error with "vector is already at its maximum length";
        -:  212:      else
    #####:  213:         Insert_Vector (Container, Container.Last + 1, New_Item);
        -:  214:      end if;
        -:  215:   end Append_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__append_vector.558:
    #####:  206:   procedure Append_Vector (Container : in out Vector; New_Item : Vector) is
        -:  207:   begin
    #####:  208:      if Is_Empty (New_Item) then
    #####:  209:         return;
    #####:  210:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  211:         raise Constraint_Error with "vector is already at its maximum length";
        -:  212:      else
    #####:  213:         Insert_Vector (Container, Container.Last + 1, New_Item);
        -:  214:      end if;
        -:  215:   end Append_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__append_vector.687:
    #####:  206:   procedure Append_Vector (Container : in out Vector; New_Item : Vector) is
        -:  207:   begin
    #####:  208:      if Is_Empty (New_Item) then
    #####:  209:         return;
    #####:  210:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  211:         raise Constraint_Error with "vector is already at its maximum length";
        -:  212:      else
    #####:  213:         Insert_Vector (Container, Container.Last + 1, New_Item);
        -:  214:      end if;
        -:  215:   end Append_Vector;
------------------
        -:  216:
        -:  217:   ------------
        -:  218:   -- Append --
        -:  219:   ------------
        -:  220:
    #####:  221:   procedure Append (Container : in out Vector;
        -:  222:                     New_Item  :        Element_Type)
        -:  223:   is
        -:  224:   begin
    #####:  225:      Insert (Container, Last_Index (Container) + 1, New_Item, 1);
    #####:  226:   end Append;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__append__3.198:
    #####:  221:   procedure Append (Container : in out Vector;
        -:  222:                     New_Item  :        Element_Type)
        -:  223:   is
        -:  224:   begin
    #####:  225:      Insert (Container, Last_Index (Container) + 1, New_Item, 1);
    #####:  226:   end Append;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__append__3.327:
    #####:  221:   procedure Append (Container : in out Vector;
        -:  222:                     New_Item  :        Element_Type)
        -:  223:   is
        -:  224:   begin
    #####:  225:      Insert (Container, Last_Index (Container) + 1, New_Item, 1);
    #####:  226:   end Append;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__append__3.557:
    #####:  221:   procedure Append (Container : in out Vector;
        -:  222:                     New_Item  :        Element_Type)
        -:  223:   is
        -:  224:   begin
    #####:  225:      Insert (Container, Last_Index (Container) + 1, New_Item, 1);
    #####:  226:   end Append;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__append__3.686:
    #####:  221:   procedure Append (Container : in out Vector;
        -:  222:                     New_Item  :        Element_Type)
        -:  223:   is
        -:  224:   begin
    #####:  225:      Insert (Container, Last_Index (Container) + 1, New_Item, 1);
    #####:  226:   end Append;
------------------
        -:  227:
        -:  228:   ----------------------
        -:  229:   -- Append_Slow_Path --
        -:  230:   ----------------------
        -:  231:
    #####:  232:   procedure Append_Slow_Path
        -:  233:     (Container : in out Vector;
        -:  234:      New_Item  : Element_Type;
        -:  235:      Count     : Count_Type)
        -:  236:   is
        -:  237:   begin
    #####:  238:      if Count = 0 then
    #####:  239:         return;
    #####:  240:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  241:         raise Constraint_Error with "vector is already at its maximum length";
        -:  242:      else
    #####:  243:         Insert (Container, Container.Last + 1, New_Item, Count);
        -:  244:      end if;
        -:  245:   end Append_Slow_Path;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__append_slow_path.201:
    #####:  232:   procedure Append_Slow_Path
        -:  233:     (Container : in out Vector;
        -:  234:      New_Item  : Element_Type;
        -:  235:      Count     : Count_Type)
        -:  236:   is
        -:  237:   begin
    #####:  238:      if Count = 0 then
    #####:  239:         return;
    #####:  240:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  241:         raise Constraint_Error with "vector is already at its maximum length";
        -:  242:      else
    #####:  243:         Insert (Container, Container.Last + 1, New_Item, Count);
        -:  244:      end if;
        -:  245:   end Append_Slow_Path;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__append_slow_path.330:
    #####:  232:   procedure Append_Slow_Path
        -:  233:     (Container : in out Vector;
        -:  234:      New_Item  : Element_Type;
        -:  235:      Count     : Count_Type)
        -:  236:   is
        -:  237:   begin
    #####:  238:      if Count = 0 then
    #####:  239:         return;
    #####:  240:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  241:         raise Constraint_Error with "vector is already at its maximum length";
        -:  242:      else
    #####:  243:         Insert (Container, Container.Last + 1, New_Item, Count);
        -:  244:      end if;
        -:  245:   end Append_Slow_Path;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__append_slow_path.560:
    #####:  232:   procedure Append_Slow_Path
        -:  233:     (Container : in out Vector;
        -:  234:      New_Item  : Element_Type;
        -:  235:      Count     : Count_Type)
        -:  236:   is
        -:  237:   begin
    #####:  238:      if Count = 0 then
    #####:  239:         return;
    #####:  240:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  241:         raise Constraint_Error with "vector is already at its maximum length";
        -:  242:      else
    #####:  243:         Insert (Container, Container.Last + 1, New_Item, Count);
        -:  244:      end if;
        -:  245:   end Append_Slow_Path;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__append_slow_path.689:
    #####:  232:   procedure Append_Slow_Path
        -:  233:     (Container : in out Vector;
        -:  234:      New_Item  : Element_Type;
        -:  235:      Count     : Count_Type)
        -:  236:   is
        -:  237:   begin
    #####:  238:      if Count = 0 then
    #####:  239:         return;
    #####:  240:      elsif Checks and then Container.Last = Index_Type'Last then
    #####:  241:         raise Constraint_Error with "vector is already at its maximum length";
        -:  242:      else
    #####:  243:         Insert (Container, Container.Last + 1, New_Item, Count);
        -:  244:      end if;
        -:  245:   end Append_Slow_Path;
------------------
        -:  246:
        -:  247:   ------------
        -:  248:   -- Assign --
        -:  249:   ------------
        -:  250:
    #####:  251:   procedure Assign (Target : in out Vector; Source : Vector) is
        -:  252:   begin
    #####:  253:      if Target'Address = Source'Address then
    #####:  254:         return;
        -:  255:      else
    #####:  256:         Target.Clear;
    #####:  257:         Target.Append_Vector (Source);
        -:  258:      end if;
        -:  259:   end Assign;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__assign.197:
    #####:  251:   procedure Assign (Target : in out Vector; Source : Vector) is
        -:  252:   begin
    #####:  253:      if Target'Address = Source'Address then
    #####:  254:         return;
        -:  255:      else
    #####:  256:         Target.Clear;
    #####:  257:         Target.Append_Vector (Source);
        -:  258:      end if;
        -:  259:   end Assign;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__assign.326:
    #####:  251:   procedure Assign (Target : in out Vector; Source : Vector) is
        -:  252:   begin
    #####:  253:      if Target'Address = Source'Address then
    #####:  254:         return;
        -:  255:      else
    #####:  256:         Target.Clear;
    #####:  257:         Target.Append_Vector (Source);
        -:  258:      end if;
        -:  259:   end Assign;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__assign.556:
    #####:  251:   procedure Assign (Target : in out Vector; Source : Vector) is
        -:  252:   begin
    #####:  253:      if Target'Address = Source'Address then
    #####:  254:         return;
        -:  255:      else
    #####:  256:         Target.Clear;
    #####:  257:         Target.Append_Vector (Source);
        -:  258:      end if;
        -:  259:   end Assign;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__assign.685:
    #####:  251:   procedure Assign (Target : in out Vector; Source : Vector) is
        -:  252:   begin
    #####:  253:      if Target'Address = Source'Address then
    #####:  254:         return;
        -:  255:      else
    #####:  256:         Target.Clear;
    #####:  257:         Target.Append_Vector (Source);
        -:  258:      end if;
        -:  259:   end Assign;
------------------
        -:  260:
        -:  261:   --------------
        -:  262:   -- Capacity --
        -:  263:   --------------
        -:  264:
    #####:  265:   function Capacity (Container : Vector) return Count_Type is
        -:  266:   begin
    #####:  267:      if Container.Elements = null then
    #####:  268:         return 0;
        -:  269:      else
    #####:  270:         return Container.Elements.EA'Length;
        -:  271:      end if;
        -:  272:   end Capacity;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__capacity.196:
    #####:  265:   function Capacity (Container : Vector) return Count_Type is
        -:  266:   begin
    #####:  267:      if Container.Elements = null then
    #####:  268:         return 0;
        -:  269:      else
    #####:  270:         return Container.Elements.EA'Length;
        -:  271:      end if;
        -:  272:   end Capacity;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__capacity.325:
    #####:  265:   function Capacity (Container : Vector) return Count_Type is
        -:  266:   begin
    #####:  267:      if Container.Elements = null then
    #####:  268:         return 0;
        -:  269:      else
    #####:  270:         return Container.Elements.EA'Length;
        -:  271:      end if;
        -:  272:   end Capacity;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__capacity.555:
    #####:  265:   function Capacity (Container : Vector) return Count_Type is
        -:  266:   begin
    #####:  267:      if Container.Elements = null then
    #####:  268:         return 0;
        -:  269:      else
    #####:  270:         return Container.Elements.EA'Length;
        -:  271:      end if;
        -:  272:   end Capacity;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__capacity.684:
    #####:  265:   function Capacity (Container : Vector) return Count_Type is
        -:  266:   begin
    #####:  267:      if Container.Elements = null then
    #####:  268:         return 0;
        -:  269:      else
    #####:  270:         return Container.Elements.EA'Length;
        -:  271:      end if;
        -:  272:   end Capacity;
------------------
        -:  273:
        -:  274:   -----------
        -:  275:   -- Clear --
        -:  276:   -----------
        -:  277:
    #####:  278:   procedure Clear (Container : in out Vector) is
        -:  279:   begin
    #####:  280:      TC_Check (Container.TC);
    #####:  281:      Container.Last := No_Index;
    #####:  282:   end Clear;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__clear.195:
    #####:  278:   procedure Clear (Container : in out Vector) is
        -:  279:   begin
    #####:  280:      TC_Check (Container.TC);
    #####:  281:      Container.Last := No_Index;
    #####:  282:   end Clear;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__clear.324:
    #####:  278:   procedure Clear (Container : in out Vector) is
        -:  279:   begin
    #####:  280:      TC_Check (Container.TC);
    #####:  281:      Container.Last := No_Index;
    #####:  282:   end Clear;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__clear.554:
    #####:  278:   procedure Clear (Container : in out Vector) is
        -:  279:   begin
    #####:  280:      TC_Check (Container.TC);
    #####:  281:      Container.Last := No_Index;
    #####:  282:   end Clear;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__clear.683:
    #####:  278:   procedure Clear (Container : in out Vector) is
        -:  279:   begin
    #####:  280:      TC_Check (Container.TC);
    #####:  281:      Container.Last := No_Index;
    #####:  282:   end Clear;
------------------
        -:  283:
        -:  284:   ------------------------
        -:  285:   -- Constant_Reference --
        -:  286:   ------------------------
        -:  287:
    #####:  288:   function Constant_Reference
        -:  289:     (Container : aliased Vector;
        -:  290:      Position  : Cursor) return Constant_Reference_Type
        -:  291:   is
        -:  292:   begin
        -:  293:      if Checks then
    #####:  294:         if Position.Container = null then
    #####:  295:            raise Constraint_Error with "Position cursor has no element";
        -:  296:         end if;
        -:  297:
    #####:  298:         if Position.Container /= Container'Unrestricted_Access then
    #####:  299:            raise Program_Error with "Position cursor denotes wrong container";
        -:  300:         end if;
        -:  301:
    #####:  302:         if Position.Index > Position.Container.Last then
    #####:  303:            raise Constraint_Error with "Position cursor is out of range";
        -:  304:         end if;
        -:  305:      end if;
        -:  306:
        -:  307:      declare
    #####:  308:         TC : constant Tamper_Counts_Access :=
        -:  309:           Container.TC'Unrestricted_Access;
        -:  310:      begin
    #####:  311:         return R : constant Constant_Reference_Type :=
    #####:  312:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####:  313:            Control => (Controlled with TC))
        -:  314:         do
    #####:  315:            Busy (TC.all);
        -:  316:         end return;
        -:  317:      end;
        -:  318:   end Constant_Reference;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__constant_reference.193:
    #####:  288:   function Constant_Reference
        -:  289:     (Container : aliased Vector;
        -:  290:      Position  : Cursor) return Constant_Reference_Type
        -:  291:   is
        -:  292:   begin
        -:  293:      if Checks then
    #####:  294:         if Position.Container = null then
    #####:  295:            raise Constraint_Error with "Position cursor has no element";
        -:  296:         end if;
        -:  297:
    #####:  298:         if Position.Container /= Container'Unrestricted_Access then
    #####:  299:            raise Program_Error with "Position cursor denotes wrong container";
        -:  300:         end if;
        -:  301:
    #####:  302:         if Position.Index > Position.Container.Last then
    #####:  303:            raise Constraint_Error with "Position cursor is out of range";
        -:  304:         end if;
        -:  305:      end if;
        -:  306:
        -:  307:      declare
    #####:  308:         TC : constant Tamper_Counts_Access :=
        -:  309:           Container.TC'Unrestricted_Access;
        -:  310:      begin
    #####:  311:         return R : constant Constant_Reference_Type :=
    #####:  312:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####:  313:            Control => (Controlled with TC))
        -:  314:         do
    #####:  315:            Busy (TC.all);
        -:  316:         end return;
        -:  317:      end;
        -:  318:   end Constant_Reference;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__constant_reference.322:
    #####:  288:   function Constant_Reference
        -:  289:     (Container : aliased Vector;
        -:  290:      Position  : Cursor) return Constant_Reference_Type
        -:  291:   is
        -:  292:   begin
        -:  293:      if Checks then
    #####:  294:         if Position.Container = null then
    #####:  295:            raise Constraint_Error with "Position cursor has no element";
        -:  296:         end if;
        -:  297:
    #####:  298:         if Position.Container /= Container'Unrestricted_Access then
    #####:  299:            raise Program_Error with "Position cursor denotes wrong container";
        -:  300:         end if;
        -:  301:
    #####:  302:         if Position.Index > Position.Container.Last then
    #####:  303:            raise Constraint_Error with "Position cursor is out of range";
        -:  304:         end if;
        -:  305:      end if;
        -:  306:
        -:  307:      declare
    #####:  308:         TC : constant Tamper_Counts_Access :=
        -:  309:           Container.TC'Unrestricted_Access;
        -:  310:      begin
    #####:  311:         return R : constant Constant_Reference_Type :=
    #####:  312:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####:  313:            Control => (Controlled with TC))
        -:  314:         do
    #####:  315:            Busy (TC.all);
        -:  316:         end return;
        -:  317:      end;
        -:  318:   end Constant_Reference;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__constant_reference.552:
    #####:  288:   function Constant_Reference
        -:  289:     (Container : aliased Vector;
        -:  290:      Position  : Cursor) return Constant_Reference_Type
        -:  291:   is
        -:  292:   begin
        -:  293:      if Checks then
    #####:  294:         if Position.Container = null then
    #####:  295:            raise Constraint_Error with "Position cursor has no element";
        -:  296:         end if;
        -:  297:
    #####:  298:         if Position.Container /= Container'Unrestricted_Access then
    #####:  299:            raise Program_Error with "Position cursor denotes wrong container";
        -:  300:         end if;
        -:  301:
    #####:  302:         if Position.Index > Position.Container.Last then
    #####:  303:            raise Constraint_Error with "Position cursor is out of range";
        -:  304:         end if;
        -:  305:      end if;
        -:  306:
        -:  307:      declare
    #####:  308:         TC : constant Tamper_Counts_Access :=
        -:  309:           Container.TC'Unrestricted_Access;
        -:  310:      begin
    #####:  311:         return R : constant Constant_Reference_Type :=
    #####:  312:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####:  313:            Control => (Controlled with TC))
        -:  314:         do
    #####:  315:            Busy (TC.all);
        -:  316:         end return;
        -:  317:      end;
        -:  318:   end Constant_Reference;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__constant_reference.681:
    #####:  288:   function Constant_Reference
        -:  289:     (Container : aliased Vector;
        -:  290:      Position  : Cursor) return Constant_Reference_Type
        -:  291:   is
        -:  292:   begin
        -:  293:      if Checks then
    #####:  294:         if Position.Container = null then
    #####:  295:            raise Constraint_Error with "Position cursor has no element";
        -:  296:         end if;
        -:  297:
    #####:  298:         if Position.Container /= Container'Unrestricted_Access then
    #####:  299:            raise Program_Error with "Position cursor denotes wrong container";
        -:  300:         end if;
        -:  301:
    #####:  302:         if Position.Index > Position.Container.Last then
    #####:  303:            raise Constraint_Error with "Position cursor is out of range";
        -:  304:         end if;
        -:  305:      end if;
        -:  306:
        -:  307:      declare
    #####:  308:         TC : constant Tamper_Counts_Access :=
        -:  309:           Container.TC'Unrestricted_Access;
        -:  310:      begin
    #####:  311:         return R : constant Constant_Reference_Type :=
    #####:  312:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####:  313:            Control => (Controlled with TC))
        -:  314:         do
    #####:  315:            Busy (TC.all);
        -:  316:         end return;
        -:  317:      end;
        -:  318:   end Constant_Reference;
------------------
        -:  319:
    #####:  320:   function Constant_Reference
        -:  321:     (Container : aliased Vector;
        -:  322:      Index     : Index_Type) return Constant_Reference_Type
        -:  323:   is
        -:  324:   begin
    #####:  325:      if Checks and then Index > Container.Last then
    #####:  326:         raise Constraint_Error with "Index is out of range";
        -:  327:      end if;
        -:  328:
        -:  329:      declare
    #####:  330:         TC : constant Tamper_Counts_Access :=
        -:  331:           Container.TC'Unrestricted_Access;
        -:  332:      begin
    #####:  333:         return R : constant Constant_Reference_Type :=
    #####:  334:           (Element => Container.Elements.EA (Index)'Access,
    #####:  335:            Control => (Controlled with TC))
        -:  336:         do
    #####:  337:            Busy (TC.all);
        -:  338:         end return;
        -:  339:      end;
        -:  340:   end Constant_Reference;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__constant_reference__2.190:
    #####:  320:   function Constant_Reference
        -:  321:     (Container : aliased Vector;
        -:  322:      Index     : Index_Type) return Constant_Reference_Type
        -:  323:   is
        -:  324:   begin
    #####:  325:      if Checks and then Index > Container.Last then
    #####:  326:         raise Constraint_Error with "Index is out of range";
        -:  327:      end if;
        -:  328:
        -:  329:      declare
    #####:  330:         TC : constant Tamper_Counts_Access :=
        -:  331:           Container.TC'Unrestricted_Access;
        -:  332:      begin
    #####:  333:         return R : constant Constant_Reference_Type :=
    #####:  334:           (Element => Container.Elements.EA (Index)'Access,
    #####:  335:            Control => (Controlled with TC))
        -:  336:         do
    #####:  337:            Busy (TC.all);
        -:  338:         end return;
        -:  339:      end;
        -:  340:   end Constant_Reference;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__constant_reference__2.319:
    #####:  320:   function Constant_Reference
        -:  321:     (Container : aliased Vector;
        -:  322:      Index     : Index_Type) return Constant_Reference_Type
        -:  323:   is
        -:  324:   begin
    #####:  325:      if Checks and then Index > Container.Last then
    #####:  326:         raise Constraint_Error with "Index is out of range";
        -:  327:      end if;
        -:  328:
        -:  329:      declare
    #####:  330:         TC : constant Tamper_Counts_Access :=
        -:  331:           Container.TC'Unrestricted_Access;
        -:  332:      begin
    #####:  333:         return R : constant Constant_Reference_Type :=
    #####:  334:           (Element => Container.Elements.EA (Index)'Access,
    #####:  335:            Control => (Controlled with TC))
        -:  336:         do
    #####:  337:            Busy (TC.all);
        -:  338:         end return;
        -:  339:      end;
        -:  340:   end Constant_Reference;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__constant_reference__2.549:
    #####:  320:   function Constant_Reference
        -:  321:     (Container : aliased Vector;
        -:  322:      Index     : Index_Type) return Constant_Reference_Type
        -:  323:   is
        -:  324:   begin
    #####:  325:      if Checks and then Index > Container.Last then
    #####:  326:         raise Constraint_Error with "Index is out of range";
        -:  327:      end if;
        -:  328:
        -:  329:      declare
    #####:  330:         TC : constant Tamper_Counts_Access :=
        -:  331:           Container.TC'Unrestricted_Access;
        -:  332:      begin
    #####:  333:         return R : constant Constant_Reference_Type :=
    #####:  334:           (Element => Container.Elements.EA (Index)'Access,
    #####:  335:            Control => (Controlled with TC))
        -:  336:         do
    #####:  337:            Busy (TC.all);
        -:  338:         end return;
        -:  339:      end;
        -:  340:   end Constant_Reference;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__constant_reference__2.678:
    #####:  320:   function Constant_Reference
        -:  321:     (Container : aliased Vector;
        -:  322:      Index     : Index_Type) return Constant_Reference_Type
        -:  323:   is
        -:  324:   begin
    #####:  325:      if Checks and then Index > Container.Last then
    #####:  326:         raise Constraint_Error with "Index is out of range";
        -:  327:      end if;
        -:  328:
        -:  329:      declare
    #####:  330:         TC : constant Tamper_Counts_Access :=
        -:  331:           Container.TC'Unrestricted_Access;
        -:  332:      begin
    #####:  333:         return R : constant Constant_Reference_Type :=
    #####:  334:           (Element => Container.Elements.EA (Index)'Access,
    #####:  335:            Control => (Controlled with TC))
        -:  336:         do
    #####:  337:            Busy (TC.all);
        -:  338:         end return;
        -:  339:      end;
        -:  340:   end Constant_Reference;
------------------
        -:  341:
        -:  342:   --------------
        -:  343:   -- Contains --
        -:  344:   --------------
        -:  345:
    #####:  346:   function Contains
        -:  347:     (Container : Vector;
        -:  348:      Item      : Element_Type) return Boolean
        -:  349:   is
        -:  350:   begin
    #####:  351:      return Find_Index (Container, Item) /= No_Index;
        -:  352:   end Contains;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__contains.189:
    #####:  346:   function Contains
        -:  347:     (Container : Vector;
        -:  348:      Item      : Element_Type) return Boolean
        -:  349:   is
        -:  350:   begin
    #####:  351:      return Find_Index (Container, Item) /= No_Index;
        -:  352:   end Contains;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__contains.318:
    #####:  346:   function Contains
        -:  347:     (Container : Vector;
        -:  348:      Item      : Element_Type) return Boolean
        -:  349:   is
        -:  350:   begin
    #####:  351:      return Find_Index (Container, Item) /= No_Index;
        -:  352:   end Contains;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__contains.548:
    #####:  346:   function Contains
        -:  347:     (Container : Vector;
        -:  348:      Item      : Element_Type) return Boolean
        -:  349:   is
        -:  350:   begin
    #####:  351:      return Find_Index (Container, Item) /= No_Index;
        -:  352:   end Contains;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__contains.677:
    #####:  346:   function Contains
        -:  347:     (Container : Vector;
        -:  348:      Item      : Element_Type) return Boolean
        -:  349:   is
        -:  350:   begin
    #####:  351:      return Find_Index (Container, Item) /= No_Index;
        -:  352:   end Contains;
------------------
        -:  353:
        -:  354:   ----------
        -:  355:   -- Copy --
        -:  356:   ----------
        -:  357:
    #####:  358:   function Copy
        -:  359:     (Source   : Vector;
        -:  360:      Capacity : Count_Type := 0) return Vector
        -:  361:   is
        -:  362:      C : Count_Type;
        -:  363:
        -:  364:   begin
    #####:  365:      if Capacity >= Source.Length then
    #####:  366:         C := Capacity;
        -:  367:
        -:  368:      else
    #####:  369:         C := Source.Length;
        -:  370:
    #####:  371:         if Checks and then Capacity /= 0 then
    #####:  372:            raise Capacity_Error with
        -:  373:              "Requested capacity is less than Source length";
        -:  374:         end if;
        -:  375:      end if;
        -:  376:
    #####:  377:      return Target : Vector do
    #####:  378:         Target.Reserve_Capacity (C);
    #####:  379:         Target.Assign (Source);
        -:  380:      end return;
        -:  381:   end Copy;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__copy.187:
    #####:  358:   function Copy
        -:  359:     (Source   : Vector;
        -:  360:      Capacity : Count_Type := 0) return Vector
        -:  361:   is
        -:  362:      C : Count_Type;
        -:  363:
        -:  364:   begin
    #####:  365:      if Capacity >= Source.Length then
    #####:  366:         C := Capacity;
        -:  367:
        -:  368:      else
    #####:  369:         C := Source.Length;
        -:  370:
    #####:  371:         if Checks and then Capacity /= 0 then
    #####:  372:            raise Capacity_Error with
        -:  373:              "Requested capacity is less than Source length";
        -:  374:         end if;
        -:  375:      end if;
        -:  376:
    #####:  377:      return Target : Vector do
    #####:  378:         Target.Reserve_Capacity (C);
    #####:  379:         Target.Assign (Source);
        -:  380:      end return;
        -:  381:   end Copy;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__copy.316:
    #####:  358:   function Copy
        -:  359:     (Source   : Vector;
        -:  360:      Capacity : Count_Type := 0) return Vector
        -:  361:   is
        -:  362:      C : Count_Type;
        -:  363:
        -:  364:   begin
    #####:  365:      if Capacity >= Source.Length then
    #####:  366:         C := Capacity;
        -:  367:
        -:  368:      else
    #####:  369:         C := Source.Length;
        -:  370:
    #####:  371:         if Checks and then Capacity /= 0 then
    #####:  372:            raise Capacity_Error with
        -:  373:              "Requested capacity is less than Source length";
        -:  374:         end if;
        -:  375:      end if;
        -:  376:
    #####:  377:      return Target : Vector do
    #####:  378:         Target.Reserve_Capacity (C);
    #####:  379:         Target.Assign (Source);
        -:  380:      end return;
        -:  381:   end Copy;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__copy.546:
    #####:  358:   function Copy
        -:  359:     (Source   : Vector;
        -:  360:      Capacity : Count_Type := 0) return Vector
        -:  361:   is
        -:  362:      C : Count_Type;
        -:  363:
        -:  364:   begin
    #####:  365:      if Capacity >= Source.Length then
    #####:  366:         C := Capacity;
        -:  367:
        -:  368:      else
    #####:  369:         C := Source.Length;
        -:  370:
    #####:  371:         if Checks and then Capacity /= 0 then
    #####:  372:            raise Capacity_Error with
        -:  373:              "Requested capacity is less than Source length";
        -:  374:         end if;
        -:  375:      end if;
        -:  376:
    #####:  377:      return Target : Vector do
    #####:  378:         Target.Reserve_Capacity (C);
    #####:  379:         Target.Assign (Source);
        -:  380:      end return;
        -:  381:   end Copy;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__copy.675:
    #####:  358:   function Copy
        -:  359:     (Source   : Vector;
        -:  360:      Capacity : Count_Type := 0) return Vector
        -:  361:   is
        -:  362:      C : Count_Type;
        -:  363:
        -:  364:   begin
    #####:  365:      if Capacity >= Source.Length then
    #####:  366:         C := Capacity;
        -:  367:
        -:  368:      else
    #####:  369:         C := Source.Length;
        -:  370:
    #####:  371:         if Checks and then Capacity /= 0 then
    #####:  372:            raise Capacity_Error with
        -:  373:              "Requested capacity is less than Source length";
        -:  374:         end if;
        -:  375:      end if;
        -:  376:
    #####:  377:      return Target : Vector do
    #####:  378:         Target.Reserve_Capacity (C);
    #####:  379:         Target.Assign (Source);
        -:  380:      end return;
        -:  381:   end Copy;
------------------
        -:  382:
        -:  383:   ------------
        -:  384:   -- Delete --
        -:  385:   ------------
        -:  386:
    #####:  387:   procedure Delete
        -:  388:     (Container : in out Vector;
        -:  389:      Index     : Extended_Index;
        -:  390:      Count     : Count_Type := 1)
        -:  391:   is
    #####:  392:      Old_Last : constant Index_Type'Base := Container.Last;
        -:  393:      New_Last : Index_Type'Base;
        -:  394:      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last
        -:  395:      J        : Index_Type'Base;  -- first index of items that slide down
        -:  396:
        -:  397:   begin
        -:  398:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  399:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  400:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  401:      --  the count on exit. Delete checks the count to determine whether it is
        -:  402:      --  being called while the associated callback procedure is executing.
        -:  403:
    #####:  404:      TC_Check (Container.TC);
        -:  405:
        -:  406:      --  Delete removes items from the vector, the number of which is the
        -:  407:      --  minimum of the specified Count and the items (if any) that exist from
        -:  408:      --  Index to Container.Last. There are no constraints on the specified
        -:  409:      --  value of Count (it can be larger than what's available at this
        -:  410:      --  position in the vector, for example), but there are constraints on
        -:  411:      --  the allowed values of the Index.
        -:  412:
        -:  413:      --  As a precondition on the generic actual Index_Type, the base type
        -:  414:      --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  415:      --  that Container.Last assumes when the vector is empty. However, we do
        -:  416:      --  not allow that as the value for Index when specifying which items
        -:  417:      --  should be deleted, so we must manually check. (That the user is
        -:  418:      --  allowed to specify the value at all here is a consequence of the
        -:  419:      --  declaration of the Extended_Index subtype, which includes the values
        -:  420:      --  in the base range that immediately precede and immediately follow the
        -:  421:      --  values in the Index_Type.)
        -:  422:
    #####:  423:      if Checks and then Index < Index_Type'First then
    #####:  424:         raise Constraint_Error with "Index is out of range (too small)";
        -:  425:      end if;
        -:  426:
        -:  427:      --  We do allow a value greater than Container.Last to be specified as
        -:  428:      --  the Index, but only if it's immediately greater. This allows the
        -:  429:      --  corner case of deleting no items from the back end of the vector to
        -:  430:      --  be treated as a no-op. (It is assumed that specifying an index value
        -:  431:      --  greater than Last + 1 indicates some deeper flaw in the caller's
        -:  432:      --  algorithm, so that case is treated as a proper error.)
        -:  433:
    #####:  434:      if Index > Old_Last then
    #####:  435:         if Checks and then Index > Old_Last + 1 then
    #####:  436:            raise Constraint_Error with "Index is out of range (too large)";
        -:  437:         else
    #####:  438:            return;
        -:  439:         end if;
        -:  440:      end if;
        -:  441:
        -:  442:      --  Here and elsewhere we treat deleting 0 items from the container as a
        -:  443:      --  no-op, even when the container is busy, so we simply return.
        -:  444:
    #####:  445:      if Count = 0 then
    #####:  446:         return;
        -:  447:      end if;
        -:  448:
        -:  449:      --  We first calculate what's available for deletion starting at
        -:  450:      --  Index. Here and elsewhere we use the wider of Index_Type'Base and
        -:  451:      --  Count_Type'Base as the type for intermediate values. (See function
        -:  452:      --  Length for more information.)
        -:  453:
        -:  454:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####:  455:         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;
        -:  456:      else
        -:  457:         Count2 := Count_Type'Base (Old_Last - Index + 1);
        -:  458:      end if;
        -:  459:
        -:  460:      --  If more elements are requested (Count) for deletion than are
        -:  461:      --  available (Count2) for deletion beginning at Index, then everything
        -:  462:      --  from Index is deleted. There are no elements to slide down, and so
        -:  463:      --  all we need to do is set the value of Container.Last.
        -:  464:
    #####:  465:      if Count >= Count2 then
    #####:  466:         Container.Last := Index - 1;
    #####:  467:         return;
        -:  468:      end if;
        -:  469:
        -:  470:      --  There are some elements that aren't being deleted (the requested
        -:  471:      --  count was less than the available count), so we must slide them down
        -:  472:      --  to Index. We first calculate the index values of the respective array
        -:  473:      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the
        -:  474:      --  type for intermediate calculations. For the elements that slide down,
        -:  475:      --  index value New_Last is the last index value of their new home, and
        -:  476:      --  index value J is the first index of their old home.
        -:  477:
        -:  478:      if Index_Type'Base'Last >= Count_Type_Last then
    #####:  479:         New_Last := Old_Last - Index_Type'Base (Count);
    #####:  480:         J := Index + Index_Type'Base (Count);
        -:  481:      else
        -:  482:         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);
        -:  483:         J := Index_Type'Base (Count_Type'Base (Index) + Count);
        -:  484:      end if;
        -:  485:
        -:  486:      --  The internal elements array isn't guaranteed to exist unless we have
        -:  487:      --  elements, but we have that guarantee here because we know we have
        -:  488:      --  elements to slide.  The array index values for each slice have
        -:  489:      --  already been determined, so we just slide down to Index the elements
        -:  490:      --  that weren't deleted.
        -:  491:
        -:  492:      declare
    #####:  493:         EA : Elements_Array renames Container.Elements.EA;
        -:  494:      begin
    #####:  495:         EA (Index .. New_Last) := EA (J .. Old_Last);
    #####:  496:         Container.Last := New_Last;
        -:  497:      end;
        -:  498:   end Delete;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__delete.186:
    #####:  387:   procedure Delete
        -:  388:     (Container : in out Vector;
        -:  389:      Index     : Extended_Index;
        -:  390:      Count     : Count_Type := 1)
        -:  391:   is
    #####:  392:      Old_Last : constant Index_Type'Base := Container.Last;
        -:  393:      New_Last : Index_Type'Base;
        -:  394:      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last
        -:  395:      J        : Index_Type'Base;  -- first index of items that slide down
        -:  396:
        -:  397:   begin
        -:  398:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  399:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  400:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  401:      --  the count on exit. Delete checks the count to determine whether it is
        -:  402:      --  being called while the associated callback procedure is executing.
        -:  403:
    #####:  404:      TC_Check (Container.TC);
        -:  405:
        -:  406:      --  Delete removes items from the vector, the number of which is the
        -:  407:      --  minimum of the specified Count and the items (if any) that exist from
        -:  408:      --  Index to Container.Last. There are no constraints on the specified
        -:  409:      --  value of Count (it can be larger than what's available at this
        -:  410:      --  position in the vector, for example), but there are constraints on
        -:  411:      --  the allowed values of the Index.
        -:  412:
        -:  413:      --  As a precondition on the generic actual Index_Type, the base type
        -:  414:      --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  415:      --  that Container.Last assumes when the vector is empty. However, we do
        -:  416:      --  not allow that as the value for Index when specifying which items
        -:  417:      --  should be deleted, so we must manually check. (That the user is
        -:  418:      --  allowed to specify the value at all here is a consequence of the
        -:  419:      --  declaration of the Extended_Index subtype, which includes the values
        -:  420:      --  in the base range that immediately precede and immediately follow the
        -:  421:      --  values in the Index_Type.)
        -:  422:
    #####:  423:      if Checks and then Index < Index_Type'First then
    #####:  424:         raise Constraint_Error with "Index is out of range (too small)";
        -:  425:      end if;
        -:  426:
        -:  427:      --  We do allow a value greater than Container.Last to be specified as
        -:  428:      --  the Index, but only if it's immediately greater. This allows the
        -:  429:      --  corner case of deleting no items from the back end of the vector to
        -:  430:      --  be treated as a no-op. (It is assumed that specifying an index value
        -:  431:      --  greater than Last + 1 indicates some deeper flaw in the caller's
        -:  432:      --  algorithm, so that case is treated as a proper error.)
        -:  433:
    #####:  434:      if Index > Old_Last then
    #####:  435:         if Checks and then Index > Old_Last + 1 then
    #####:  436:            raise Constraint_Error with "Index is out of range (too large)";
        -:  437:         else
    #####:  438:            return;
        -:  439:         end if;
        -:  440:      end if;
        -:  441:
        -:  442:      --  Here and elsewhere we treat deleting 0 items from the container as a
        -:  443:      --  no-op, even when the container is busy, so we simply return.
        -:  444:
    #####:  445:      if Count = 0 then
    #####:  446:         return;
        -:  447:      end if;
        -:  448:
        -:  449:      --  We first calculate what's available for deletion starting at
        -:  450:      --  Index. Here and elsewhere we use the wider of Index_Type'Base and
        -:  451:      --  Count_Type'Base as the type for intermediate values. (See function
        -:  452:      --  Length for more information.)
        -:  453:
        -:  454:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####:  455:         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;
        -:  456:      else
        -:  457:         Count2 := Count_Type'Base (Old_Last - Index + 1);
        -:  458:      end if;
        -:  459:
        -:  460:      --  If more elements are requested (Count) for deletion than are
        -:  461:      --  available (Count2) for deletion beginning at Index, then everything
        -:  462:      --  from Index is deleted. There are no elements to slide down, and so
        -:  463:      --  all we need to do is set the value of Container.Last.
        -:  464:
    #####:  465:      if Count >= Count2 then
    #####:  466:         Container.Last := Index - 1;
    #####:  467:         return;
        -:  468:      end if;
        -:  469:
        -:  470:      --  There are some elements that aren't being deleted (the requested
        -:  471:      --  count was less than the available count), so we must slide them down
        -:  472:      --  to Index. We first calculate the index values of the respective array
        -:  473:      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the
        -:  474:      --  type for intermediate calculations. For the elements that slide down,
        -:  475:      --  index value New_Last is the last index value of their new home, and
        -:  476:      --  index value J is the first index of their old home.
        -:  477:
        -:  478:      if Index_Type'Base'Last >= Count_Type_Last then
    #####:  479:         New_Last := Old_Last - Index_Type'Base (Count);
    #####:  480:         J := Index + Index_Type'Base (Count);
        -:  481:      else
        -:  482:         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);
        -:  483:         J := Index_Type'Base (Count_Type'Base (Index) + Count);
        -:  484:      end if;
        -:  485:
        -:  486:      --  The internal elements array isn't guaranteed to exist unless we have
        -:  487:      --  elements, but we have that guarantee here because we know we have
        -:  488:      --  elements to slide.  The array index values for each slice have
        -:  489:      --  already been determined, so we just slide down to Index the elements
        -:  490:      --  that weren't deleted.
        -:  491:
        -:  492:      declare
    #####:  493:         EA : Elements_Array renames Container.Elements.EA;
        -:  494:      begin
    #####:  495:         EA (Index .. New_Last) := EA (J .. Old_Last);
    #####:  496:         Container.Last := New_Last;
        -:  497:      end;
        -:  498:   end Delete;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__delete.315:
    #####:  387:   procedure Delete
        -:  388:     (Container : in out Vector;
        -:  389:      Index     : Extended_Index;
        -:  390:      Count     : Count_Type := 1)
        -:  391:   is
    #####:  392:      Old_Last : constant Index_Type'Base := Container.Last;
        -:  393:      New_Last : Index_Type'Base;
        -:  394:      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last
        -:  395:      J        : Index_Type'Base;  -- first index of items that slide down
        -:  396:
        -:  397:   begin
        -:  398:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  399:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  400:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  401:      --  the count on exit. Delete checks the count to determine whether it is
        -:  402:      --  being called while the associated callback procedure is executing.
        -:  403:
    #####:  404:      TC_Check (Container.TC);
        -:  405:
        -:  406:      --  Delete removes items from the vector, the number of which is the
        -:  407:      --  minimum of the specified Count and the items (if any) that exist from
        -:  408:      --  Index to Container.Last. There are no constraints on the specified
        -:  409:      --  value of Count (it can be larger than what's available at this
        -:  410:      --  position in the vector, for example), but there are constraints on
        -:  411:      --  the allowed values of the Index.
        -:  412:
        -:  413:      --  As a precondition on the generic actual Index_Type, the base type
        -:  414:      --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  415:      --  that Container.Last assumes when the vector is empty. However, we do
        -:  416:      --  not allow that as the value for Index when specifying which items
        -:  417:      --  should be deleted, so we must manually check. (That the user is
        -:  418:      --  allowed to specify the value at all here is a consequence of the
        -:  419:      --  declaration of the Extended_Index subtype, which includes the values
        -:  420:      --  in the base range that immediately precede and immediately follow the
        -:  421:      --  values in the Index_Type.)
        -:  422:
    #####:  423:      if Checks and then Index < Index_Type'First then
    #####:  424:         raise Constraint_Error with "Index is out of range (too small)";
        -:  425:      end if;
        -:  426:
        -:  427:      --  We do allow a value greater than Container.Last to be specified as
        -:  428:      --  the Index, but only if it's immediately greater. This allows the
        -:  429:      --  corner case of deleting no items from the back end of the vector to
        -:  430:      --  be treated as a no-op. (It is assumed that specifying an index value
        -:  431:      --  greater than Last + 1 indicates some deeper flaw in the caller's
        -:  432:      --  algorithm, so that case is treated as a proper error.)
        -:  433:
    #####:  434:      if Index > Old_Last then
    #####:  435:         if Checks and then Index > Old_Last + 1 then
    #####:  436:            raise Constraint_Error with "Index is out of range (too large)";
        -:  437:         else
    #####:  438:            return;
        -:  439:         end if;
        -:  440:      end if;
        -:  441:
        -:  442:      --  Here and elsewhere we treat deleting 0 items from the container as a
        -:  443:      --  no-op, even when the container is busy, so we simply return.
        -:  444:
    #####:  445:      if Count = 0 then
    #####:  446:         return;
        -:  447:      end if;
        -:  448:
        -:  449:      --  We first calculate what's available for deletion starting at
        -:  450:      --  Index. Here and elsewhere we use the wider of Index_Type'Base and
        -:  451:      --  Count_Type'Base as the type for intermediate values. (See function
        -:  452:      --  Length for more information.)
        -:  453:
        -:  454:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####:  455:         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;
        -:  456:      else
        -:  457:         Count2 := Count_Type'Base (Old_Last - Index + 1);
        -:  458:      end if;
        -:  459:
        -:  460:      --  If more elements are requested (Count) for deletion than are
        -:  461:      --  available (Count2) for deletion beginning at Index, then everything
        -:  462:      --  from Index is deleted. There are no elements to slide down, and so
        -:  463:      --  all we need to do is set the value of Container.Last.
        -:  464:
    #####:  465:      if Count >= Count2 then
    #####:  466:         Container.Last := Index - 1;
    #####:  467:         return;
        -:  468:      end if;
        -:  469:
        -:  470:      --  There are some elements that aren't being deleted (the requested
        -:  471:      --  count was less than the available count), so we must slide them down
        -:  472:      --  to Index. We first calculate the index values of the respective array
        -:  473:      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the
        -:  474:      --  type for intermediate calculations. For the elements that slide down,
        -:  475:      --  index value New_Last is the last index value of their new home, and
        -:  476:      --  index value J is the first index of their old home.
        -:  477:
        -:  478:      if Index_Type'Base'Last >= Count_Type_Last then
    #####:  479:         New_Last := Old_Last - Index_Type'Base (Count);
    #####:  480:         J := Index + Index_Type'Base (Count);
        -:  481:      else
        -:  482:         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);
        -:  483:         J := Index_Type'Base (Count_Type'Base (Index) + Count);
        -:  484:      end if;
        -:  485:
        -:  486:      --  The internal elements array isn't guaranteed to exist unless we have
        -:  487:      --  elements, but we have that guarantee here because we know we have
        -:  488:      --  elements to slide.  The array index values for each slice have
        -:  489:      --  already been determined, so we just slide down to Index the elements
        -:  490:      --  that weren't deleted.
        -:  491:
        -:  492:      declare
    #####:  493:         EA : Elements_Array renames Container.Elements.EA;
        -:  494:      begin
    #####:  495:         EA (Index .. New_Last) := EA (J .. Old_Last);
    #####:  496:         Container.Last := New_Last;
        -:  497:      end;
        -:  498:   end Delete;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__delete.545:
    #####:  387:   procedure Delete
        -:  388:     (Container : in out Vector;
        -:  389:      Index     : Extended_Index;
        -:  390:      Count     : Count_Type := 1)
        -:  391:   is
    #####:  392:      Old_Last : constant Index_Type'Base := Container.Last;
        -:  393:      New_Last : Index_Type'Base;
        -:  394:      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last
        -:  395:      J        : Index_Type'Base;  -- first index of items that slide down
        -:  396:
        -:  397:   begin
        -:  398:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  399:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  400:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  401:      --  the count on exit. Delete checks the count to determine whether it is
        -:  402:      --  being called while the associated callback procedure is executing.
        -:  403:
    #####:  404:      TC_Check (Container.TC);
        -:  405:
        -:  406:      --  Delete removes items from the vector, the number of which is the
        -:  407:      --  minimum of the specified Count and the items (if any) that exist from
        -:  408:      --  Index to Container.Last. There are no constraints on the specified
        -:  409:      --  value of Count (it can be larger than what's available at this
        -:  410:      --  position in the vector, for example), but there are constraints on
        -:  411:      --  the allowed values of the Index.
        -:  412:
        -:  413:      --  As a precondition on the generic actual Index_Type, the base type
        -:  414:      --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  415:      --  that Container.Last assumes when the vector is empty. However, we do
        -:  416:      --  not allow that as the value for Index when specifying which items
        -:  417:      --  should be deleted, so we must manually check. (That the user is
        -:  418:      --  allowed to specify the value at all here is a consequence of the
        -:  419:      --  declaration of the Extended_Index subtype, which includes the values
        -:  420:      --  in the base range that immediately precede and immediately follow the
        -:  421:      --  values in the Index_Type.)
        -:  422:
    #####:  423:      if Checks and then Index < Index_Type'First then
    #####:  424:         raise Constraint_Error with "Index is out of range (too small)";
        -:  425:      end if;
        -:  426:
        -:  427:      --  We do allow a value greater than Container.Last to be specified as
        -:  428:      --  the Index, but only if it's immediately greater. This allows the
        -:  429:      --  corner case of deleting no items from the back end of the vector to
        -:  430:      --  be treated as a no-op. (It is assumed that specifying an index value
        -:  431:      --  greater than Last + 1 indicates some deeper flaw in the caller's
        -:  432:      --  algorithm, so that case is treated as a proper error.)
        -:  433:
    #####:  434:      if Index > Old_Last then
    #####:  435:         if Checks and then Index > Old_Last + 1 then
    #####:  436:            raise Constraint_Error with "Index is out of range (too large)";
        -:  437:         else
    #####:  438:            return;
        -:  439:         end if;
        -:  440:      end if;
        -:  441:
        -:  442:      --  Here and elsewhere we treat deleting 0 items from the container as a
        -:  443:      --  no-op, even when the container is busy, so we simply return.
        -:  444:
    #####:  445:      if Count = 0 then
    #####:  446:         return;
        -:  447:      end if;
        -:  448:
        -:  449:      --  We first calculate what's available for deletion starting at
        -:  450:      --  Index. Here and elsewhere we use the wider of Index_Type'Base and
        -:  451:      --  Count_Type'Base as the type for intermediate values. (See function
        -:  452:      --  Length for more information.)
        -:  453:
        -:  454:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####:  455:         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;
        -:  456:      else
        -:  457:         Count2 := Count_Type'Base (Old_Last - Index + 1);
        -:  458:      end if;
        -:  459:
        -:  460:      --  If more elements are requested (Count) for deletion than are
        -:  461:      --  available (Count2) for deletion beginning at Index, then everything
        -:  462:      --  from Index is deleted. There are no elements to slide down, and so
        -:  463:      --  all we need to do is set the value of Container.Last.
        -:  464:
    #####:  465:      if Count >= Count2 then
    #####:  466:         Container.Last := Index - 1;
    #####:  467:         return;
        -:  468:      end if;
        -:  469:
        -:  470:      --  There are some elements that aren't being deleted (the requested
        -:  471:      --  count was less than the available count), so we must slide them down
        -:  472:      --  to Index. We first calculate the index values of the respective array
        -:  473:      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the
        -:  474:      --  type for intermediate calculations. For the elements that slide down,
        -:  475:      --  index value New_Last is the last index value of their new home, and
        -:  476:      --  index value J is the first index of their old home.
        -:  477:
        -:  478:      if Index_Type'Base'Last >= Count_Type_Last then
    #####:  479:         New_Last := Old_Last - Index_Type'Base (Count);
    #####:  480:         J := Index + Index_Type'Base (Count);
        -:  481:      else
        -:  482:         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);
        -:  483:         J := Index_Type'Base (Count_Type'Base (Index) + Count);
        -:  484:      end if;
        -:  485:
        -:  486:      --  The internal elements array isn't guaranteed to exist unless we have
        -:  487:      --  elements, but we have that guarantee here because we know we have
        -:  488:      --  elements to slide.  The array index values for each slice have
        -:  489:      --  already been determined, so we just slide down to Index the elements
        -:  490:      --  that weren't deleted.
        -:  491:
        -:  492:      declare
    #####:  493:         EA : Elements_Array renames Container.Elements.EA;
        -:  494:      begin
    #####:  495:         EA (Index .. New_Last) := EA (J .. Old_Last);
    #####:  496:         Container.Last := New_Last;
        -:  497:      end;
        -:  498:   end Delete;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__delete.674:
    #####:  387:   procedure Delete
        -:  388:     (Container : in out Vector;
        -:  389:      Index     : Extended_Index;
        -:  390:      Count     : Count_Type := 1)
        -:  391:   is
    #####:  392:      Old_Last : constant Index_Type'Base := Container.Last;
        -:  393:      New_Last : Index_Type'Base;
        -:  394:      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last
        -:  395:      J        : Index_Type'Base;  -- first index of items that slide down
        -:  396:
        -:  397:   begin
        -:  398:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  399:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  400:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  401:      --  the count on exit. Delete checks the count to determine whether it is
        -:  402:      --  being called while the associated callback procedure is executing.
        -:  403:
    #####:  404:      TC_Check (Container.TC);
        -:  405:
        -:  406:      --  Delete removes items from the vector, the number of which is the
        -:  407:      --  minimum of the specified Count and the items (if any) that exist from
        -:  408:      --  Index to Container.Last. There are no constraints on the specified
        -:  409:      --  value of Count (it can be larger than what's available at this
        -:  410:      --  position in the vector, for example), but there are constraints on
        -:  411:      --  the allowed values of the Index.
        -:  412:
        -:  413:      --  As a precondition on the generic actual Index_Type, the base type
        -:  414:      --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  415:      --  that Container.Last assumes when the vector is empty. However, we do
        -:  416:      --  not allow that as the value for Index when specifying which items
        -:  417:      --  should be deleted, so we must manually check. (That the user is
        -:  418:      --  allowed to specify the value at all here is a consequence of the
        -:  419:      --  declaration of the Extended_Index subtype, which includes the values
        -:  420:      --  in the base range that immediately precede and immediately follow the
        -:  421:      --  values in the Index_Type.)
        -:  422:
    #####:  423:      if Checks and then Index < Index_Type'First then
    #####:  424:         raise Constraint_Error with "Index is out of range (too small)";
        -:  425:      end if;
        -:  426:
        -:  427:      --  We do allow a value greater than Container.Last to be specified as
        -:  428:      --  the Index, but only if it's immediately greater. This allows the
        -:  429:      --  corner case of deleting no items from the back end of the vector to
        -:  430:      --  be treated as a no-op. (It is assumed that specifying an index value
        -:  431:      --  greater than Last + 1 indicates some deeper flaw in the caller's
        -:  432:      --  algorithm, so that case is treated as a proper error.)
        -:  433:
    #####:  434:      if Index > Old_Last then
    #####:  435:         if Checks and then Index > Old_Last + 1 then
    #####:  436:            raise Constraint_Error with "Index is out of range (too large)";
        -:  437:         else
    #####:  438:            return;
        -:  439:         end if;
        -:  440:      end if;
        -:  441:
        -:  442:      --  Here and elsewhere we treat deleting 0 items from the container as a
        -:  443:      --  no-op, even when the container is busy, so we simply return.
        -:  444:
    #####:  445:      if Count = 0 then
    #####:  446:         return;
        -:  447:      end if;
        -:  448:
        -:  449:      --  We first calculate what's available for deletion starting at
        -:  450:      --  Index. Here and elsewhere we use the wider of Index_Type'Base and
        -:  451:      --  Count_Type'Base as the type for intermediate values. (See function
        -:  452:      --  Length for more information.)
        -:  453:
        -:  454:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####:  455:         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;
        -:  456:      else
        -:  457:         Count2 := Count_Type'Base (Old_Last - Index + 1);
        -:  458:      end if;
        -:  459:
        -:  460:      --  If more elements are requested (Count) for deletion than are
        -:  461:      --  available (Count2) for deletion beginning at Index, then everything
        -:  462:      --  from Index is deleted. There are no elements to slide down, and so
        -:  463:      --  all we need to do is set the value of Container.Last.
        -:  464:
    #####:  465:      if Count >= Count2 then
    #####:  466:         Container.Last := Index - 1;
    #####:  467:         return;
        -:  468:      end if;
        -:  469:
        -:  470:      --  There are some elements that aren't being deleted (the requested
        -:  471:      --  count was less than the available count), so we must slide them down
        -:  472:      --  to Index. We first calculate the index values of the respective array
        -:  473:      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the
        -:  474:      --  type for intermediate calculations. For the elements that slide down,
        -:  475:      --  index value New_Last is the last index value of their new home, and
        -:  476:      --  index value J is the first index of their old home.
        -:  477:
        -:  478:      if Index_Type'Base'Last >= Count_Type_Last then
    #####:  479:         New_Last := Old_Last - Index_Type'Base (Count);
    #####:  480:         J := Index + Index_Type'Base (Count);
        -:  481:      else
        -:  482:         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);
        -:  483:         J := Index_Type'Base (Count_Type'Base (Index) + Count);
        -:  484:      end if;
        -:  485:
        -:  486:      --  The internal elements array isn't guaranteed to exist unless we have
        -:  487:      --  elements, but we have that guarantee here because we know we have
        -:  488:      --  elements to slide.  The array index values for each slice have
        -:  489:      --  already been determined, so we just slide down to Index the elements
        -:  490:      --  that weren't deleted.
        -:  491:
        -:  492:      declare
    #####:  493:         EA : Elements_Array renames Container.Elements.EA;
        -:  494:      begin
    #####:  495:         EA (Index .. New_Last) := EA (J .. Old_Last);
    #####:  496:         Container.Last := New_Last;
        -:  497:      end;
        -:  498:   end Delete;
------------------
        -:  499:
    #####:  500:   procedure Delete
        -:  501:     (Container : in out Vector;
        -:  502:      Position  : in out Cursor;
        -:  503:      Count     : Count_Type := 1)
        -:  504:   is
        -:  505:   begin
        -:  506:      if Checks then
    #####:  507:         if Position.Container = null then
    #####:  508:            raise Constraint_Error with "Position cursor has no element";
        -:  509:
    #####:  510:         elsif Position.Container /= Container'Unrestricted_Access then
    #####:  511:            raise Program_Error with "Position cursor denotes wrong container";
        -:  512:
    #####:  513:         elsif Position.Index > Container.Last then
    #####:  514:            raise Program_Error with "Position index is out of range";
        -:  515:         end if;
        -:  516:      end if;
        -:  517:
    #####:  518:      Delete (Container, Position.Index, Count);
    #####:  519:      Position := No_Element;
    #####:  520:   end Delete;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__delete__2.185:
    #####:  500:   procedure Delete
        -:  501:     (Container : in out Vector;
        -:  502:      Position  : in out Cursor;
        -:  503:      Count     : Count_Type := 1)
        -:  504:   is
        -:  505:   begin
        -:  506:      if Checks then
    #####:  507:         if Position.Container = null then
    #####:  508:            raise Constraint_Error with "Position cursor has no element";
        -:  509:
    #####:  510:         elsif Position.Container /= Container'Unrestricted_Access then
    #####:  511:            raise Program_Error with "Position cursor denotes wrong container";
        -:  512:
    #####:  513:         elsif Position.Index > Container.Last then
    #####:  514:            raise Program_Error with "Position index is out of range";
        -:  515:         end if;
        -:  516:      end if;
        -:  517:
    #####:  518:      Delete (Container, Position.Index, Count);
    #####:  519:      Position := No_Element;
    #####:  520:   end Delete;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__delete__2.314:
    #####:  500:   procedure Delete
        -:  501:     (Container : in out Vector;
        -:  502:      Position  : in out Cursor;
        -:  503:      Count     : Count_Type := 1)
        -:  504:   is
        -:  505:   begin
        -:  506:      if Checks then
    #####:  507:         if Position.Container = null then
    #####:  508:            raise Constraint_Error with "Position cursor has no element";
        -:  509:
    #####:  510:         elsif Position.Container /= Container'Unrestricted_Access then
    #####:  511:            raise Program_Error with "Position cursor denotes wrong container";
        -:  512:
    #####:  513:         elsif Position.Index > Container.Last then
    #####:  514:            raise Program_Error with "Position index is out of range";
        -:  515:         end if;
        -:  516:      end if;
        -:  517:
    #####:  518:      Delete (Container, Position.Index, Count);
    #####:  519:      Position := No_Element;
    #####:  520:   end Delete;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__delete__2.544:
    #####:  500:   procedure Delete
        -:  501:     (Container : in out Vector;
        -:  502:      Position  : in out Cursor;
        -:  503:      Count     : Count_Type := 1)
        -:  504:   is
        -:  505:   begin
        -:  506:      if Checks then
    #####:  507:         if Position.Container = null then
    #####:  508:            raise Constraint_Error with "Position cursor has no element";
        -:  509:
    #####:  510:         elsif Position.Container /= Container'Unrestricted_Access then
    #####:  511:            raise Program_Error with "Position cursor denotes wrong container";
        -:  512:
    #####:  513:         elsif Position.Index > Container.Last then
    #####:  514:            raise Program_Error with "Position index is out of range";
        -:  515:         end if;
        -:  516:      end if;
        -:  517:
    #####:  518:      Delete (Container, Position.Index, Count);
    #####:  519:      Position := No_Element;
    #####:  520:   end Delete;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__delete__2.673:
    #####:  500:   procedure Delete
        -:  501:     (Container : in out Vector;
        -:  502:      Position  : in out Cursor;
        -:  503:      Count     : Count_Type := 1)
        -:  504:   is
        -:  505:   begin
        -:  506:      if Checks then
    #####:  507:         if Position.Container = null then
    #####:  508:            raise Constraint_Error with "Position cursor has no element";
        -:  509:
    #####:  510:         elsif Position.Container /= Container'Unrestricted_Access then
    #####:  511:            raise Program_Error with "Position cursor denotes wrong container";
        -:  512:
    #####:  513:         elsif Position.Index > Container.Last then
    #####:  514:            raise Program_Error with "Position index is out of range";
        -:  515:         end if;
        -:  516:      end if;
        -:  517:
    #####:  518:      Delete (Container, Position.Index, Count);
    #####:  519:      Position := No_Element;
    #####:  520:   end Delete;
------------------
        -:  521:
        -:  522:   ------------------
        -:  523:   -- Delete_First --
        -:  524:   ------------------
        -:  525:
    #####:  526:   procedure Delete_First
        -:  527:     (Container : in out Vector;
        -:  528:      Count     : Count_Type := 1)
        -:  529:   is
        -:  530:   begin
    #####:  531:      if Count = 0 then
    #####:  532:         return;
        -:  533:
    #####:  534:      elsif Count >= Length (Container) then
    #####:  535:         Clear (Container);
    #####:  536:         return;
        -:  537:
        -:  538:      else
    #####:  539:         Delete (Container, Index_Type'First, Count);
        -:  540:      end if;
        -:  541:   end Delete_First;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__delete_first.184:
    #####:  526:   procedure Delete_First
        -:  527:     (Container : in out Vector;
        -:  528:      Count     : Count_Type := 1)
        -:  529:   is
        -:  530:   begin
    #####:  531:      if Count = 0 then
    #####:  532:         return;
        -:  533:
    #####:  534:      elsif Count >= Length (Container) then
    #####:  535:         Clear (Container);
    #####:  536:         return;
        -:  537:
        -:  538:      else
    #####:  539:         Delete (Container, Index_Type'First, Count);
        -:  540:      end if;
        -:  541:   end Delete_First;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__delete_first.313:
    #####:  526:   procedure Delete_First
        -:  527:     (Container : in out Vector;
        -:  528:      Count     : Count_Type := 1)
        -:  529:   is
        -:  530:   begin
    #####:  531:      if Count = 0 then
    #####:  532:         return;
        -:  533:
    #####:  534:      elsif Count >= Length (Container) then
    #####:  535:         Clear (Container);
    #####:  536:         return;
        -:  537:
        -:  538:      else
    #####:  539:         Delete (Container, Index_Type'First, Count);
        -:  540:      end if;
        -:  541:   end Delete_First;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__delete_first.543:
    #####:  526:   procedure Delete_First
        -:  527:     (Container : in out Vector;
        -:  528:      Count     : Count_Type := 1)
        -:  529:   is
        -:  530:   begin
    #####:  531:      if Count = 0 then
    #####:  532:         return;
        -:  533:
    #####:  534:      elsif Count >= Length (Container) then
    #####:  535:         Clear (Container);
    #####:  536:         return;
        -:  537:
        -:  538:      else
    #####:  539:         Delete (Container, Index_Type'First, Count);
        -:  540:      end if;
        -:  541:   end Delete_First;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__delete_first.672:
    #####:  526:   procedure Delete_First
        -:  527:     (Container : in out Vector;
        -:  528:      Count     : Count_Type := 1)
        -:  529:   is
        -:  530:   begin
    #####:  531:      if Count = 0 then
    #####:  532:         return;
        -:  533:
    #####:  534:      elsif Count >= Length (Container) then
    #####:  535:         Clear (Container);
    #####:  536:         return;
        -:  537:
        -:  538:      else
    #####:  539:         Delete (Container, Index_Type'First, Count);
        -:  540:      end if;
        -:  541:   end Delete_First;
------------------
        -:  542:
        -:  543:   -----------------
        -:  544:   -- Delete_Last --
        -:  545:   -----------------
        -:  546:
    #####:  547:   procedure Delete_Last
        -:  548:     (Container : in out Vector;
        -:  549:      Count     : Count_Type := 1)
        -:  550:   is
        -:  551:   begin
        -:  552:      --  It is not permitted to delete items while the container is busy (for
        -:  553:      --  example, we're in the middle of a passive iteration). However, we
        -:  554:      --  always treat deleting 0 items as a no-op, even when we're busy, so we
        -:  555:      --  simply return without checking.
        -:  556:
    #####:  557:      if Count = 0 then
    #####:  558:         return;
        -:  559:      end if;
        -:  560:
        -:  561:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  562:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  563:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  564:      --  the count on exit. Delete_Last checks the count to determine whether
        -:  565:      --  it is being called while the associated callback procedure is
        -:  566:      --  executing.
        -:  567:
    #####:  568:      TC_Check (Container.TC);
        -:  569:
        -:  570:      --  There is no restriction on how large Count can be when deleting
        -:  571:      --  items. If it is equal or greater than the current length, then this
        -:  572:      --  is equivalent to clearing the vector. (In particular, there's no need
        -:  573:      --  for us to actually calculate the new value for Last.)
        -:  574:
        -:  575:      --  If the requested count is less than the current length, then we must
        -:  576:      --  calculate the new value for Last. For the type we use the widest of
        -:  577:      --  Index_Type'Base and Count_Type'Base for the intermediate values of
        -:  578:      --  our calculation.  (See the comments in Length for more information.)
        -:  579:
    #####:  580:      if Count >= Container.Length then
    #####:  581:         Container.Last := No_Index;
        -:  582:
        -:  583:      elsif Index_Type'Base'Last >= Count_Type_Last then
    #####:  584:         Container.Last := Container.Last - Index_Type'Base (Count);
        -:  585:
        -:  586:      else
        -:  587:         Container.Last :=
        -:  588:           Index_Type'Base (Count_Type'Base (Container.Last) - Count);
        -:  589:      end if;
        -:  590:   end Delete_Last;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__delete_last.183:
    #####:  547:   procedure Delete_Last
        -:  548:     (Container : in out Vector;
        -:  549:      Count     : Count_Type := 1)
        -:  550:   is
        -:  551:   begin
        -:  552:      --  It is not permitted to delete items while the container is busy (for
        -:  553:      --  example, we're in the middle of a passive iteration). However, we
        -:  554:      --  always treat deleting 0 items as a no-op, even when we're busy, so we
        -:  555:      --  simply return without checking.
        -:  556:
    #####:  557:      if Count = 0 then
    #####:  558:         return;
        -:  559:      end if;
        -:  560:
        -:  561:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  562:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  563:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  564:      --  the count on exit. Delete_Last checks the count to determine whether
        -:  565:      --  it is being called while the associated callback procedure is
        -:  566:      --  executing.
        -:  567:
    #####:  568:      TC_Check (Container.TC);
        -:  569:
        -:  570:      --  There is no restriction on how large Count can be when deleting
        -:  571:      --  items. If it is equal or greater than the current length, then this
        -:  572:      --  is equivalent to clearing the vector. (In particular, there's no need
        -:  573:      --  for us to actually calculate the new value for Last.)
        -:  574:
        -:  575:      --  If the requested count is less than the current length, then we must
        -:  576:      --  calculate the new value for Last. For the type we use the widest of
        -:  577:      --  Index_Type'Base and Count_Type'Base for the intermediate values of
        -:  578:      --  our calculation.  (See the comments in Length for more information.)
        -:  579:
    #####:  580:      if Count >= Container.Length then
    #####:  581:         Container.Last := No_Index;
        -:  582:
        -:  583:      elsif Index_Type'Base'Last >= Count_Type_Last then
    #####:  584:         Container.Last := Container.Last - Index_Type'Base (Count);
        -:  585:
        -:  586:      else
        -:  587:         Container.Last :=
        -:  588:           Index_Type'Base (Count_Type'Base (Container.Last) - Count);
        -:  589:      end if;
        -:  590:   end Delete_Last;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__delete_last.312:
    #####:  547:   procedure Delete_Last
        -:  548:     (Container : in out Vector;
        -:  549:      Count     : Count_Type := 1)
        -:  550:   is
        -:  551:   begin
        -:  552:      --  It is not permitted to delete items while the container is busy (for
        -:  553:      --  example, we're in the middle of a passive iteration). However, we
        -:  554:      --  always treat deleting 0 items as a no-op, even when we're busy, so we
        -:  555:      --  simply return without checking.
        -:  556:
    #####:  557:      if Count = 0 then
    #####:  558:         return;
        -:  559:      end if;
        -:  560:
        -:  561:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  562:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  563:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  564:      --  the count on exit. Delete_Last checks the count to determine whether
        -:  565:      --  it is being called while the associated callback procedure is
        -:  566:      --  executing.
        -:  567:
    #####:  568:      TC_Check (Container.TC);
        -:  569:
        -:  570:      --  There is no restriction on how large Count can be when deleting
        -:  571:      --  items. If it is equal or greater than the current length, then this
        -:  572:      --  is equivalent to clearing the vector. (In particular, there's no need
        -:  573:      --  for us to actually calculate the new value for Last.)
        -:  574:
        -:  575:      --  If the requested count is less than the current length, then we must
        -:  576:      --  calculate the new value for Last. For the type we use the widest of
        -:  577:      --  Index_Type'Base and Count_Type'Base for the intermediate values of
        -:  578:      --  our calculation.  (See the comments in Length for more information.)
        -:  579:
    #####:  580:      if Count >= Container.Length then
    #####:  581:         Container.Last := No_Index;
        -:  582:
        -:  583:      elsif Index_Type'Base'Last >= Count_Type_Last then
    #####:  584:         Container.Last := Container.Last - Index_Type'Base (Count);
        -:  585:
        -:  586:      else
        -:  587:         Container.Last :=
        -:  588:           Index_Type'Base (Count_Type'Base (Container.Last) - Count);
        -:  589:      end if;
        -:  590:   end Delete_Last;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__delete_last.542:
    #####:  547:   procedure Delete_Last
        -:  548:     (Container : in out Vector;
        -:  549:      Count     : Count_Type := 1)
        -:  550:   is
        -:  551:   begin
        -:  552:      --  It is not permitted to delete items while the container is busy (for
        -:  553:      --  example, we're in the middle of a passive iteration). However, we
        -:  554:      --  always treat deleting 0 items as a no-op, even when we're busy, so we
        -:  555:      --  simply return without checking.
        -:  556:
    #####:  557:      if Count = 0 then
    #####:  558:         return;
        -:  559:      end if;
        -:  560:
        -:  561:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  562:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  563:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  564:      --  the count on exit. Delete_Last checks the count to determine whether
        -:  565:      --  it is being called while the associated callback procedure is
        -:  566:      --  executing.
        -:  567:
    #####:  568:      TC_Check (Container.TC);
        -:  569:
        -:  570:      --  There is no restriction on how large Count can be when deleting
        -:  571:      --  items. If it is equal or greater than the current length, then this
        -:  572:      --  is equivalent to clearing the vector. (In particular, there's no need
        -:  573:      --  for us to actually calculate the new value for Last.)
        -:  574:
        -:  575:      --  If the requested count is less than the current length, then we must
        -:  576:      --  calculate the new value for Last. For the type we use the widest of
        -:  577:      --  Index_Type'Base and Count_Type'Base for the intermediate values of
        -:  578:      --  our calculation.  (See the comments in Length for more information.)
        -:  579:
    #####:  580:      if Count >= Container.Length then
    #####:  581:         Container.Last := No_Index;
        -:  582:
        -:  583:      elsif Index_Type'Base'Last >= Count_Type_Last then
    #####:  584:         Container.Last := Container.Last - Index_Type'Base (Count);
        -:  585:
        -:  586:      else
        -:  587:         Container.Last :=
        -:  588:           Index_Type'Base (Count_Type'Base (Container.Last) - Count);
        -:  589:      end if;
        -:  590:   end Delete_Last;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__delete_last.671:
    #####:  547:   procedure Delete_Last
        -:  548:     (Container : in out Vector;
        -:  549:      Count     : Count_Type := 1)
        -:  550:   is
        -:  551:   begin
        -:  552:      --  It is not permitted to delete items while the container is busy (for
        -:  553:      --  example, we're in the middle of a passive iteration). However, we
        -:  554:      --  always treat deleting 0 items as a no-op, even when we're busy, so we
        -:  555:      --  simply return without checking.
        -:  556:
    #####:  557:      if Count = 0 then
    #####:  558:         return;
        -:  559:      end if;
        -:  560:
        -:  561:      --  The tampering bits exist to prevent an item from being deleted (or
        -:  562:      --  otherwise harmfully manipulated) while it is being visited. Query,
        -:  563:      --  Update, and Iterate increment the busy count on entry, and decrement
        -:  564:      --  the count on exit. Delete_Last checks the count to determine whether
        -:  565:      --  it is being called while the associated callback procedure is
        -:  566:      --  executing.
        -:  567:
    #####:  568:      TC_Check (Container.TC);
        -:  569:
        -:  570:      --  There is no restriction on how large Count can be when deleting
        -:  571:      --  items. If it is equal or greater than the current length, then this
        -:  572:      --  is equivalent to clearing the vector. (In particular, there's no need
        -:  573:      --  for us to actually calculate the new value for Last.)
        -:  574:
        -:  575:      --  If the requested count is less than the current length, then we must
        -:  576:      --  calculate the new value for Last. For the type we use the widest of
        -:  577:      --  Index_Type'Base and Count_Type'Base for the intermediate values of
        -:  578:      --  our calculation.  (See the comments in Length for more information.)
        -:  579:
    #####:  580:      if Count >= Container.Length then
    #####:  581:         Container.Last := No_Index;
        -:  582:
        -:  583:      elsif Index_Type'Base'Last >= Count_Type_Last then
    #####:  584:         Container.Last := Container.Last - Index_Type'Base (Count);
        -:  585:
        -:  586:      else
        -:  587:         Container.Last :=
        -:  588:           Index_Type'Base (Count_Type'Base (Container.Last) - Count);
        -:  589:      end if;
        -:  590:   end Delete_Last;
------------------
        -:  591:
        -:  592:   -------------
        -:  593:   -- Element --
        -:  594:   -------------
        -:  595:
    #####:  596:   function Element
        -:  597:     (Container : Vector;
        -:  598:      Index     : Index_Type) return Element_Type
        -:  599:   is
        -:  600:   begin
    #####:  601:      if Checks and then Index > Container.Last then
    #####:  602:         raise Constraint_Error with "Index is out of range";
        -:  603:      end if;
        -:  604:
    #####:  605:      return Container.Elements.EA (Index);
        -:  606:   end Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__element.182:
    #####:  596:   function Element
        -:  597:     (Container : Vector;
        -:  598:      Index     : Index_Type) return Element_Type
        -:  599:   is
        -:  600:   begin
    #####:  601:      if Checks and then Index > Container.Last then
    #####:  602:         raise Constraint_Error with "Index is out of range";
        -:  603:      end if;
        -:  604:
    #####:  605:      return Container.Elements.EA (Index);
        -:  606:   end Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__element.311:
    #####:  596:   function Element
        -:  597:     (Container : Vector;
        -:  598:      Index     : Index_Type) return Element_Type
        -:  599:   is
        -:  600:   begin
    #####:  601:      if Checks and then Index > Container.Last then
    #####:  602:         raise Constraint_Error with "Index is out of range";
        -:  603:      end if;
        -:  604:
    #####:  605:      return Container.Elements.EA (Index);
        -:  606:   end Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__element.541:
    #####:  596:   function Element
        -:  597:     (Container : Vector;
        -:  598:      Index     : Index_Type) return Element_Type
        -:  599:   is
        -:  600:   begin
    #####:  601:      if Checks and then Index > Container.Last then
    #####:  602:         raise Constraint_Error with "Index is out of range";
        -:  603:      end if;
        -:  604:
    #####:  605:      return Container.Elements.EA (Index);
        -:  606:   end Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__element.670:
    #####:  596:   function Element
        -:  597:     (Container : Vector;
        -:  598:      Index     : Index_Type) return Element_Type
        -:  599:   is
        -:  600:   begin
    #####:  601:      if Checks and then Index > Container.Last then
    #####:  602:         raise Constraint_Error with "Index is out of range";
        -:  603:      end if;
        -:  604:
    #####:  605:      return Container.Elements.EA (Index);
        -:  606:   end Element;
------------------
        -:  607:
        -:  608:   function Element (Position : Cursor) return Element_Type is
        -:  609:   begin
        -:  610:      if Checks then
        -:  611:         if Position.Container = null then
        -:  612:            raise Constraint_Error with "Position cursor has no element";
        -:  613:         elsif Position.Index > Position.Container.Last then
        -:  614:            raise Constraint_Error with "Position cursor is out of range";
        -:  615:         end if;
        -:  616:      end if;
        -:  617:
        -:  618:      return Position.Container.Elements.EA (Position.Index);
        -:  619:   end Element;
        -:  620:
        -:  621:   -----------
        -:  622:   -- Empty --
        -:  623:   -----------
        -:  624:
    #####:  625:   function Empty (Capacity : Count_Type := 10) return Vector is
        -:  626:   begin
    #####:  627:      return Result : Vector do
    #####:  628:         Reserve_Capacity (Result, Capacity);
        -:  629:      end return;
        -:  630:   end Empty;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__empty.180:
    #####:  625:   function Empty (Capacity : Count_Type := 10) return Vector is
        -:  626:   begin
    #####:  627:      return Result : Vector do
    #####:  628:         Reserve_Capacity (Result, Capacity);
        -:  629:      end return;
        -:  630:   end Empty;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__empty.309:
    #####:  625:   function Empty (Capacity : Count_Type := 10) return Vector is
        -:  626:   begin
    #####:  627:      return Result : Vector do
    #####:  628:         Reserve_Capacity (Result, Capacity);
        -:  629:      end return;
        -:  630:   end Empty;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__empty.539:
    #####:  625:   function Empty (Capacity : Count_Type := 10) return Vector is
        -:  626:   begin
    #####:  627:      return Result : Vector do
    #####:  628:         Reserve_Capacity (Result, Capacity);
        -:  629:      end return;
        -:  630:   end Empty;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__empty.668:
    #####:  625:   function Empty (Capacity : Count_Type := 10) return Vector is
        -:  626:   begin
    #####:  627:      return Result : Vector do
    #####:  628:         Reserve_Capacity (Result, Capacity);
        -:  629:      end return;
        -:  630:   end Empty;
------------------
        -:  631:
        -:  632:   --------------
        -:  633:   -- Finalize --
        -:  634:   --------------
        -:  635:
    #####:  636:   procedure Finalize (Container : in out Vector) is
    #####:  637:      X : Elements_Access := Container.Elements;
        -:  638:
        -:  639:   begin
    #####:  640:      Container.Elements := null;
    #####:  641:      Container.Last := No_Index;
        -:  642:
    #####:  643:      Free (X);
        -:  644:
    #####:  645:      TC_Check (Container.TC);
    #####:  646:   end Finalize;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__finalize__2.179:
    #####:  636:   procedure Finalize (Container : in out Vector) is
    #####:  637:      X : Elements_Access := Container.Elements;
        -:  638:
        -:  639:   begin
    #####:  640:      Container.Elements := null;
    #####:  641:      Container.Last := No_Index;
        -:  642:
    #####:  643:      Free (X);
        -:  644:
    #####:  645:      TC_Check (Container.TC);
    #####:  646:   end Finalize;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__finalize__2.308:
    #####:  636:   procedure Finalize (Container : in out Vector) is
    #####:  637:      X : Elements_Access := Container.Elements;
        -:  638:
        -:  639:   begin
    #####:  640:      Container.Elements := null;
    #####:  641:      Container.Last := No_Index;
        -:  642:
    #####:  643:      Free (X);
        -:  644:
    #####:  645:      TC_Check (Container.TC);
    #####:  646:   end Finalize;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__finalize__2.538:
    #####:  636:   procedure Finalize (Container : in out Vector) is
    #####:  637:      X : Elements_Access := Container.Elements;
        -:  638:
        -:  639:   begin
    #####:  640:      Container.Elements := null;
    #####:  641:      Container.Last := No_Index;
        -:  642:
    #####:  643:      Free (X);
        -:  644:
    #####:  645:      TC_Check (Container.TC);
    #####:  646:   end Finalize;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__finalize__2.667:
    #####:  636:   procedure Finalize (Container : in out Vector) is
    #####:  637:      X : Elements_Access := Container.Elements;
        -:  638:
        -:  639:   begin
    #####:  640:      Container.Elements := null;
    #####:  641:      Container.Last := No_Index;
        -:  642:
    #####:  643:      Free (X);
        -:  644:
    #####:  645:      TC_Check (Container.TC);
    #####:  646:   end Finalize;
------------------
        -:  647:
    #####:  648:   procedure Finalize (Object : in out Iterator) is
        -:  649:   begin
    #####:  650:      Unbusy (Object.Container.TC);
    #####:  651:   end Finalize;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__finalize__4.177:
    #####:  648:   procedure Finalize (Object : in out Iterator) is
        -:  649:   begin
    #####:  650:      Unbusy (Object.Container.TC);
    #####:  651:   end Finalize;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__finalize__4.306:
    #####:  648:   procedure Finalize (Object : in out Iterator) is
        -:  649:   begin
    #####:  650:      Unbusy (Object.Container.TC);
    #####:  651:   end Finalize;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__finalize__4.536:
    #####:  648:   procedure Finalize (Object : in out Iterator) is
        -:  649:   begin
    #####:  650:      Unbusy (Object.Container.TC);
    #####:  651:   end Finalize;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__finalize__4.665:
    #####:  648:   procedure Finalize (Object : in out Iterator) is
        -:  649:   begin
    #####:  650:      Unbusy (Object.Container.TC);
    #####:  651:   end Finalize;
------------------
        -:  652:
        -:  653:   ----------
        -:  654:   -- Find --
        -:  655:   ----------
        -:  656:
    #####:  657:   function Find
        -:  658:     (Container : Vector;
        -:  659:      Item      : Element_Type;
        -:  660:      Position  : Cursor := No_Element) return Cursor
        -:  661:   is
        -:  662:   begin
    #####:  663:      if Checks and then Position.Container /= null then
    #####:  664:         if Position.Container /= Container'Unrestricted_Access then
    #####:  665:            raise Program_Error with "Position cursor denotes wrong container";
        -:  666:         end if;
        -:  667:
    #####:  668:         if Position.Index > Container.Last then
    #####:  669:            raise Program_Error with "Position index is out of range";
        -:  670:         end if;
        -:  671:      end if;
        -:  672:
        -:  673:      --  Per AI05-0022, the container implementation is required to detect
        -:  674:      --  element tampering by a generic actual subprogram.
        -:  675:
    #####:  676:      declare
    #####:  677:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  678:      begin
    #####:  679:         for J in Position.Index .. Container.Last loop
    #####:  680:            if Container.Elements.EA (J) = Item then
    #####:  681:               return Cursor'(Container'Unrestricted_Access, J);
        -:  682:            end if;
    #####:  683:         end loop;
        -:  684:
    #####:  685:         return No_Element;
    #####:  686:      end;
        -:  687:   end Find;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__find.175:
    #####:  657:   function Find
        -:  658:     (Container : Vector;
        -:  659:      Item      : Element_Type;
        -:  660:      Position  : Cursor := No_Element) return Cursor
        -:  661:   is
        -:  662:   begin
    #####:  663:      if Checks and then Position.Container /= null then
    #####:  664:         if Position.Container /= Container'Unrestricted_Access then
    #####:  665:            raise Program_Error with "Position cursor denotes wrong container";
        -:  666:         end if;
        -:  667:
    #####:  668:         if Position.Index > Container.Last then
    #####:  669:            raise Program_Error with "Position index is out of range";
        -:  670:         end if;
        -:  671:      end if;
        -:  672:
        -:  673:      --  Per AI05-0022, the container implementation is required to detect
        -:  674:      --  element tampering by a generic actual subprogram.
        -:  675:
    #####:  676:      declare
    #####:  677:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  678:      begin
    #####:  679:         for J in Position.Index .. Container.Last loop
    #####:  680:            if Container.Elements.EA (J) = Item then
    #####:  681:               return Cursor'(Container'Unrestricted_Access, J);
        -:  682:            end if;
    #####:  683:         end loop;
        -:  684:
    #####:  685:         return No_Element;
    #####:  686:      end;
        -:  687:   end Find;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__find.304:
    #####:  657:   function Find
        -:  658:     (Container : Vector;
        -:  659:      Item      : Element_Type;
        -:  660:      Position  : Cursor := No_Element) return Cursor
        -:  661:   is
        -:  662:   begin
    #####:  663:      if Checks and then Position.Container /= null then
    #####:  664:         if Position.Container /= Container'Unrestricted_Access then
    #####:  665:            raise Program_Error with "Position cursor denotes wrong container";
        -:  666:         end if;
        -:  667:
    #####:  668:         if Position.Index > Container.Last then
    #####:  669:            raise Program_Error with "Position index is out of range";
        -:  670:         end if;
        -:  671:      end if;
        -:  672:
        -:  673:      --  Per AI05-0022, the container implementation is required to detect
        -:  674:      --  element tampering by a generic actual subprogram.
        -:  675:
    #####:  676:      declare
    #####:  677:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  678:      begin
    #####:  679:         for J in Position.Index .. Container.Last loop
    #####:  680:            if Container.Elements.EA (J) = Item then
    #####:  681:               return Cursor'(Container'Unrestricted_Access, J);
        -:  682:            end if;
    #####:  683:         end loop;
        -:  684:
    #####:  685:         return No_Element;
    #####:  686:      end;
        -:  687:   end Find;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__find.534:
    #####:  657:   function Find
        -:  658:     (Container : Vector;
        -:  659:      Item      : Element_Type;
        -:  660:      Position  : Cursor := No_Element) return Cursor
        -:  661:   is
        -:  662:   begin
    #####:  663:      if Checks and then Position.Container /= null then
    #####:  664:         if Position.Container /= Container'Unrestricted_Access then
    #####:  665:            raise Program_Error with "Position cursor denotes wrong container";
        -:  666:         end if;
        -:  667:
    #####:  668:         if Position.Index > Container.Last then
    #####:  669:            raise Program_Error with "Position index is out of range";
        -:  670:         end if;
        -:  671:      end if;
        -:  672:
        -:  673:      --  Per AI05-0022, the container implementation is required to detect
        -:  674:      --  element tampering by a generic actual subprogram.
        -:  675:
    #####:  676:      declare
    #####:  677:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  678:      begin
    #####:  679:         for J in Position.Index .. Container.Last loop
    #####:  680:            if Container.Elements.EA (J) = Item then
    #####:  681:               return Cursor'(Container'Unrestricted_Access, J);
        -:  682:            end if;
    #####:  683:         end loop;
        -:  684:
    #####:  685:         return No_Element;
    #####:  686:      end;
        -:  687:   end Find;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__find.663:
    #####:  657:   function Find
        -:  658:     (Container : Vector;
        -:  659:      Item      : Element_Type;
        -:  660:      Position  : Cursor := No_Element) return Cursor
        -:  661:   is
        -:  662:   begin
    #####:  663:      if Checks and then Position.Container /= null then
    #####:  664:         if Position.Container /= Container'Unrestricted_Access then
    #####:  665:            raise Program_Error with "Position cursor denotes wrong container";
        -:  666:         end if;
        -:  667:
    #####:  668:         if Position.Index > Container.Last then
    #####:  669:            raise Program_Error with "Position index is out of range";
        -:  670:         end if;
        -:  671:      end if;
        -:  672:
        -:  673:      --  Per AI05-0022, the container implementation is required to detect
        -:  674:      --  element tampering by a generic actual subprogram.
        -:  675:
    #####:  676:      declare
    #####:  677:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  678:      begin
    #####:  679:         for J in Position.Index .. Container.Last loop
    #####:  680:            if Container.Elements.EA (J) = Item then
    #####:  681:               return Cursor'(Container'Unrestricted_Access, J);
        -:  682:            end if;
    #####:  683:         end loop;
        -:  684:
    #####:  685:         return No_Element;
    #####:  686:      end;
        -:  687:   end Find;
------------------
        -:  688:
        -:  689:   ----------------
        -:  690:   -- Find_Index --
        -:  691:   ----------------
        -:  692:
    #####:  693:   function Find_Index
        -:  694:     (Container : Vector;
        -:  695:      Item      : Element_Type;
        -:  696:      Index     : Index_Type := Index_Type'First) return Extended_Index
        -:  697:   is
        -:  698:      --  Per AI05-0022, the container implementation is required to detect
        -:  699:      --  element tampering by a generic actual subprogram.
        -:  700:
    #####:  701:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  702:   begin
    #####:  703:      for Indx in Index .. Container.Last loop
    #####:  704:         if Container.Elements.EA (Indx) = Item then
    #####:  705:            return Indx;
        -:  706:         end if;
    #####:  707:      end loop;
        -:  708:
    #####:  709:      return No_Index;
    #####:  710:   end Find_Index;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__find_index.173:
    #####:  693:   function Find_Index
        -:  694:     (Container : Vector;
        -:  695:      Item      : Element_Type;
        -:  696:      Index     : Index_Type := Index_Type'First) return Extended_Index
        -:  697:   is
        -:  698:      --  Per AI05-0022, the container implementation is required to detect
        -:  699:      --  element tampering by a generic actual subprogram.
        -:  700:
    #####:  701:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  702:   begin
    #####:  703:      for Indx in Index .. Container.Last loop
    #####:  704:         if Container.Elements.EA (Indx) = Item then
    #####:  705:            return Indx;
        -:  706:         end if;
    #####:  707:      end loop;
        -:  708:
    #####:  709:      return No_Index;
    #####:  710:   end Find_Index;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__find_index.302:
    #####:  693:   function Find_Index
        -:  694:     (Container : Vector;
        -:  695:      Item      : Element_Type;
        -:  696:      Index     : Index_Type := Index_Type'First) return Extended_Index
        -:  697:   is
        -:  698:      --  Per AI05-0022, the container implementation is required to detect
        -:  699:      --  element tampering by a generic actual subprogram.
        -:  700:
    #####:  701:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  702:   begin
    #####:  703:      for Indx in Index .. Container.Last loop
    #####:  704:         if Container.Elements.EA (Indx) = Item then
    #####:  705:            return Indx;
        -:  706:         end if;
    #####:  707:      end loop;
        -:  708:
    #####:  709:      return No_Index;
    #####:  710:   end Find_Index;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__find_index.532:
    #####:  693:   function Find_Index
        -:  694:     (Container : Vector;
        -:  695:      Item      : Element_Type;
        -:  696:      Index     : Index_Type := Index_Type'First) return Extended_Index
        -:  697:   is
        -:  698:      --  Per AI05-0022, the container implementation is required to detect
        -:  699:      --  element tampering by a generic actual subprogram.
        -:  700:
    #####:  701:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  702:   begin
    #####:  703:      for Indx in Index .. Container.Last loop
    #####:  704:         if Container.Elements.EA (Indx) = Item then
    #####:  705:            return Indx;
        -:  706:         end if;
    #####:  707:      end loop;
        -:  708:
    #####:  709:      return No_Index;
    #####:  710:   end Find_Index;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__find_index.661:
    #####:  693:   function Find_Index
        -:  694:     (Container : Vector;
        -:  695:      Item      : Element_Type;
        -:  696:      Index     : Index_Type := Index_Type'First) return Extended_Index
        -:  697:   is
        -:  698:      --  Per AI05-0022, the container implementation is required to detect
        -:  699:      --  element tampering by a generic actual subprogram.
        -:  700:
    #####:  701:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  702:   begin
    #####:  703:      for Indx in Index .. Container.Last loop
    #####:  704:         if Container.Elements.EA (Indx) = Item then
    #####:  705:            return Indx;
        -:  706:         end if;
    #####:  707:      end loop;
        -:  708:
    #####:  709:      return No_Index;
    #####:  710:   end Find_Index;
------------------
        -:  711:
        -:  712:   -----------
        -:  713:   -- First --
        -:  714:   -----------
        -:  715:
    #####:  716:   function First (Container : Vector) return Cursor is
        -:  717:   begin
    #####:  718:      if Is_Empty (Container) then
    #####:  719:         return No_Element;
        -:  720:      end if;
        -:  721:
    #####:  722:      return (Container'Unrestricted_Access, Index_Type'First);
        -:  723:   end First;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__first.172:
    #####:  716:   function First (Container : Vector) return Cursor is
        -:  717:   begin
    #####:  718:      if Is_Empty (Container) then
    #####:  719:         return No_Element;
        -:  720:      end if;
        -:  721:
    #####:  722:      return (Container'Unrestricted_Access, Index_Type'First);
        -:  723:   end First;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__first.301:
    #####:  716:   function First (Container : Vector) return Cursor is
        -:  717:   begin
    #####:  718:      if Is_Empty (Container) then
    #####:  719:         return No_Element;
        -:  720:      end if;
        -:  721:
    #####:  722:      return (Container'Unrestricted_Access, Index_Type'First);
        -:  723:   end First;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__first.531:
    #####:  716:   function First (Container : Vector) return Cursor is
        -:  717:   begin
    #####:  718:      if Is_Empty (Container) then
    #####:  719:         return No_Element;
        -:  720:      end if;
        -:  721:
    #####:  722:      return (Container'Unrestricted_Access, Index_Type'First);
        -:  723:   end First;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__first.660:
    #####:  716:   function First (Container : Vector) return Cursor is
        -:  717:   begin
    #####:  718:      if Is_Empty (Container) then
    #####:  719:         return No_Element;
        -:  720:      end if;
        -:  721:
    #####:  722:      return (Container'Unrestricted_Access, Index_Type'First);
        -:  723:   end First;
------------------
        -:  724:
    #####:  725:   function First (Object : Iterator) return Cursor is
        -:  726:   begin
        -:  727:      --  The value of the iterator object's Index component influences the
        -:  728:      --  behavior of the First (and Last) selector function.
        -:  729:
        -:  730:      --  When the Index component is No_Index, this means the iterator
        -:  731:      --  object was constructed without a start expression, in which case the
        -:  732:      --  (forward) iteration starts from the (logical) beginning of the entire
        -:  733:      --  sequence of items (corresponding to Container.First, for a forward
        -:  734:      --  iterator).
        -:  735:
        -:  736:      --  Otherwise, this is iteration over a partial sequence of items.
        -:  737:      --  When the Index component isn't No_Index, the iterator object was
        -:  738:      --  constructed with a start expression, that specifies the position
        -:  739:      --  from which the (forward) partial iteration begins.
        -:  740:
    #####:  741:      if Object.Index = No_Index then
    #####:  742:         return First (Object.Container.all);
        -:  743:      else
    #####:  744:         return Cursor'(Object.Container, Object.Index);
        -:  745:      end if;
        -:  746:   end First;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__first__3.6:
    #####:  725:   function First (Object : Iterator) return Cursor is
        -:  726:   begin
        -:  727:      --  The value of the iterator object's Index component influences the
        -:  728:      --  behavior of the First (and Last) selector function.
        -:  729:
        -:  730:      --  When the Index component is No_Index, this means the iterator
        -:  731:      --  object was constructed without a start expression, in which case the
        -:  732:      --  (forward) iteration starts from the (logical) beginning of the entire
        -:  733:      --  sequence of items (corresponding to Container.First, for a forward
        -:  734:      --  iterator).
        -:  735:
        -:  736:      --  Otherwise, this is iteration over a partial sequence of items.
        -:  737:      --  When the Index component isn't No_Index, the iterator object was
        -:  738:      --  constructed with a start expression, that specifies the position
        -:  739:      --  from which the (forward) partial iteration begins.
        -:  740:
    #####:  741:      if Object.Index = No_Index then
    #####:  742:         return First (Object.Container.all);
        -:  743:      else
    #####:  744:         return Cursor'(Object.Container, Object.Index);
        -:  745:      end if;
        -:  746:   end First;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__first__3.51:
    #####:  725:   function First (Object : Iterator) return Cursor is
        -:  726:   begin
        -:  727:      --  The value of the iterator object's Index component influences the
        -:  728:      --  behavior of the First (and Last) selector function.
        -:  729:
        -:  730:      --  When the Index component is No_Index, this means the iterator
        -:  731:      --  object was constructed without a start expression, in which case the
        -:  732:      --  (forward) iteration starts from the (logical) beginning of the entire
        -:  733:      --  sequence of items (corresponding to Container.First, for a forward
        -:  734:      --  iterator).
        -:  735:
        -:  736:      --  Otherwise, this is iteration over a partial sequence of items.
        -:  737:      --  When the Index component isn't No_Index, the iterator object was
        -:  738:      --  constructed with a start expression, that specifies the position
        -:  739:      --  from which the (forward) partial iteration begins.
        -:  740:
    #####:  741:      if Object.Index = No_Index then
    #####:  742:         return First (Object.Container.all);
        -:  743:      else
    #####:  744:         return Cursor'(Object.Container, Object.Index);
        -:  745:      end if;
        -:  746:   end First;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__first__3.365:
    #####:  725:   function First (Object : Iterator) return Cursor is
        -:  726:   begin
        -:  727:      --  The value of the iterator object's Index component influences the
        -:  728:      --  behavior of the First (and Last) selector function.
        -:  729:
        -:  730:      --  When the Index component is No_Index, this means the iterator
        -:  731:      --  object was constructed without a start expression, in which case the
        -:  732:      --  (forward) iteration starts from the (logical) beginning of the entire
        -:  733:      --  sequence of items (corresponding to Container.First, for a forward
        -:  734:      --  iterator).
        -:  735:
        -:  736:      --  Otherwise, this is iteration over a partial sequence of items.
        -:  737:      --  When the Index component isn't No_Index, the iterator object was
        -:  738:      --  constructed with a start expression, that specifies the position
        -:  739:      --  from which the (forward) partial iteration begins.
        -:  740:
    #####:  741:      if Object.Index = No_Index then
    #####:  742:         return First (Object.Container.all);
        -:  743:      else
    #####:  744:         return Cursor'(Object.Container, Object.Index);
        -:  745:      end if;
        -:  746:   end First;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__first__3.410:
    #####:  725:   function First (Object : Iterator) return Cursor is
        -:  726:   begin
        -:  727:      --  The value of the iterator object's Index component influences the
        -:  728:      --  behavior of the First (and Last) selector function.
        -:  729:
        -:  730:      --  When the Index component is No_Index, this means the iterator
        -:  731:      --  object was constructed without a start expression, in which case the
        -:  732:      --  (forward) iteration starts from the (logical) beginning of the entire
        -:  733:      --  sequence of items (corresponding to Container.First, for a forward
        -:  734:      --  iterator).
        -:  735:
        -:  736:      --  Otherwise, this is iteration over a partial sequence of items.
        -:  737:      --  When the Index component isn't No_Index, the iterator object was
        -:  738:      --  constructed with a start expression, that specifies the position
        -:  739:      --  from which the (forward) partial iteration begins.
        -:  740:
    #####:  741:      if Object.Index = No_Index then
    #####:  742:         return First (Object.Container.all);
        -:  743:      else
    #####:  744:         return Cursor'(Object.Container, Object.Index);
        -:  745:      end if;
        -:  746:   end First;
------------------
        -:  747:
        -:  748:   -------------------
        -:  749:   -- First_Element --
        -:  750:   -------------------
        -:  751:
    #####:  752:   function First_Element (Container : Vector) return Element_Type is
        -:  753:   begin
    #####:  754:      if Checks and then Container.Last = No_Index then
    #####:  755:         raise Constraint_Error with "Container is empty";
        -:  756:      else
    #####:  757:         return Container.Elements.EA (Index_Type'First);
        -:  758:      end if;
        -:  759:   end First_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__first_element.171:
    #####:  752:   function First_Element (Container : Vector) return Element_Type is
        -:  753:   begin
    #####:  754:      if Checks and then Container.Last = No_Index then
    #####:  755:         raise Constraint_Error with "Container is empty";
        -:  756:      else
    #####:  757:         return Container.Elements.EA (Index_Type'First);
        -:  758:      end if;
        -:  759:   end First_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__first_element.300:
    #####:  752:   function First_Element (Container : Vector) return Element_Type is
        -:  753:   begin
    #####:  754:      if Checks and then Container.Last = No_Index then
    #####:  755:         raise Constraint_Error with "Container is empty";
        -:  756:      else
    #####:  757:         return Container.Elements.EA (Index_Type'First);
        -:  758:      end if;
        -:  759:   end First_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__first_element.530:
    #####:  752:   function First_Element (Container : Vector) return Element_Type is
        -:  753:   begin
    #####:  754:      if Checks and then Container.Last = No_Index then
    #####:  755:         raise Constraint_Error with "Container is empty";
        -:  756:      else
    #####:  757:         return Container.Elements.EA (Index_Type'First);
        -:  758:      end if;
        -:  759:   end First_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__first_element.659:
    #####:  752:   function First_Element (Container : Vector) return Element_Type is
        -:  753:   begin
    #####:  754:      if Checks and then Container.Last = No_Index then
    #####:  755:         raise Constraint_Error with "Container is empty";
        -:  756:      else
    #####:  757:         return Container.Elements.EA (Index_Type'First);
        -:  758:      end if;
        -:  759:   end First_Element;
------------------
        -:  760:
        -:  761:   -----------------
        -:  762:   -- First_Index --
        -:  763:   -----------------
        -:  764:
    #####:  765:   function First_Index (Container : Vector) return Index_Type is
        -:  766:      pragma Unreferenced (Container);
        -:  767:   begin
    #####:  768:      return Index_Type'First;
        -:  769:   end First_Index;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__first_index.170:
    #####:  765:   function First_Index (Container : Vector) return Index_Type is
        -:  766:      pragma Unreferenced (Container);
        -:  767:   begin
    #####:  768:      return Index_Type'First;
        -:  769:   end First_Index;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__first_index.299:
    #####:  765:   function First_Index (Container : Vector) return Index_Type is
        -:  766:      pragma Unreferenced (Container);
        -:  767:   begin
    #####:  768:      return Index_Type'First;
        -:  769:   end First_Index;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__first_index.529:
    #####:  765:   function First_Index (Container : Vector) return Index_Type is
        -:  766:      pragma Unreferenced (Container);
        -:  767:   begin
    #####:  768:      return Index_Type'First;
        -:  769:   end First_Index;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__first_index.658:
    #####:  765:   function First_Index (Container : Vector) return Index_Type is
        -:  766:      pragma Unreferenced (Container);
        -:  767:   begin
    #####:  768:      return Index_Type'First;
        -:  769:   end First_Index;
------------------
        -:  770:
        -:  771:   -----------------
        -:  772:   -- New_Vector --
        -:  773:   -----------------
        -:  774:
    #####:  775:   function New_Vector (First, Last : Index_Type) return Vector
        -:  776:   is
        -:  777:   begin
    #####:  778:      return (To_Vector (Count_Type (Last - First + 1)));
        -:  779:   end New_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__new_vector.169:
    #####:  775:   function New_Vector (First, Last : Index_Type) return Vector
        -:  776:   is
        -:  777:   begin
    #####:  778:      return (To_Vector (Count_Type (Last - First + 1)));
        -:  779:   end New_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__new_vector.298:
    #####:  775:   function New_Vector (First, Last : Index_Type) return Vector
        -:  776:   is
        -:  777:   begin
    #####:  778:      return (To_Vector (Count_Type (Last - First + 1)));
        -:  779:   end New_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__new_vector.528:
    #####:  775:   function New_Vector (First, Last : Index_Type) return Vector
        -:  776:   is
        -:  777:   begin
    #####:  778:      return (To_Vector (Count_Type (Last - First + 1)));
        -:  779:   end New_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__new_vector.657:
    #####:  775:   function New_Vector (First, Last : Index_Type) return Vector
        -:  776:   is
        -:  777:   begin
    #####:  778:      return (To_Vector (Count_Type (Last - First + 1)));
        -:  779:   end New_Vector;
------------------
        -:  780:
        -:  781:   ---------------------
        -:  782:   -- Generic_Sorting --
        -:  783:   ---------------------
        -:  784:
        -:  785:   package body Generic_Sorting is
        -:  786:
        -:  787:      ---------------
        -:  788:      -- Is_Sorted --
        -:  789:      ---------------
        -:  790:
        -:  791:      function Is_Sorted (Container : Vector) return Boolean is
        -:  792:      begin
        -:  793:         if Container.Last <= Index_Type'First then
        -:  794:            return True;
        -:  795:         end if;
        -:  796:
        -:  797:         --  Per AI05-0022, the container implementation is required to detect
        -:  798:         --  element tampering by a generic actual subprogram.
        -:  799:
        -:  800:         declare
        -:  801:            Lock : With_Lock (Container.TC'Unrestricted_Access);
        -:  802:            EA   : Elements_Array renames Container.Elements.EA;
        -:  803:         begin
        -:  804:            for J in Index_Type'First .. Container.Last - 1 loop
        -:  805:               if EA (J + 1) < EA (J) then
        -:  806:                  return False;
        -:  807:               end if;
        -:  808:            end loop;
        -:  809:
        -:  810:            return True;
        -:  811:         end;
        -:  812:      end Is_Sorted;
        -:  813:
        -:  814:      -----------
        -:  815:      -- Merge --
        -:  816:      -----------
        -:  817:
        -:  818:      procedure Merge (Target, Source : in out Vector) is
        -:  819:         I : Index_Type'Base := Target.Last;
        -:  820:         J : Index_Type'Base;
        -:  821:
        -:  822:      begin
        -:  823:         TC_Check (Source.TC);
        -:  824:
        -:  825:         --  The semantics of Merge changed slightly per AI05-0021. It was
        -:  826:         --  originally the case that if Target and Source denoted the same
        -:  827:         --  container object, then the GNAT implementation of Merge did
        -:  828:         --  nothing. However, it was argued that RM05 did not precisely
        -:  829:         --  specify the semantics for this corner case. The decision of the
        -:  830:         --  ARG was that if Target and Source denote the same non-empty
        -:  831:         --  container object, then Program_Error is raised.
        -:  832:
        -:  833:         if Source.Last < Index_Type'First then  -- Source is empty
        -:  834:            return;
        -:  835:         end if;
        -:  836:
        -:  837:         if Checks and then Target'Address = Source'Address then
        -:  838:            raise Program_Error with
        -:  839:              "Target and Source denote same non-empty container";
        -:  840:         end if;
        -:  841:
        -:  842:         if Target.Last < Index_Type'First then  -- Target is empty
        -:  843:            Move (Target => Target, Source => Source);
        -:  844:            return;
        -:  845:         end if;
        -:  846:
        -:  847:         Target.Set_Length (Length (Target) + Length (Source));
        -:  848:
        -:  849:         --  Per AI05-0022, the container implementation is required to detect
        -:  850:         --  element tampering by a generic actual subprogram.
        -:  851:
        -:  852:         declare
        -:  853:            TA : Elements_Array renames Target.Elements.EA;
        -:  854:            SA : Elements_Array renames Source.Elements.EA;
        -:  855:
        -:  856:            Lock_Target : With_Lock (Target.TC'Unchecked_Access);
        -:  857:            Lock_Source : With_Lock (Source.TC'Unchecked_Access);
        -:  858:         begin
        -:  859:            J := Target.Last;
        -:  860:            while Source.Last >= Index_Type'First loop
        -:  861:               pragma Assert (Source.Last <= Index_Type'First
        -:  862:                               or else not (SA (Source.Last) <
        -:  863:                                            SA (Source.Last - 1)));
        -:  864:
        -:  865:               if I < Index_Type'First then
        -:  866:                  TA (Index_Type'First .. J) :=
        -:  867:                    SA (Index_Type'First .. Source.Last);
        -:  868:
        -:  869:                  Source.Last := No_Index;
        -:  870:                  exit;
        -:  871:               end if;
        -:  872:
        -:  873:               pragma Assert (I <= Index_Type'First
        -:  874:                                or else not (TA (I) < TA (I - 1)));
        -:  875:
        -:  876:               if SA (Source.Last) < TA (I) then
        -:  877:                  TA (J) := TA (I);
        -:  878:                  I := I - 1;
        -:  879:
        -:  880:               else
        -:  881:                  TA (J) := SA (Source.Last);
        -:  882:                  Source.Last := Source.Last - 1;
        -:  883:               end if;
        -:  884:
        -:  885:               J := J - 1;
        -:  886:            end loop;
        -:  887:         end;
        -:  888:      end Merge;
        -:  889:
        -:  890:      ----------
        -:  891:      -- Sort --
        -:  892:      ----------
        -:  893:
        -:  894:      procedure Sort (Container : in out Vector) is
        -:  895:         procedure Sort is
        -:  896:            new Generic_Array_Sort
        -:  897:             (Index_Type   => Index_Type,
        -:  898:              Element_Type => Element_Type,
        -:  899:              Array_Type   => Elements_Array,
        -:  900:              "<"          => "<");
        -:  901:
        -:  902:      begin
        -:  903:         --  The exception behavior for the vector container must match that
        -:  904:         --  for the list container, so we check for cursor tampering here
        -:  905:         --  (which will catch more things) instead of for element tampering
        -:  906:         --  (which will catch fewer things). It's true that the elements of
        -:  907:         --  this vector container could be safely moved around while (say) an
        -:  908:         --  iteration is taking place (iteration only increments the busy
        -:  909:         --  counter), and so technically all we would need here is a test for
        -:  910:         --  element tampering (indicated by the lock counter), that's simply
        -:  911:         --  an artifact of our array-based implementation. Logically Sort
        -:  912:         --  requires a check for cursor tampering.
        -:  913:
        -:  914:         TC_Check (Container.TC);
        -:  915:
        -:  916:         if Container.Last <= Index_Type'First then
        -:  917:            return;
        -:  918:         end if;
        -:  919:
        -:  920:         --  Per AI05-0022, the container implementation is required to detect
        -:  921:         --  element tampering by a generic actual subprogram.
        -:  922:
        -:  923:         declare
        -:  924:            Lock : With_Lock (Container.TC'Unchecked_Access);
        -:  925:         begin
        -:  926:            Sort (Container.Elements.EA (Index_Type'First .. Container.Last));
        -:  927:         end;
        -:  928:      end Sort;
        -:  929:
        -:  930:   end Generic_Sorting;
        -:  931:
        -:  932:   ------------------------
        -:  933:   -- Get_Element_Access --
        -:  934:   ------------------------
        -:  935:
    #####:  936:   function Get_Element_Access
        -:  937:     (Position : Cursor) return not null Element_Access is
        -:  938:   begin
    #####:  939:      return Position.Container.Elements.EA (Position.Index)'Access;
        -:  940:   end Get_Element_Access;
        -:  941:
        -:  942:   -----------------
        -:  943:   -- Has_Element --
        -:  944:   -----------------
        -:  945:
    #####:  946:   function Has_Element (Position : Cursor) return Boolean is
        -:  947:   begin
    #####:  948:      return Position /= No_Element;
        -:  949:   end Has_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__has_element.128:
    #####:  946:   function Has_Element (Position : Cursor) return Boolean is
        -:  947:   begin
    #####:  948:      return Position /= No_Element;
        -:  949:   end Has_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__has_element.256:
    #####:  946:   function Has_Element (Position : Cursor) return Boolean is
        -:  947:   begin
    #####:  948:      return Position /= No_Element;
        -:  949:   end Has_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__has_element.487:
    #####:  946:   function Has_Element (Position : Cursor) return Boolean is
        -:  947:   begin
    #####:  948:      return Position /= No_Element;
        -:  949:   end Has_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__has_element.615:
    #####:  946:   function Has_Element (Position : Cursor) return Boolean is
        -:  947:   begin
    #####:  948:      return Position /= No_Element;
        -:  949:   end Has_Element;
------------------
        -:  950:
        -:  951:   ------------
        -:  952:   -- Insert --
        -:  953:   ------------
        -:  954:
    #####:  955:   procedure Insert
        -:  956:     (Container : in out Vector;
        -:  957:      Before    : Extended_Index;
        -:  958:      New_Item  : Element_Type;
        -:  959:      Count     : Count_Type := 1)
        -:  960:   is
    #####:  961:      Old_Length : constant Count_Type := Container.Length;
        -:  962:
        -:  963:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -:  964:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -:  965:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -:  966:
        -:  967:      Index : Index_Type'Base;  -- scratch for intermediate values
        -:  968:      J     : Count_Type'Base;  -- scratch
        -:  969:
        -:  970:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -:  971:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####:  972:      Dst          : Elements_Access;  -- new, expanded internal array
        -:  973:
        -:  974:   begin
        -:  975:      --  The tampering bits exist to prevent an item from being harmfully
        -:  976:      --  manipulated while it is being visited. Query, Update, and Iterate
        -:  977:      --  increment the busy count on entry, and decrement the count on
        -:  978:      --  exit. Insert checks the count to determine whether it is being called
        -:  979:      --  while the associated callback procedure is executing.
        -:  980:
    #####:  981:      TC_Check (Container.TC);
        -:  982:
        -:  983:      if Checks then
        -:  984:         --  As a precondition on the generic actual Index_Type, the base type
        -:  985:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  986:         --  that Container.Last assumes when the vector is empty. However, we
        -:  987:         --  do not allow that as the value for Index when specifying where the
        -:  988:         --  new items should be inserted, so we must manually check. (That the
        -:  989:         --  user is allowed to specify the value at all here is a consequence
        -:  990:         --  of the declaration of the Extended_Index subtype, which includes
        -:  991:         --  the values in the base range that immediately precede and
        -:  992:         --  immediately follow the values in the Index_Type.)
        -:  993:
    #####:  994:         if Before < Index_Type'First then
    #####:  995:            raise Constraint_Error with
        -:  996:              "Before index is out of range (too small)";
        -:  997:         end if;
        -:  998:
        -:  999:         --  We do allow a value greater than Container.Last to be specified as
        -: 1000:         --  the Index, but only if it's immediately greater. This allows for
        -: 1001:         --  the case of appending items to the back end of the vector. (It is
        -: 1002:         --  assumed that specifying an index value greater than Last + 1
        -: 1003:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1004:         --  is treated as a proper error.)
        -: 1005:
    #####: 1006:         if Before > Container.Last + 1 then
    #####: 1007:            raise Constraint_Error with
        -: 1008:              "Before index is out of range (too large)";
        -: 1009:         end if;
        -: 1010:      end if;
        -: 1011:
        -: 1012:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1013:      --  the container is busy, so we simply return.
        -: 1014:
    #####: 1015:      if Count = 0 then
    #####: 1016:         return;
        -: 1017:      end if;
        -: 1018:
        -: 1019:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1020:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1021:      --  we must check the sum of the current length and the insertion count.
        -: 1022:      --  Note: we cannot simply add these values, because of the possibility
        -: 1023:      --  of overflow.
        -: 1024:
    #####: 1025:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1026:         raise Constraint_Error with "Count is out of range";
        -: 1027:      end if;
        -: 1028:
        -: 1029:      --  It is now safe compute the length of the new vector, without fear of
        -: 1030:      --  overflow.
        -: 1031:
    #####: 1032:      New_Length := Old_Length + Count;
        -: 1033:
        -: 1034:      --  The second constraint is that the new Last index value cannot exceed
        -: 1035:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1036:      --  length (computed from the range of values in Index_Type), and then
        -: 1037:      --  compare the new length to the maximum length. If the new length is
        -: 1038:      --  acceptable, then we compute the new last index from that.
        -: 1039:
        -: 1040:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1041:
        -: 1042:         --  We have to handle the case when there might be more values in the
        -: 1043:         --  range of Index_Type than in the range of Count_Type.
        -: 1044:
        -: 1045:         if Index_Type'First <= 0 then
        -: 1046:
        -: 1047:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1048:            --  less than 0, so it is safe to compute the following sum without
        -: 1049:            --  fear of overflow. We need to suppress warnings, because
        -: 1050:            --  otherwise we get an error in -gnatwE mode.
        -: 1051:
        -: 1052:            pragma Warnings (Off);
    #####: 1053:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1054:            pragma Warnings (On);
        -: 1055:
        -: 1056:            if Index <= Index_Type'Last then
        -: 1057:
        -: 1058:               --  We have determined that range of Index_Type has at least as
        -: 1059:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1060:               --  maximum number of items that are allowed.
        -: 1061:
    #####: 1062:               Max_Length := Count_Type'Last;
        -: 1063:
        -: 1064:            else
        -: 1065:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1066:               --  so the maximum number of items is computed from the range of
        -: 1067:               --  the Index_Type.
        -: 1068:
        -: 1069:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1070:            end if;
        -: 1071:
        -: 1072:         else
        -: 1073:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1074:            --  the difference without fear of overflow (which we would have to
        -: 1075:            --  worry about if No_Index were less than 0, but that case is
        -: 1076:            --  handled above).
        -: 1077:
        -: 1078:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1079:               --  We have determined that range of Index_Type has at least as
        -: 1080:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1081:               --  maximum number of items that are allowed.
        -: 1082:
        -: 1083:               Max_Length := Count_Type'Last;
        -: 1084:
        -: 1085:            else
        -: 1086:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1087:               --  so the maximum number of items is computed from the range of
        -: 1088:               --  the Index_Type.
        -: 1089:
        -: 1090:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1091:            end if;
        -: 1092:         end if;
        -: 1093:
        -: 1094:      elsif Index_Type'First <= 0 then
        -: 1095:
        -: 1096:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1097:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1098:         --  overflow.
        -: 1099:
        -: 1100:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1101:
        -: 1102:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1103:
        -: 1104:            --  We have determined that range of Index_Type has at least as
        -: 1105:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1106:            --  number of items that are allowed.
        -: 1107:
        -: 1108:            Max_Length := Count_Type'Last;
        -: 1109:
        -: 1110:         else
        -: 1111:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1112:            --  so the maximum number of items is computed from the range of
        -: 1113:            --  the Index_Type.
        -: 1114:
        -: 1115:            Max_Length :=
        -: 1116:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1117:         end if;
        -: 1118:
        -: 1119:      else
        -: 1120:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1121:         --  difference without fear of overflow (which we would have to worry
        -: 1122:         --  about if No_Index were less than 0, but that case is handled
        -: 1123:         --  above).
        -: 1124:
        -: 1125:         Max_Length :=
        -: 1126:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1127:      end if;
        -: 1128:
        -: 1129:      --  We have just computed the maximum length (number of items). We must
        -: 1130:      --  now compare the requested length to the maximum length, as we do not
        -: 1131:      --  allow a vector expand beyond the maximum (because that would create
        -: 1132:      --  an internal array with a last index value greater than
        -: 1133:      --  Index_Type'Last, with no way to index those elements).
        -: 1134:
    #####: 1135:      if Checks and then New_Length > Max_Length then
    #####: 1136:         raise Constraint_Error with "Count is out of range";
        -: 1137:      end if;
        -: 1138:
        -: 1139:      --  New_Last is the last index value of the items in the container after
        -: 1140:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1141:      --  compute its value from the New_Length.
        -: 1142:
        -: 1143:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1144:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1145:      else
        -: 1146:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1147:      end if;
        -: 1148:
    #####: 1149:      if Container.Elements = null then
    #####: 1150:         pragma Assert (Container.Last = No_Index);
        -: 1151:
        -: 1152:         --  This is the simplest case, with which we must always begin: we're
        -: 1153:         --  inserting items into an empty vector that hasn't allocated an
        -: 1154:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1155:         --  here, because an empty container cannot be busy.
        -: 1156:
        -: 1157:         --  In order to preserve container invariants, we allocate the new
        -: 1158:         --  internal array first, before setting the Last index value, in case
        -: 1159:         --  the allocation fails (which can happen either because there is no
        -: 1160:         --  storage available, or because element initialization fails).
        -: 1161:
    #####: 1162:         Container.Elements := new Elements_Type'
    #####: 1163:                                     (Last => New_Last,
    #####: 1164:                                      EA   => (others => New_Item));
        -: 1165:
        -: 1166:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1167:         --  safe to update the Last index, restoring container invariants.
        -: 1168:
    #####: 1169:         Container.Last := New_Last;
        -: 1170:
    #####: 1171:         return;
        -: 1172:      end if;
        -: 1173:
        -: 1174:      --  An internal array has already been allocated, so we must determine
        -: 1175:      --  whether there is enough unused storage for the new items.
        -: 1176:
    #####: 1177:      if New_Length <= Container.Elements.EA'Length then
        -: 1178:
        -: 1179:         --  In this case, we're inserting elements into a vector that has
        -: 1180:         --  already allocated an internal array, and the existing array has
        -: 1181:         --  enough unused storage for the new items.
        -: 1182:
    #####: 1183:         declare
    #####: 1184:            EA : Elements_Array renames Container.Elements.EA;
        -: 1185:
        -: 1186:         begin
    #####: 1187:            if Before > Container.Last then
        -: 1188:
        -: 1189:               --  The new items are being appended to the vector, so no
        -: 1190:               --  sliding of existing elements is required.
        -: 1191:
    #####: 1192:               EA (Before .. New_Last) := (others => New_Item);
        -: 1193:
        -: 1194:            else
        -: 1195:               --  The new items are being inserted before some existing
        -: 1196:               --  elements, so we must slide the existing elements up to their
        -: 1197:               --  new home. We use the wider of Index_Type'Base and
        -: 1198:               --  Count_Type'Base as the type for intermediate index values.
        -: 1199:
        -: 1200:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1201:                  Index := Before + Index_Type'Base (Count);
        -: 1202:               else
        -: 1203:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1204:               end if;
        -: 1205:
    #####: 1206:               EA (Index .. New_Last) := EA (Before .. Container.Last);
    #####: 1207:               EA (Before .. Index - 1) := (others => New_Item);
        -: 1208:            end if;
    #####: 1209:         end;
        -: 1210:
    #####: 1211:         Container.Last := New_Last;
    #####: 1212:         return;
        -: 1213:      end if;
        -: 1214:
        -: 1215:      --  In this case, we're inserting elements into a vector that has already
        -: 1216:      --  allocated an internal array, but the existing array does not have
        -: 1217:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1218:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1219:      --  allocate an array whose length is some power-of-two factor of the
        -: 1220:      --  current array length. (The new array cannot have a length less than
        -: 1221:      --  the New_Length of the container, but its last index value cannot be
        -: 1222:      --  greater than Index_Type'Last.)
        -: 1223:
    #####: 1224:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1225:      while New_Capacity < New_Length loop
    #####: 1226:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1227:            New_Capacity := Count_Type'Last;
    #####: 1228:            exit;
        -: 1229:         else
    #####: 1230:            New_Capacity := 2 * New_Capacity;
        -: 1231:         end if;
    #####: 1232:      end loop;
        -: 1233:
    #####: 1234:      if New_Capacity > Max_Length then
        -: 1235:
        -: 1236:         --  We have reached the limit of capacity, so no further expansion
        -: 1237:         --  will occur. (This is not a problem, as there is never a need to
        -: 1238:         --  have more capacity than the maximum container length.)
        -: 1239:
    #####: 1240:         New_Capacity := Max_Length;
        -: 1241:      end if;
        -: 1242:
        -: 1243:      --  We have computed the length of the new internal array (and this is
        -: 1244:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1245:
        -: 1246:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1247:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1248:      else
        -: 1249:         Dst_Last :=
        -: 1250:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1251:      end if;
        -: 1252:
        -: 1253:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1254:      --  fails, we have not changed any container state, so no side-effect
        -: 1255:      --  will occur as a result of propagating the exception.
        -: 1256:
    #####: 1257:      Dst := new Elements_Type (Dst_Last);
        -: 1258:
        -: 1259:      --  We have our new internal array. All that needs to be done now is to
        -: 1260:      --  copy the existing items (if any) from the old array (the "source"
        -: 1261:      --  array, object SA below) to the new array (the "destination" array,
        -: 1262:      --  object DA below), and then deallocate the old array.
        -: 1263:
        -: 1264:      declare
    #####: 1265:         SA : Elements_Array renames Container.Elements.EA; -- source
    #####: 1266:         DA : Elements_Array renames Dst.EA;                -- destination
        -: 1267:
        -: 1268:      begin
    #####: 1269:         DA (Index_Type'First .. Before - 1) :=
    #####: 1270:           SA (Index_Type'First .. Before - 1);
        -: 1271:
    #####: 1272:         if Before > Container.Last then
    #####: 1273:            DA (Before .. New_Last) := (others => New_Item);
        -: 1274:
        -: 1275:         else
        -: 1276:            --  The new items are being inserted before some existing elements,
        -: 1277:            --  so we must slide the existing elements up to their new home.
        -: 1278:
        -: 1279:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1280:               Index := Before + Index_Type'Base (Count);
        -: 1281:            else
        -: 1282:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1283:            end if;
        -: 1284:
    #####: 1285:            DA (Before .. Index - 1) := (others => New_Item);
    #####: 1286:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1287:         end if;
        -: 1288:
        -: 1289:      exception
    #####: 1290:         when others =>
    #####: 1291:            Free (Dst);
    #####: 1292:            raise;
        -: 1293:      end;
        -: 1294:
        -: 1295:      --  We have successfully copied the items onto the new array, so the
        -: 1296:      --  final thing to do is deallocate the old array.
        -: 1297:
        -: 1298:      declare
    #####: 1299:         X : Elements_Access := Container.Elements;
        -: 1300:
        -: 1301:      begin
        -: 1302:         --  We first isolate the old internal array, removing it from the
        -: 1303:         --  container and replacing it with the new internal array, before we
        -: 1304:         --  deallocate the old array (which can fail if finalization of
        -: 1305:         --  elements propagates an exception).
        -: 1306:
    #####: 1307:         Container.Elements := Dst;
    #####: 1308:         Container.Last := New_Last;
        -: 1309:
        -: 1310:         --  The container invariants have been restored, so it is now safe to
        -: 1311:         --  attempt to deallocate the old array.
        -: 1312:
    #####: 1313:         Free (X);
        -: 1314:      end;
        -: 1315:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert__4.168:
    #####:  955:   procedure Insert
        -:  956:     (Container : in out Vector;
        -:  957:      Before    : Extended_Index;
        -:  958:      New_Item  : Element_Type;
        -:  959:      Count     : Count_Type := 1)
        -:  960:   is
    #####:  961:      Old_Length : constant Count_Type := Container.Length;
        -:  962:
        -:  963:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -:  964:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -:  965:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -:  966:
        -:  967:      Index : Index_Type'Base;  -- scratch for intermediate values
        -:  968:      J     : Count_Type'Base;  -- scratch
        -:  969:
        -:  970:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -:  971:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####:  972:      Dst          : Elements_Access;  -- new, expanded internal array
        -:  973:
        -:  974:   begin
        -:  975:      --  The tampering bits exist to prevent an item from being harmfully
        -:  976:      --  manipulated while it is being visited. Query, Update, and Iterate
        -:  977:      --  increment the busy count on entry, and decrement the count on
        -:  978:      --  exit. Insert checks the count to determine whether it is being called
        -:  979:      --  while the associated callback procedure is executing.
        -:  980:
    #####:  981:      TC_Check (Container.TC);
        -:  982:
        -:  983:      if Checks then
        -:  984:         --  As a precondition on the generic actual Index_Type, the base type
        -:  985:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  986:         --  that Container.Last assumes when the vector is empty. However, we
        -:  987:         --  do not allow that as the value for Index when specifying where the
        -:  988:         --  new items should be inserted, so we must manually check. (That the
        -:  989:         --  user is allowed to specify the value at all here is a consequence
        -:  990:         --  of the declaration of the Extended_Index subtype, which includes
        -:  991:         --  the values in the base range that immediately precede and
        -:  992:         --  immediately follow the values in the Index_Type.)
        -:  993:
    #####:  994:         if Before < Index_Type'First then
    #####:  995:            raise Constraint_Error with
        -:  996:              "Before index is out of range (too small)";
        -:  997:         end if;
        -:  998:
        -:  999:         --  We do allow a value greater than Container.Last to be specified as
        -: 1000:         --  the Index, but only if it's immediately greater. This allows for
        -: 1001:         --  the case of appending items to the back end of the vector. (It is
        -: 1002:         --  assumed that specifying an index value greater than Last + 1
        -: 1003:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1004:         --  is treated as a proper error.)
        -: 1005:
    #####: 1006:         if Before > Container.Last + 1 then
    #####: 1007:            raise Constraint_Error with
        -: 1008:              "Before index is out of range (too large)";
        -: 1009:         end if;
        -: 1010:      end if;
        -: 1011:
        -: 1012:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1013:      --  the container is busy, so we simply return.
        -: 1014:
    #####: 1015:      if Count = 0 then
    #####: 1016:         return;
        -: 1017:      end if;
        -: 1018:
        -: 1019:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1020:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1021:      --  we must check the sum of the current length and the insertion count.
        -: 1022:      --  Note: we cannot simply add these values, because of the possibility
        -: 1023:      --  of overflow.
        -: 1024:
    #####: 1025:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1026:         raise Constraint_Error with "Count is out of range";
        -: 1027:      end if;
        -: 1028:
        -: 1029:      --  It is now safe compute the length of the new vector, without fear of
        -: 1030:      --  overflow.
        -: 1031:
    #####: 1032:      New_Length := Old_Length + Count;
        -: 1033:
        -: 1034:      --  The second constraint is that the new Last index value cannot exceed
        -: 1035:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1036:      --  length (computed from the range of values in Index_Type), and then
        -: 1037:      --  compare the new length to the maximum length. If the new length is
        -: 1038:      --  acceptable, then we compute the new last index from that.
        -: 1039:
        -: 1040:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1041:
        -: 1042:         --  We have to handle the case when there might be more values in the
        -: 1043:         --  range of Index_Type than in the range of Count_Type.
        -: 1044:
        -: 1045:         if Index_Type'First <= 0 then
        -: 1046:
        -: 1047:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1048:            --  less than 0, so it is safe to compute the following sum without
        -: 1049:            --  fear of overflow. We need to suppress warnings, because
        -: 1050:            --  otherwise we get an error in -gnatwE mode.
        -: 1051:
        -: 1052:            pragma Warnings (Off);
    #####: 1053:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1054:            pragma Warnings (On);
        -: 1055:
        -: 1056:            if Index <= Index_Type'Last then
        -: 1057:
        -: 1058:               --  We have determined that range of Index_Type has at least as
        -: 1059:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1060:               --  maximum number of items that are allowed.
        -: 1061:
    #####: 1062:               Max_Length := Count_Type'Last;
        -: 1063:
        -: 1064:            else
        -: 1065:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1066:               --  so the maximum number of items is computed from the range of
        -: 1067:               --  the Index_Type.
        -: 1068:
        -: 1069:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1070:            end if;
        -: 1071:
        -: 1072:         else
        -: 1073:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1074:            --  the difference without fear of overflow (which we would have to
        -: 1075:            --  worry about if No_Index were less than 0, but that case is
        -: 1076:            --  handled above).
        -: 1077:
        -: 1078:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1079:               --  We have determined that range of Index_Type has at least as
        -: 1080:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1081:               --  maximum number of items that are allowed.
        -: 1082:
        -: 1083:               Max_Length := Count_Type'Last;
        -: 1084:
        -: 1085:            else
        -: 1086:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1087:               --  so the maximum number of items is computed from the range of
        -: 1088:               --  the Index_Type.
        -: 1089:
        -: 1090:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1091:            end if;
        -: 1092:         end if;
        -: 1093:
        -: 1094:      elsif Index_Type'First <= 0 then
        -: 1095:
        -: 1096:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1097:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1098:         --  overflow.
        -: 1099:
        -: 1100:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1101:
        -: 1102:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1103:
        -: 1104:            --  We have determined that range of Index_Type has at least as
        -: 1105:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1106:            --  number of items that are allowed.
        -: 1107:
        -: 1108:            Max_Length := Count_Type'Last;
        -: 1109:
        -: 1110:         else
        -: 1111:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1112:            --  so the maximum number of items is computed from the range of
        -: 1113:            --  the Index_Type.
        -: 1114:
        -: 1115:            Max_Length :=
        -: 1116:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1117:         end if;
        -: 1118:
        -: 1119:      else
        -: 1120:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1121:         --  difference without fear of overflow (which we would have to worry
        -: 1122:         --  about if No_Index were less than 0, but that case is handled
        -: 1123:         --  above).
        -: 1124:
        -: 1125:         Max_Length :=
        -: 1126:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1127:      end if;
        -: 1128:
        -: 1129:      --  We have just computed the maximum length (number of items). We must
        -: 1130:      --  now compare the requested length to the maximum length, as we do not
        -: 1131:      --  allow a vector expand beyond the maximum (because that would create
        -: 1132:      --  an internal array with a last index value greater than
        -: 1133:      --  Index_Type'Last, with no way to index those elements).
        -: 1134:
    #####: 1135:      if Checks and then New_Length > Max_Length then
    #####: 1136:         raise Constraint_Error with "Count is out of range";
        -: 1137:      end if;
        -: 1138:
        -: 1139:      --  New_Last is the last index value of the items in the container after
        -: 1140:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1141:      --  compute its value from the New_Length.
        -: 1142:
        -: 1143:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1144:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1145:      else
        -: 1146:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1147:      end if;
        -: 1148:
    #####: 1149:      if Container.Elements = null then
    #####: 1150:         pragma Assert (Container.Last = No_Index);
        -: 1151:
        -: 1152:         --  This is the simplest case, with which we must always begin: we're
        -: 1153:         --  inserting items into an empty vector that hasn't allocated an
        -: 1154:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1155:         --  here, because an empty container cannot be busy.
        -: 1156:
        -: 1157:         --  In order to preserve container invariants, we allocate the new
        -: 1158:         --  internal array first, before setting the Last index value, in case
        -: 1159:         --  the allocation fails (which can happen either because there is no
        -: 1160:         --  storage available, or because element initialization fails).
        -: 1161:
    #####: 1162:         Container.Elements := new Elements_Type'
    #####: 1163:                                     (Last => New_Last,
    #####: 1164:                                      EA   => (others => New_Item));
        -: 1165:
        -: 1166:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1167:         --  safe to update the Last index, restoring container invariants.
        -: 1168:
    #####: 1169:         Container.Last := New_Last;
        -: 1170:
    #####: 1171:         return;
        -: 1172:      end if;
        -: 1173:
        -: 1174:      --  An internal array has already been allocated, so we must determine
        -: 1175:      --  whether there is enough unused storage for the new items.
        -: 1176:
    #####: 1177:      if New_Length <= Container.Elements.EA'Length then
        -: 1178:
        -: 1179:         --  In this case, we're inserting elements into a vector that has
        -: 1180:         --  already allocated an internal array, and the existing array has
        -: 1181:         --  enough unused storage for the new items.
        -: 1182:
        -: 1183:         declare
    #####: 1184:            EA : Elements_Array renames Container.Elements.EA;
        -: 1185:
        -: 1186:         begin
    #####: 1187:            if Before > Container.Last then
        -: 1188:
        -: 1189:               --  The new items are being appended to the vector, so no
        -: 1190:               --  sliding of existing elements is required.
        -: 1191:
    #####: 1192:               EA (Before .. New_Last) := (others => New_Item);
        -: 1193:
        -: 1194:            else
        -: 1195:               --  The new items are being inserted before some existing
        -: 1196:               --  elements, so we must slide the existing elements up to their
        -: 1197:               --  new home. We use the wider of Index_Type'Base and
        -: 1198:               --  Count_Type'Base as the type for intermediate index values.
        -: 1199:
        -: 1200:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1201:                  Index := Before + Index_Type'Base (Count);
        -: 1202:               else
        -: 1203:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1204:               end if;
        -: 1205:
    #####: 1206:               EA (Index .. New_Last) := EA (Before .. Container.Last);
    #####: 1207:               EA (Before .. Index - 1) := (others => New_Item);
        -: 1208:            end if;
        -: 1209:         end;
        -: 1210:
    #####: 1211:         Container.Last := New_Last;
    #####: 1212:         return;
        -: 1213:      end if;
        -: 1214:
        -: 1215:      --  In this case, we're inserting elements into a vector that has already
        -: 1216:      --  allocated an internal array, but the existing array does not have
        -: 1217:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1218:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1219:      --  allocate an array whose length is some power-of-two factor of the
        -: 1220:      --  current array length. (The new array cannot have a length less than
        -: 1221:      --  the New_Length of the container, but its last index value cannot be
        -: 1222:      --  greater than Index_Type'Last.)
        -: 1223:
    #####: 1224:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1225:      while New_Capacity < New_Length loop
    #####: 1226:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1227:            New_Capacity := Count_Type'Last;
    #####: 1228:            exit;
        -: 1229:         else
    #####: 1230:            New_Capacity := 2 * New_Capacity;
        -: 1231:         end if;
    #####: 1232:      end loop;
        -: 1233:
    #####: 1234:      if New_Capacity > Max_Length then
        -: 1235:
        -: 1236:         --  We have reached the limit of capacity, so no further expansion
        -: 1237:         --  will occur. (This is not a problem, as there is never a need to
        -: 1238:         --  have more capacity than the maximum container length.)
        -: 1239:
    #####: 1240:         New_Capacity := Max_Length;
        -: 1241:      end if;
        -: 1242:
        -: 1243:      --  We have computed the length of the new internal array (and this is
        -: 1244:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1245:
        -: 1246:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1247:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1248:      else
        -: 1249:         Dst_Last :=
        -: 1250:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1251:      end if;
        -: 1252:
        -: 1253:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1254:      --  fails, we have not changed any container state, so no side-effect
        -: 1255:      --  will occur as a result of propagating the exception.
        -: 1256:
    #####: 1257:      Dst := new Elements_Type (Dst_Last);
        -: 1258:
        -: 1259:      --  We have our new internal array. All that needs to be done now is to
        -: 1260:      --  copy the existing items (if any) from the old array (the "source"
        -: 1261:      --  array, object SA below) to the new array (the "destination" array,
        -: 1262:      --  object DA below), and then deallocate the old array.
        -: 1263:
        -: 1264:      declare
    #####: 1265:         SA : Elements_Array renames Container.Elements.EA; -- source
    #####: 1266:         DA : Elements_Array renames Dst.EA;                -- destination
        -: 1267:
        -: 1268:      begin
    #####: 1269:         DA (Index_Type'First .. Before - 1) :=
    #####: 1270:           SA (Index_Type'First .. Before - 1);
        -: 1271:
    #####: 1272:         if Before > Container.Last then
    #####: 1273:            DA (Before .. New_Last) := (others => New_Item);
        -: 1274:
        -: 1275:         else
        -: 1276:            --  The new items are being inserted before some existing elements,
        -: 1277:            --  so we must slide the existing elements up to their new home.
        -: 1278:
        -: 1279:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1280:               Index := Before + Index_Type'Base (Count);
        -: 1281:            else
        -: 1282:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1283:            end if;
        -: 1284:
    #####: 1285:            DA (Before .. Index - 1) := (others => New_Item);
    #####: 1286:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1287:         end if;
        -: 1288:
        -: 1289:      exception
    #####: 1290:         when others =>
    #####: 1291:            Free (Dst);
    #####: 1292:            raise;
        -: 1293:      end;
        -: 1294:
        -: 1295:      --  We have successfully copied the items onto the new array, so the
        -: 1296:      --  final thing to do is deallocate the old array.
        -: 1297:
        -: 1298:      declare
    #####: 1299:         X : Elements_Access := Container.Elements;
        -: 1300:
        -: 1301:      begin
        -: 1302:         --  We first isolate the old internal array, removing it from the
        -: 1303:         --  container and replacing it with the new internal array, before we
        -: 1304:         --  deallocate the old array (which can fail if finalization of
        -: 1305:         --  elements propagates an exception).
        -: 1306:
    #####: 1307:         Container.Elements := Dst;
    #####: 1308:         Container.Last := New_Last;
        -: 1309:
        -: 1310:         --  The container invariants have been restored, so it is now safe to
        -: 1311:         --  attempt to deallocate the old array.
        -: 1312:
    #####: 1313:         Free (X);
        -: 1314:      end;
        -: 1315:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert__4.297:
    #####:  955:   procedure Insert
        -:  956:     (Container : in out Vector;
        -:  957:      Before    : Extended_Index;
        -:  958:      New_Item  : Element_Type;
        -:  959:      Count     : Count_Type := 1)
        -:  960:   is
    #####:  961:      Old_Length : constant Count_Type := Container.Length;
        -:  962:
        -:  963:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -:  964:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -:  965:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -:  966:
        -:  967:      Index : Index_Type'Base;  -- scratch for intermediate values
        -:  968:      J     : Count_Type'Base;  -- scratch
        -:  969:
        -:  970:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -:  971:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####:  972:      Dst          : Elements_Access;  -- new, expanded internal array
        -:  973:
        -:  974:   begin
        -:  975:      --  The tampering bits exist to prevent an item from being harmfully
        -:  976:      --  manipulated while it is being visited. Query, Update, and Iterate
        -:  977:      --  increment the busy count on entry, and decrement the count on
        -:  978:      --  exit. Insert checks the count to determine whether it is being called
        -:  979:      --  while the associated callback procedure is executing.
        -:  980:
    #####:  981:      TC_Check (Container.TC);
        -:  982:
        -:  983:      if Checks then
        -:  984:         --  As a precondition on the generic actual Index_Type, the base type
        -:  985:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  986:         --  that Container.Last assumes when the vector is empty. However, we
        -:  987:         --  do not allow that as the value for Index when specifying where the
        -:  988:         --  new items should be inserted, so we must manually check. (That the
        -:  989:         --  user is allowed to specify the value at all here is a consequence
        -:  990:         --  of the declaration of the Extended_Index subtype, which includes
        -:  991:         --  the values in the base range that immediately precede and
        -:  992:         --  immediately follow the values in the Index_Type.)
        -:  993:
    #####:  994:         if Before < Index_Type'First then
    #####:  995:            raise Constraint_Error with
        -:  996:              "Before index is out of range (too small)";
        -:  997:         end if;
        -:  998:
        -:  999:         --  We do allow a value greater than Container.Last to be specified as
        -: 1000:         --  the Index, but only if it's immediately greater. This allows for
        -: 1001:         --  the case of appending items to the back end of the vector. (It is
        -: 1002:         --  assumed that specifying an index value greater than Last + 1
        -: 1003:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1004:         --  is treated as a proper error.)
        -: 1005:
    #####: 1006:         if Before > Container.Last + 1 then
    #####: 1007:            raise Constraint_Error with
        -: 1008:              "Before index is out of range (too large)";
        -: 1009:         end if;
        -: 1010:      end if;
        -: 1011:
        -: 1012:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1013:      --  the container is busy, so we simply return.
        -: 1014:
    #####: 1015:      if Count = 0 then
    #####: 1016:         return;
        -: 1017:      end if;
        -: 1018:
        -: 1019:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1020:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1021:      --  we must check the sum of the current length and the insertion count.
        -: 1022:      --  Note: we cannot simply add these values, because of the possibility
        -: 1023:      --  of overflow.
        -: 1024:
    #####: 1025:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1026:         raise Constraint_Error with "Count is out of range";
        -: 1027:      end if;
        -: 1028:
        -: 1029:      --  It is now safe compute the length of the new vector, without fear of
        -: 1030:      --  overflow.
        -: 1031:
    #####: 1032:      New_Length := Old_Length + Count;
        -: 1033:
        -: 1034:      --  The second constraint is that the new Last index value cannot exceed
        -: 1035:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1036:      --  length (computed from the range of values in Index_Type), and then
        -: 1037:      --  compare the new length to the maximum length. If the new length is
        -: 1038:      --  acceptable, then we compute the new last index from that.
        -: 1039:
        -: 1040:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1041:
        -: 1042:         --  We have to handle the case when there might be more values in the
        -: 1043:         --  range of Index_Type than in the range of Count_Type.
        -: 1044:
        -: 1045:         if Index_Type'First <= 0 then
        -: 1046:
        -: 1047:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1048:            --  less than 0, so it is safe to compute the following sum without
        -: 1049:            --  fear of overflow. We need to suppress warnings, because
        -: 1050:            --  otherwise we get an error in -gnatwE mode.
        -: 1051:
        -: 1052:            pragma Warnings (Off);
    #####: 1053:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1054:            pragma Warnings (On);
        -: 1055:
        -: 1056:            if Index <= Index_Type'Last then
        -: 1057:
        -: 1058:               --  We have determined that range of Index_Type has at least as
        -: 1059:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1060:               --  maximum number of items that are allowed.
        -: 1061:
    #####: 1062:               Max_Length := Count_Type'Last;
        -: 1063:
        -: 1064:            else
        -: 1065:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1066:               --  so the maximum number of items is computed from the range of
        -: 1067:               --  the Index_Type.
        -: 1068:
        -: 1069:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1070:            end if;
        -: 1071:
        -: 1072:         else
        -: 1073:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1074:            --  the difference without fear of overflow (which we would have to
        -: 1075:            --  worry about if No_Index were less than 0, but that case is
        -: 1076:            --  handled above).
        -: 1077:
        -: 1078:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1079:               --  We have determined that range of Index_Type has at least as
        -: 1080:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1081:               --  maximum number of items that are allowed.
        -: 1082:
        -: 1083:               Max_Length := Count_Type'Last;
        -: 1084:
        -: 1085:            else
        -: 1086:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1087:               --  so the maximum number of items is computed from the range of
        -: 1088:               --  the Index_Type.
        -: 1089:
        -: 1090:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1091:            end if;
        -: 1092:         end if;
        -: 1093:
        -: 1094:      elsif Index_Type'First <= 0 then
        -: 1095:
        -: 1096:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1097:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1098:         --  overflow.
        -: 1099:
        -: 1100:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1101:
        -: 1102:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1103:
        -: 1104:            --  We have determined that range of Index_Type has at least as
        -: 1105:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1106:            --  number of items that are allowed.
        -: 1107:
        -: 1108:            Max_Length := Count_Type'Last;
        -: 1109:
        -: 1110:         else
        -: 1111:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1112:            --  so the maximum number of items is computed from the range of
        -: 1113:            --  the Index_Type.
        -: 1114:
        -: 1115:            Max_Length :=
        -: 1116:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1117:         end if;
        -: 1118:
        -: 1119:      else
        -: 1120:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1121:         --  difference without fear of overflow (which we would have to worry
        -: 1122:         --  about if No_Index were less than 0, but that case is handled
        -: 1123:         --  above).
        -: 1124:
        -: 1125:         Max_Length :=
        -: 1126:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1127:      end if;
        -: 1128:
        -: 1129:      --  We have just computed the maximum length (number of items). We must
        -: 1130:      --  now compare the requested length to the maximum length, as we do not
        -: 1131:      --  allow a vector expand beyond the maximum (because that would create
        -: 1132:      --  an internal array with a last index value greater than
        -: 1133:      --  Index_Type'Last, with no way to index those elements).
        -: 1134:
    #####: 1135:      if Checks and then New_Length > Max_Length then
    #####: 1136:         raise Constraint_Error with "Count is out of range";
        -: 1137:      end if;
        -: 1138:
        -: 1139:      --  New_Last is the last index value of the items in the container after
        -: 1140:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1141:      --  compute its value from the New_Length.
        -: 1142:
        -: 1143:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1144:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1145:      else
        -: 1146:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1147:      end if;
        -: 1148:
    #####: 1149:      if Container.Elements = null then
    #####: 1150:         pragma Assert (Container.Last = No_Index);
        -: 1151:
        -: 1152:         --  This is the simplest case, with which we must always begin: we're
        -: 1153:         --  inserting items into an empty vector that hasn't allocated an
        -: 1154:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1155:         --  here, because an empty container cannot be busy.
        -: 1156:
        -: 1157:         --  In order to preserve container invariants, we allocate the new
        -: 1158:         --  internal array first, before setting the Last index value, in case
        -: 1159:         --  the allocation fails (which can happen either because there is no
        -: 1160:         --  storage available, or because element initialization fails).
        -: 1161:
    #####: 1162:         Container.Elements := new Elements_Type'
    #####: 1163:                                     (Last => New_Last,
    #####: 1164:                                      EA   => (others => New_Item));
        -: 1165:
        -: 1166:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1167:         --  safe to update the Last index, restoring container invariants.
        -: 1168:
    #####: 1169:         Container.Last := New_Last;
        -: 1170:
    #####: 1171:         return;
        -: 1172:      end if;
        -: 1173:
        -: 1174:      --  An internal array has already been allocated, so we must determine
        -: 1175:      --  whether there is enough unused storage for the new items.
        -: 1176:
    #####: 1177:      if New_Length <= Container.Elements.EA'Length then
        -: 1178:
        -: 1179:         --  In this case, we're inserting elements into a vector that has
        -: 1180:         --  already allocated an internal array, and the existing array has
        -: 1181:         --  enough unused storage for the new items.
        -: 1182:
    #####: 1183:         declare
    #####: 1184:            EA : Elements_Array renames Container.Elements.EA;
        -: 1185:
        -: 1186:         begin
    #####: 1187:            if Before > Container.Last then
        -: 1188:
        -: 1189:               --  The new items are being appended to the vector, so no
        -: 1190:               --  sliding of existing elements is required.
        -: 1191:
    #####: 1192:               EA (Before .. New_Last) := (others => New_Item);
        -: 1193:
        -: 1194:            else
        -: 1195:               --  The new items are being inserted before some existing
        -: 1196:               --  elements, so we must slide the existing elements up to their
        -: 1197:               --  new home. We use the wider of Index_Type'Base and
        -: 1198:               --  Count_Type'Base as the type for intermediate index values.
        -: 1199:
        -: 1200:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1201:                  Index := Before + Index_Type'Base (Count);
        -: 1202:               else
        -: 1203:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1204:               end if;
        -: 1205:
    #####: 1206:               EA (Index .. New_Last) := EA (Before .. Container.Last);
    #####: 1207:               EA (Before .. Index - 1) := (others => New_Item);
        -: 1208:            end if;
    #####: 1209:         end;
        -: 1210:
    #####: 1211:         Container.Last := New_Last;
    #####: 1212:         return;
        -: 1213:      end if;
        -: 1214:
        -: 1215:      --  In this case, we're inserting elements into a vector that has already
        -: 1216:      --  allocated an internal array, but the existing array does not have
        -: 1217:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1218:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1219:      --  allocate an array whose length is some power-of-two factor of the
        -: 1220:      --  current array length. (The new array cannot have a length less than
        -: 1221:      --  the New_Length of the container, but its last index value cannot be
        -: 1222:      --  greater than Index_Type'Last.)
        -: 1223:
    #####: 1224:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1225:      while New_Capacity < New_Length loop
    #####: 1226:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1227:            New_Capacity := Count_Type'Last;
    #####: 1228:            exit;
        -: 1229:         else
    #####: 1230:            New_Capacity := 2 * New_Capacity;
        -: 1231:         end if;
    #####: 1232:      end loop;
        -: 1233:
    #####: 1234:      if New_Capacity > Max_Length then
        -: 1235:
        -: 1236:         --  We have reached the limit of capacity, so no further expansion
        -: 1237:         --  will occur. (This is not a problem, as there is never a need to
        -: 1238:         --  have more capacity than the maximum container length.)
        -: 1239:
    #####: 1240:         New_Capacity := Max_Length;
        -: 1241:      end if;
        -: 1242:
        -: 1243:      --  We have computed the length of the new internal array (and this is
        -: 1244:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1245:
        -: 1246:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1247:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1248:      else
        -: 1249:         Dst_Last :=
        -: 1250:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1251:      end if;
        -: 1252:
        -: 1253:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1254:      --  fails, we have not changed any container state, so no side-effect
        -: 1255:      --  will occur as a result of propagating the exception.
        -: 1256:
    #####: 1257:      Dst := new Elements_Type (Dst_Last);
        -: 1258:
        -: 1259:      --  We have our new internal array. All that needs to be done now is to
        -: 1260:      --  copy the existing items (if any) from the old array (the "source"
        -: 1261:      --  array, object SA below) to the new array (the "destination" array,
        -: 1262:      --  object DA below), and then deallocate the old array.
        -: 1263:
        -: 1264:      declare
    #####: 1265:         SA : Elements_Array renames Container.Elements.EA; -- source
    #####: 1266:         DA : Elements_Array renames Dst.EA;                -- destination
        -: 1267:
        -: 1268:      begin
    #####: 1269:         DA (Index_Type'First .. Before - 1) :=
    #####: 1270:           SA (Index_Type'First .. Before - 1);
        -: 1271:
    #####: 1272:         if Before > Container.Last then
    #####: 1273:            DA (Before .. New_Last) := (others => New_Item);
        -: 1274:
        -: 1275:         else
        -: 1276:            --  The new items are being inserted before some existing elements,
        -: 1277:            --  so we must slide the existing elements up to their new home.
        -: 1278:
        -: 1279:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1280:               Index := Before + Index_Type'Base (Count);
        -: 1281:            else
        -: 1282:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1283:            end if;
        -: 1284:
    #####: 1285:            DA (Before .. Index - 1) := (others => New_Item);
    #####: 1286:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1287:         end if;
        -: 1288:
        -: 1289:      exception
    #####: 1290:         when others =>
    #####: 1291:            Free (Dst);
    #####: 1292:            raise;
        -: 1293:      end;
        -: 1294:
        -: 1295:      --  We have successfully copied the items onto the new array, so the
        -: 1296:      --  final thing to do is deallocate the old array.
        -: 1297:
        -: 1298:      declare
    #####: 1299:         X : Elements_Access := Container.Elements;
        -: 1300:
        -: 1301:      begin
        -: 1302:         --  We first isolate the old internal array, removing it from the
        -: 1303:         --  container and replacing it with the new internal array, before we
        -: 1304:         --  deallocate the old array (which can fail if finalization of
        -: 1305:         --  elements propagates an exception).
        -: 1306:
    #####: 1307:         Container.Elements := Dst;
    #####: 1308:         Container.Last := New_Last;
        -: 1309:
        -: 1310:         --  The container invariants have been restored, so it is now safe to
        -: 1311:         --  attempt to deallocate the old array.
        -: 1312:
    #####: 1313:         Free (X);
        -: 1314:      end;
        -: 1315:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert__4.527:
    #####:  955:   procedure Insert
        -:  956:     (Container : in out Vector;
        -:  957:      Before    : Extended_Index;
        -:  958:      New_Item  : Element_Type;
        -:  959:      Count     : Count_Type := 1)
        -:  960:   is
    #####:  961:      Old_Length : constant Count_Type := Container.Length;
        -:  962:
        -:  963:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -:  964:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -:  965:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -:  966:
        -:  967:      Index : Index_Type'Base;  -- scratch for intermediate values
        -:  968:      J     : Count_Type'Base;  -- scratch
        -:  969:
        -:  970:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -:  971:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####:  972:      Dst          : Elements_Access;  -- new, expanded internal array
        -:  973:
        -:  974:   begin
        -:  975:      --  The tampering bits exist to prevent an item from being harmfully
        -:  976:      --  manipulated while it is being visited. Query, Update, and Iterate
        -:  977:      --  increment the busy count on entry, and decrement the count on
        -:  978:      --  exit. Insert checks the count to determine whether it is being called
        -:  979:      --  while the associated callback procedure is executing.
        -:  980:
    #####:  981:      TC_Check (Container.TC);
        -:  982:
        -:  983:      if Checks then
        -:  984:         --  As a precondition on the generic actual Index_Type, the base type
        -:  985:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  986:         --  that Container.Last assumes when the vector is empty. However, we
        -:  987:         --  do not allow that as the value for Index when specifying where the
        -:  988:         --  new items should be inserted, so we must manually check. (That the
        -:  989:         --  user is allowed to specify the value at all here is a consequence
        -:  990:         --  of the declaration of the Extended_Index subtype, which includes
        -:  991:         --  the values in the base range that immediately precede and
        -:  992:         --  immediately follow the values in the Index_Type.)
        -:  993:
    #####:  994:         if Before < Index_Type'First then
    #####:  995:            raise Constraint_Error with
        -:  996:              "Before index is out of range (too small)";
        -:  997:         end if;
        -:  998:
        -:  999:         --  We do allow a value greater than Container.Last to be specified as
        -: 1000:         --  the Index, but only if it's immediately greater. This allows for
        -: 1001:         --  the case of appending items to the back end of the vector. (It is
        -: 1002:         --  assumed that specifying an index value greater than Last + 1
        -: 1003:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1004:         --  is treated as a proper error.)
        -: 1005:
    #####: 1006:         if Before > Container.Last + 1 then
    #####: 1007:            raise Constraint_Error with
        -: 1008:              "Before index is out of range (too large)";
        -: 1009:         end if;
        -: 1010:      end if;
        -: 1011:
        -: 1012:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1013:      --  the container is busy, so we simply return.
        -: 1014:
    #####: 1015:      if Count = 0 then
    #####: 1016:         return;
        -: 1017:      end if;
        -: 1018:
        -: 1019:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1020:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1021:      --  we must check the sum of the current length and the insertion count.
        -: 1022:      --  Note: we cannot simply add these values, because of the possibility
        -: 1023:      --  of overflow.
        -: 1024:
    #####: 1025:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1026:         raise Constraint_Error with "Count is out of range";
        -: 1027:      end if;
        -: 1028:
        -: 1029:      --  It is now safe compute the length of the new vector, without fear of
        -: 1030:      --  overflow.
        -: 1031:
    #####: 1032:      New_Length := Old_Length + Count;
        -: 1033:
        -: 1034:      --  The second constraint is that the new Last index value cannot exceed
        -: 1035:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1036:      --  length (computed from the range of values in Index_Type), and then
        -: 1037:      --  compare the new length to the maximum length. If the new length is
        -: 1038:      --  acceptable, then we compute the new last index from that.
        -: 1039:
        -: 1040:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1041:
        -: 1042:         --  We have to handle the case when there might be more values in the
        -: 1043:         --  range of Index_Type than in the range of Count_Type.
        -: 1044:
        -: 1045:         if Index_Type'First <= 0 then
        -: 1046:
        -: 1047:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1048:            --  less than 0, so it is safe to compute the following sum without
        -: 1049:            --  fear of overflow. We need to suppress warnings, because
        -: 1050:            --  otherwise we get an error in -gnatwE mode.
        -: 1051:
        -: 1052:            pragma Warnings (Off);
    #####: 1053:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1054:            pragma Warnings (On);
        -: 1055:
        -: 1056:            if Index <= Index_Type'Last then
        -: 1057:
        -: 1058:               --  We have determined that range of Index_Type has at least as
        -: 1059:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1060:               --  maximum number of items that are allowed.
        -: 1061:
    #####: 1062:               Max_Length := Count_Type'Last;
        -: 1063:
        -: 1064:            else
        -: 1065:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1066:               --  so the maximum number of items is computed from the range of
        -: 1067:               --  the Index_Type.
        -: 1068:
        -: 1069:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1070:            end if;
        -: 1071:
        -: 1072:         else
        -: 1073:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1074:            --  the difference without fear of overflow (which we would have to
        -: 1075:            --  worry about if No_Index were less than 0, but that case is
        -: 1076:            --  handled above).
        -: 1077:
        -: 1078:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1079:               --  We have determined that range of Index_Type has at least as
        -: 1080:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1081:               --  maximum number of items that are allowed.
        -: 1082:
        -: 1083:               Max_Length := Count_Type'Last;
        -: 1084:
        -: 1085:            else
        -: 1086:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1087:               --  so the maximum number of items is computed from the range of
        -: 1088:               --  the Index_Type.
        -: 1089:
        -: 1090:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1091:            end if;
        -: 1092:         end if;
        -: 1093:
        -: 1094:      elsif Index_Type'First <= 0 then
        -: 1095:
        -: 1096:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1097:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1098:         --  overflow.
        -: 1099:
        -: 1100:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1101:
        -: 1102:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1103:
        -: 1104:            --  We have determined that range of Index_Type has at least as
        -: 1105:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1106:            --  number of items that are allowed.
        -: 1107:
        -: 1108:            Max_Length := Count_Type'Last;
        -: 1109:
        -: 1110:         else
        -: 1111:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1112:            --  so the maximum number of items is computed from the range of
        -: 1113:            --  the Index_Type.
        -: 1114:
        -: 1115:            Max_Length :=
        -: 1116:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1117:         end if;
        -: 1118:
        -: 1119:      else
        -: 1120:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1121:         --  difference without fear of overflow (which we would have to worry
        -: 1122:         --  about if No_Index were less than 0, but that case is handled
        -: 1123:         --  above).
        -: 1124:
        -: 1125:         Max_Length :=
        -: 1126:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1127:      end if;
        -: 1128:
        -: 1129:      --  We have just computed the maximum length (number of items). We must
        -: 1130:      --  now compare the requested length to the maximum length, as we do not
        -: 1131:      --  allow a vector expand beyond the maximum (because that would create
        -: 1132:      --  an internal array with a last index value greater than
        -: 1133:      --  Index_Type'Last, with no way to index those elements).
        -: 1134:
    #####: 1135:      if Checks and then New_Length > Max_Length then
    #####: 1136:         raise Constraint_Error with "Count is out of range";
        -: 1137:      end if;
        -: 1138:
        -: 1139:      --  New_Last is the last index value of the items in the container after
        -: 1140:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1141:      --  compute its value from the New_Length.
        -: 1142:
        -: 1143:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1144:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1145:      else
        -: 1146:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1147:      end if;
        -: 1148:
    #####: 1149:      if Container.Elements = null then
    #####: 1150:         pragma Assert (Container.Last = No_Index);
        -: 1151:
        -: 1152:         --  This is the simplest case, with which we must always begin: we're
        -: 1153:         --  inserting items into an empty vector that hasn't allocated an
        -: 1154:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1155:         --  here, because an empty container cannot be busy.
        -: 1156:
        -: 1157:         --  In order to preserve container invariants, we allocate the new
        -: 1158:         --  internal array first, before setting the Last index value, in case
        -: 1159:         --  the allocation fails (which can happen either because there is no
        -: 1160:         --  storage available, or because element initialization fails).
        -: 1161:
    #####: 1162:         Container.Elements := new Elements_Type'
    #####: 1163:                                     (Last => New_Last,
    #####: 1164:                                      EA   => (others => New_Item));
        -: 1165:
        -: 1166:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1167:         --  safe to update the Last index, restoring container invariants.
        -: 1168:
    #####: 1169:         Container.Last := New_Last;
        -: 1170:
    #####: 1171:         return;
        -: 1172:      end if;
        -: 1173:
        -: 1174:      --  An internal array has already been allocated, so we must determine
        -: 1175:      --  whether there is enough unused storage for the new items.
        -: 1176:
    #####: 1177:      if New_Length <= Container.Elements.EA'Length then
        -: 1178:
        -: 1179:         --  In this case, we're inserting elements into a vector that has
        -: 1180:         --  already allocated an internal array, and the existing array has
        -: 1181:         --  enough unused storage for the new items.
        -: 1182:
        -: 1183:         declare
    #####: 1184:            EA : Elements_Array renames Container.Elements.EA;
        -: 1185:
        -: 1186:         begin
    #####: 1187:            if Before > Container.Last then
        -: 1188:
        -: 1189:               --  The new items are being appended to the vector, so no
        -: 1190:               --  sliding of existing elements is required.
        -: 1191:
    #####: 1192:               EA (Before .. New_Last) := (others => New_Item);
        -: 1193:
        -: 1194:            else
        -: 1195:               --  The new items are being inserted before some existing
        -: 1196:               --  elements, so we must slide the existing elements up to their
        -: 1197:               --  new home. We use the wider of Index_Type'Base and
        -: 1198:               --  Count_Type'Base as the type for intermediate index values.
        -: 1199:
        -: 1200:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1201:                  Index := Before + Index_Type'Base (Count);
        -: 1202:               else
        -: 1203:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1204:               end if;
        -: 1205:
    #####: 1206:               EA (Index .. New_Last) := EA (Before .. Container.Last);
    #####: 1207:               EA (Before .. Index - 1) := (others => New_Item);
        -: 1208:            end if;
        -: 1209:         end;
        -: 1210:
    #####: 1211:         Container.Last := New_Last;
    #####: 1212:         return;
        -: 1213:      end if;
        -: 1214:
        -: 1215:      --  In this case, we're inserting elements into a vector that has already
        -: 1216:      --  allocated an internal array, but the existing array does not have
        -: 1217:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1218:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1219:      --  allocate an array whose length is some power-of-two factor of the
        -: 1220:      --  current array length. (The new array cannot have a length less than
        -: 1221:      --  the New_Length of the container, but its last index value cannot be
        -: 1222:      --  greater than Index_Type'Last.)
        -: 1223:
    #####: 1224:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1225:      while New_Capacity < New_Length loop
    #####: 1226:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1227:            New_Capacity := Count_Type'Last;
    #####: 1228:            exit;
        -: 1229:         else
    #####: 1230:            New_Capacity := 2 * New_Capacity;
        -: 1231:         end if;
    #####: 1232:      end loop;
        -: 1233:
    #####: 1234:      if New_Capacity > Max_Length then
        -: 1235:
        -: 1236:         --  We have reached the limit of capacity, so no further expansion
        -: 1237:         --  will occur. (This is not a problem, as there is never a need to
        -: 1238:         --  have more capacity than the maximum container length.)
        -: 1239:
    #####: 1240:         New_Capacity := Max_Length;
        -: 1241:      end if;
        -: 1242:
        -: 1243:      --  We have computed the length of the new internal array (and this is
        -: 1244:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1245:
        -: 1246:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1247:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1248:      else
        -: 1249:         Dst_Last :=
        -: 1250:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1251:      end if;
        -: 1252:
        -: 1253:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1254:      --  fails, we have not changed any container state, so no side-effect
        -: 1255:      --  will occur as a result of propagating the exception.
        -: 1256:
    #####: 1257:      Dst := new Elements_Type (Dst_Last);
        -: 1258:
        -: 1259:      --  We have our new internal array. All that needs to be done now is to
        -: 1260:      --  copy the existing items (if any) from the old array (the "source"
        -: 1261:      --  array, object SA below) to the new array (the "destination" array,
        -: 1262:      --  object DA below), and then deallocate the old array.
        -: 1263:
        -: 1264:      declare
    #####: 1265:         SA : Elements_Array renames Container.Elements.EA; -- source
    #####: 1266:         DA : Elements_Array renames Dst.EA;                -- destination
        -: 1267:
        -: 1268:      begin
    #####: 1269:         DA (Index_Type'First .. Before - 1) :=
    #####: 1270:           SA (Index_Type'First .. Before - 1);
        -: 1271:
    #####: 1272:         if Before > Container.Last then
    #####: 1273:            DA (Before .. New_Last) := (others => New_Item);
        -: 1274:
        -: 1275:         else
        -: 1276:            --  The new items are being inserted before some existing elements,
        -: 1277:            --  so we must slide the existing elements up to their new home.
        -: 1278:
        -: 1279:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1280:               Index := Before + Index_Type'Base (Count);
        -: 1281:            else
        -: 1282:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1283:            end if;
        -: 1284:
    #####: 1285:            DA (Before .. Index - 1) := (others => New_Item);
    #####: 1286:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1287:         end if;
        -: 1288:
        -: 1289:      exception
    #####: 1290:         when others =>
    #####: 1291:            Free (Dst);
    #####: 1292:            raise;
        -: 1293:      end;
        -: 1294:
        -: 1295:      --  We have successfully copied the items onto the new array, so the
        -: 1296:      --  final thing to do is deallocate the old array.
        -: 1297:
        -: 1298:      declare
    #####: 1299:         X : Elements_Access := Container.Elements;
        -: 1300:
        -: 1301:      begin
        -: 1302:         --  We first isolate the old internal array, removing it from the
        -: 1303:         --  container and replacing it with the new internal array, before we
        -: 1304:         --  deallocate the old array (which can fail if finalization of
        -: 1305:         --  elements propagates an exception).
        -: 1306:
    #####: 1307:         Container.Elements := Dst;
    #####: 1308:         Container.Last := New_Last;
        -: 1309:
        -: 1310:         --  The container invariants have been restored, so it is now safe to
        -: 1311:         --  attempt to deallocate the old array.
        -: 1312:
    #####: 1313:         Free (X);
        -: 1314:      end;
        -: 1315:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert__4.656:
    #####:  955:   procedure Insert
        -:  956:     (Container : in out Vector;
        -:  957:      Before    : Extended_Index;
        -:  958:      New_Item  : Element_Type;
        -:  959:      Count     : Count_Type := 1)
        -:  960:   is
    #####:  961:      Old_Length : constant Count_Type := Container.Length;
        -:  962:
        -:  963:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -:  964:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -:  965:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -:  966:
        -:  967:      Index : Index_Type'Base;  -- scratch for intermediate values
        -:  968:      J     : Count_Type'Base;  -- scratch
        -:  969:
        -:  970:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -:  971:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####:  972:      Dst          : Elements_Access;  -- new, expanded internal array
        -:  973:
        -:  974:   begin
        -:  975:      --  The tampering bits exist to prevent an item from being harmfully
        -:  976:      --  manipulated while it is being visited. Query, Update, and Iterate
        -:  977:      --  increment the busy count on entry, and decrement the count on
        -:  978:      --  exit. Insert checks the count to determine whether it is being called
        -:  979:      --  while the associated callback procedure is executing.
        -:  980:
    #####:  981:      TC_Check (Container.TC);
        -:  982:
        -:  983:      if Checks then
        -:  984:         --  As a precondition on the generic actual Index_Type, the base type
        -:  985:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -:  986:         --  that Container.Last assumes when the vector is empty. However, we
        -:  987:         --  do not allow that as the value for Index when specifying where the
        -:  988:         --  new items should be inserted, so we must manually check. (That the
        -:  989:         --  user is allowed to specify the value at all here is a consequence
        -:  990:         --  of the declaration of the Extended_Index subtype, which includes
        -:  991:         --  the values in the base range that immediately precede and
        -:  992:         --  immediately follow the values in the Index_Type.)
        -:  993:
    #####:  994:         if Before < Index_Type'First then
    #####:  995:            raise Constraint_Error with
        -:  996:              "Before index is out of range (too small)";
        -:  997:         end if;
        -:  998:
        -:  999:         --  We do allow a value greater than Container.Last to be specified as
        -: 1000:         --  the Index, but only if it's immediately greater. This allows for
        -: 1001:         --  the case of appending items to the back end of the vector. (It is
        -: 1002:         --  assumed that specifying an index value greater than Last + 1
        -: 1003:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1004:         --  is treated as a proper error.)
        -: 1005:
    #####: 1006:         if Before > Container.Last + 1 then
    #####: 1007:            raise Constraint_Error with
        -: 1008:              "Before index is out of range (too large)";
        -: 1009:         end if;
        -: 1010:      end if;
        -: 1011:
        -: 1012:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1013:      --  the container is busy, so we simply return.
        -: 1014:
    #####: 1015:      if Count = 0 then
    #####: 1016:         return;
        -: 1017:      end if;
        -: 1018:
        -: 1019:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1020:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1021:      --  we must check the sum of the current length and the insertion count.
        -: 1022:      --  Note: we cannot simply add these values, because of the possibility
        -: 1023:      --  of overflow.
        -: 1024:
    #####: 1025:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1026:         raise Constraint_Error with "Count is out of range";
        -: 1027:      end if;
        -: 1028:
        -: 1029:      --  It is now safe compute the length of the new vector, without fear of
        -: 1030:      --  overflow.
        -: 1031:
    #####: 1032:      New_Length := Old_Length + Count;
        -: 1033:
        -: 1034:      --  The second constraint is that the new Last index value cannot exceed
        -: 1035:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1036:      --  length (computed from the range of values in Index_Type), and then
        -: 1037:      --  compare the new length to the maximum length. If the new length is
        -: 1038:      --  acceptable, then we compute the new last index from that.
        -: 1039:
        -: 1040:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1041:
        -: 1042:         --  We have to handle the case when there might be more values in the
        -: 1043:         --  range of Index_Type than in the range of Count_Type.
        -: 1044:
        -: 1045:         if Index_Type'First <= 0 then
        -: 1046:
        -: 1047:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1048:            --  less than 0, so it is safe to compute the following sum without
        -: 1049:            --  fear of overflow. We need to suppress warnings, because
        -: 1050:            --  otherwise we get an error in -gnatwE mode.
        -: 1051:
        -: 1052:            pragma Warnings (Off);
    #####: 1053:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1054:            pragma Warnings (On);
        -: 1055:
        -: 1056:            if Index <= Index_Type'Last then
        -: 1057:
        -: 1058:               --  We have determined that range of Index_Type has at least as
        -: 1059:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1060:               --  maximum number of items that are allowed.
        -: 1061:
    #####: 1062:               Max_Length := Count_Type'Last;
        -: 1063:
        -: 1064:            else
        -: 1065:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1066:               --  so the maximum number of items is computed from the range of
        -: 1067:               --  the Index_Type.
        -: 1068:
        -: 1069:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1070:            end if;
        -: 1071:
        -: 1072:         else
        -: 1073:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1074:            --  the difference without fear of overflow (which we would have to
        -: 1075:            --  worry about if No_Index were less than 0, but that case is
        -: 1076:            --  handled above).
        -: 1077:
        -: 1078:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1079:               --  We have determined that range of Index_Type has at least as
        -: 1080:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1081:               --  maximum number of items that are allowed.
        -: 1082:
        -: 1083:               Max_Length := Count_Type'Last;
        -: 1084:
        -: 1085:            else
        -: 1086:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1087:               --  so the maximum number of items is computed from the range of
        -: 1088:               --  the Index_Type.
        -: 1089:
        -: 1090:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1091:            end if;
        -: 1092:         end if;
        -: 1093:
        -: 1094:      elsif Index_Type'First <= 0 then
        -: 1095:
        -: 1096:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1097:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1098:         --  overflow.
        -: 1099:
        -: 1100:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1101:
        -: 1102:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1103:
        -: 1104:            --  We have determined that range of Index_Type has at least as
        -: 1105:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1106:            --  number of items that are allowed.
        -: 1107:
        -: 1108:            Max_Length := Count_Type'Last;
        -: 1109:
        -: 1110:         else
        -: 1111:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1112:            --  so the maximum number of items is computed from the range of
        -: 1113:            --  the Index_Type.
        -: 1114:
        -: 1115:            Max_Length :=
        -: 1116:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1117:         end if;
        -: 1118:
        -: 1119:      else
        -: 1120:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1121:         --  difference without fear of overflow (which we would have to worry
        -: 1122:         --  about if No_Index were less than 0, but that case is handled
        -: 1123:         --  above).
        -: 1124:
        -: 1125:         Max_Length :=
        -: 1126:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1127:      end if;
        -: 1128:
        -: 1129:      --  We have just computed the maximum length (number of items). We must
        -: 1130:      --  now compare the requested length to the maximum length, as we do not
        -: 1131:      --  allow a vector expand beyond the maximum (because that would create
        -: 1132:      --  an internal array with a last index value greater than
        -: 1133:      --  Index_Type'Last, with no way to index those elements).
        -: 1134:
    #####: 1135:      if Checks and then New_Length > Max_Length then
    #####: 1136:         raise Constraint_Error with "Count is out of range";
        -: 1137:      end if;
        -: 1138:
        -: 1139:      --  New_Last is the last index value of the items in the container after
        -: 1140:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1141:      --  compute its value from the New_Length.
        -: 1142:
        -: 1143:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1144:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1145:      else
        -: 1146:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1147:      end if;
        -: 1148:
    #####: 1149:      if Container.Elements = null then
    #####: 1150:         pragma Assert (Container.Last = No_Index);
        -: 1151:
        -: 1152:         --  This is the simplest case, with which we must always begin: we're
        -: 1153:         --  inserting items into an empty vector that hasn't allocated an
        -: 1154:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1155:         --  here, because an empty container cannot be busy.
        -: 1156:
        -: 1157:         --  In order to preserve container invariants, we allocate the new
        -: 1158:         --  internal array first, before setting the Last index value, in case
        -: 1159:         --  the allocation fails (which can happen either because there is no
        -: 1160:         --  storage available, or because element initialization fails).
        -: 1161:
    #####: 1162:         Container.Elements := new Elements_Type'
    #####: 1163:                                     (Last => New_Last,
    #####: 1164:                                      EA   => (others => New_Item));
        -: 1165:
        -: 1166:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1167:         --  safe to update the Last index, restoring container invariants.
        -: 1168:
    #####: 1169:         Container.Last := New_Last;
        -: 1170:
    #####: 1171:         return;
        -: 1172:      end if;
        -: 1173:
        -: 1174:      --  An internal array has already been allocated, so we must determine
        -: 1175:      --  whether there is enough unused storage for the new items.
        -: 1176:
    #####: 1177:      if New_Length <= Container.Elements.EA'Length then
        -: 1178:
        -: 1179:         --  In this case, we're inserting elements into a vector that has
        -: 1180:         --  already allocated an internal array, and the existing array has
        -: 1181:         --  enough unused storage for the new items.
        -: 1182:
    #####: 1183:         declare
    #####: 1184:            EA : Elements_Array renames Container.Elements.EA;
        -: 1185:
        -: 1186:         begin
    #####: 1187:            if Before > Container.Last then
        -: 1188:
        -: 1189:               --  The new items are being appended to the vector, so no
        -: 1190:               --  sliding of existing elements is required.
        -: 1191:
    #####: 1192:               EA (Before .. New_Last) := (others => New_Item);
        -: 1193:
        -: 1194:            else
        -: 1195:               --  The new items are being inserted before some existing
        -: 1196:               --  elements, so we must slide the existing elements up to their
        -: 1197:               --  new home. We use the wider of Index_Type'Base and
        -: 1198:               --  Count_Type'Base as the type for intermediate index values.
        -: 1199:
        -: 1200:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1201:                  Index := Before + Index_Type'Base (Count);
        -: 1202:               else
        -: 1203:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1204:               end if;
        -: 1205:
    #####: 1206:               EA (Index .. New_Last) := EA (Before .. Container.Last);
    #####: 1207:               EA (Before .. Index - 1) := (others => New_Item);
        -: 1208:            end if;
    #####: 1209:         end;
        -: 1210:
    #####: 1211:         Container.Last := New_Last;
    #####: 1212:         return;
        -: 1213:      end if;
        -: 1214:
        -: 1215:      --  In this case, we're inserting elements into a vector that has already
        -: 1216:      --  allocated an internal array, but the existing array does not have
        -: 1217:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1218:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1219:      --  allocate an array whose length is some power-of-two factor of the
        -: 1220:      --  current array length. (The new array cannot have a length less than
        -: 1221:      --  the New_Length of the container, but its last index value cannot be
        -: 1222:      --  greater than Index_Type'Last.)
        -: 1223:
    #####: 1224:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1225:      while New_Capacity < New_Length loop
    #####: 1226:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1227:            New_Capacity := Count_Type'Last;
    #####: 1228:            exit;
        -: 1229:         else
    #####: 1230:            New_Capacity := 2 * New_Capacity;
        -: 1231:         end if;
    #####: 1232:      end loop;
        -: 1233:
    #####: 1234:      if New_Capacity > Max_Length then
        -: 1235:
        -: 1236:         --  We have reached the limit of capacity, so no further expansion
        -: 1237:         --  will occur. (This is not a problem, as there is never a need to
        -: 1238:         --  have more capacity than the maximum container length.)
        -: 1239:
    #####: 1240:         New_Capacity := Max_Length;
        -: 1241:      end if;
        -: 1242:
        -: 1243:      --  We have computed the length of the new internal array (and this is
        -: 1244:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1245:
        -: 1246:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1247:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1248:      else
        -: 1249:         Dst_Last :=
        -: 1250:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1251:      end if;
        -: 1252:
        -: 1253:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1254:      --  fails, we have not changed any container state, so no side-effect
        -: 1255:      --  will occur as a result of propagating the exception.
        -: 1256:
    #####: 1257:      Dst := new Elements_Type (Dst_Last);
        -: 1258:
        -: 1259:      --  We have our new internal array. All that needs to be done now is to
        -: 1260:      --  copy the existing items (if any) from the old array (the "source"
        -: 1261:      --  array, object SA below) to the new array (the "destination" array,
        -: 1262:      --  object DA below), and then deallocate the old array.
        -: 1263:
        -: 1264:      declare
    #####: 1265:         SA : Elements_Array renames Container.Elements.EA; -- source
    #####: 1266:         DA : Elements_Array renames Dst.EA;                -- destination
        -: 1267:
        -: 1268:      begin
    #####: 1269:         DA (Index_Type'First .. Before - 1) :=
    #####: 1270:           SA (Index_Type'First .. Before - 1);
        -: 1271:
    #####: 1272:         if Before > Container.Last then
    #####: 1273:            DA (Before .. New_Last) := (others => New_Item);
        -: 1274:
        -: 1275:         else
        -: 1276:            --  The new items are being inserted before some existing elements,
        -: 1277:            --  so we must slide the existing elements up to their new home.
        -: 1278:
        -: 1279:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1280:               Index := Before + Index_Type'Base (Count);
        -: 1281:            else
        -: 1282:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1283:            end if;
        -: 1284:
    #####: 1285:            DA (Before .. Index - 1) := (others => New_Item);
    #####: 1286:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1287:         end if;
        -: 1288:
        -: 1289:      exception
    #####: 1290:         when others =>
    #####: 1291:            Free (Dst);
    #####: 1292:            raise;
        -: 1293:      end;
        -: 1294:
        -: 1295:      --  We have successfully copied the items onto the new array, so the
        -: 1296:      --  final thing to do is deallocate the old array.
        -: 1297:
        -: 1298:      declare
    #####: 1299:         X : Elements_Access := Container.Elements;
        -: 1300:
        -: 1301:      begin
        -: 1302:         --  We first isolate the old internal array, removing it from the
        -: 1303:         --  container and replacing it with the new internal array, before we
        -: 1304:         --  deallocate the old array (which can fail if finalization of
        -: 1305:         --  elements propagates an exception).
        -: 1306:
    #####: 1307:         Container.Elements := Dst;
    #####: 1308:         Container.Last := New_Last;
        -: 1309:
        -: 1310:         --  The container invariants have been restored, so it is now safe to
        -: 1311:         --  attempt to deallocate the old array.
        -: 1312:
    #####: 1313:         Free (X);
        -: 1314:      end;
        -: 1315:   end Insert;
------------------
        -: 1316:
    #####: 1317:   procedure Insert_Vector
        -: 1318:     (Container : in out Vector;
        -: 1319:      Before    : Extended_Index;
        -: 1320:      New_Item  : Vector)
        -: 1321:   is
    #####: 1322:      N : constant Count_Type := Length (New_Item);
        -: 1323:      J : Index_Type'Base;
        -: 1324:
        -: 1325:   begin
        -: 1326:      --  Use Insert_Space to create the "hole" (the destination slice) into
        -: 1327:      --  which we copy the source items.
        -: 1328:
    #####: 1329:      Insert_Space (Container, Before, Count => N);
        -: 1330:
    #####: 1331:      if N = 0 then
        -: 1332:
        -: 1333:         --  There's nothing else to do here (vetting of parameters was
        -: 1334:         --  performed already in Insert_Space), so we simply return.
        -: 1335:
    #####: 1336:         return;
        -: 1337:      end if;
        -: 1338:
        -: 1339:      --  We calculate the last index value of the destination slice using the
        -: 1340:      --  wider of Index_Type'Base and count_Type'Base.
        -: 1341:
        -: 1342:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1343:         J := (Before - 1) + Index_Type'Base (N);
        -: 1344:      else
        -: 1345:         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);
        -: 1346:      end if;
        -: 1347:
    #####: 1348:      if Container'Address /= New_Item'Address then
        -: 1349:
        -: 1350:         --  This is the simple case.  New_Item denotes an object different
        -: 1351:         --  from Container, so there's nothing special we need to do to copy
        -: 1352:         --  the source items to their destination, because all of the source
        -: 1353:         --  items are contiguous.
        -: 1354:
    #####: 1355:         Container.Elements.EA (Before .. J) :=
    #####: 1356:           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);
        -: 1357:
    #####: 1358:         return;
        -: 1359:      end if;
        -: 1360:
        -: 1361:      --  New_Item denotes the same object as Container, so an insertion has
        -: 1362:      --  potentially split the source items. The destination is always the
        -: 1363:      --  range [Before, J], but the source is [Index_Type'First, Before) and
        -: 1364:      --  (J, Container.Last]. We perform the copy in two steps, using each of
        -: 1365:      --  the two slices of the source items.
        -: 1366:
        -: 1367:      declare
    #####: 1368:         L : constant Index_Type'Base := Before - 1;
        -: 1369:
    #####: 1370:         subtype Src_Index_Subtype is Index_Type'Base range
        -: 1371:           Index_Type'First .. L;
        -: 1372:
    #####: 1373:         Src : Elements_Array renames
    #####: 1374:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1375:
        -: 1376:         K : Index_Type'Base;
        -: 1377:
        -: 1378:      begin
        -: 1379:         --  We first copy the source items that precede the space we
        -: 1380:         --  inserted. Index value K is the last index of that portion
        -: 1381:         --  destination that receives this slice of the source. (If Before
        -: 1382:         --  equals Index_Type'First, then this first source slice will be
        -: 1383:         --  empty, which is harmless.)
        -: 1384:
        -: 1385:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1386:            K := L + Index_Type'Base (Src'Length);
        -: 1387:         else
        -: 1388:            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);
        -: 1389:         end if;
        -: 1390:
    #####: 1391:         Container.Elements.EA (Before .. K) := Src;
        -: 1392:
    #####: 1393:         if Src'Length = N then
        -: 1394:
        -: 1395:            --  The new items were effectively appended to the container, so we
        -: 1396:            --  have already copied all of the items that need to be copied.
        -: 1397:            --  We return early here, even though the source slice below is
        -: 1398:            --  empty (so the assignment would be harmless), because we want to
        -: 1399:            --  avoid computing J + 1, which will overflow if J equals
        -: 1400:            --  Index_Type'Base'Last.
        -: 1401:
    #####: 1402:            return;
        -: 1403:         end if;
        -: 1404:      end;
        -: 1405:
        -: 1406:      declare
        -: 1407:         --  Note that we want to avoid computing J + 1 here, in case J equals
        -: 1408:         --  Index_Type'Base'Last. We prevent that by returning early above,
        -: 1409:         --  immediately after copying the first slice of the source, and
        -: 1410:         --  determining that this second slice of the source is empty.
        -: 1411:
    #####: 1412:         F : constant Index_Type'Base := J + 1;
        -: 1413:
    #####: 1414:         subtype Src_Index_Subtype is Index_Type'Base range
    #####: 1415:           F .. Container.Last;
        -: 1416:
    #####: 1417:         Src : Elements_Array renames
    #####: 1418:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1419:
        -: 1420:         K : Index_Type'Base;
        -: 1421:
        -: 1422:      begin
        -: 1423:         --  We next copy the source items that follow the space we inserted.
        -: 1424:         --  Index value K is the first index of that portion of the
        -: 1425:         --  destination that receives this slice of the source. (For the
        -: 1426:         --  reasons given above, this slice is guaranteed to be non-empty.)
        -: 1427:
        -: 1428:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1429:            K := F - Index_Type'Base (Src'Length);
        -: 1430:         else
        -: 1431:            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);
        -: 1432:         end if;
        -: 1433:
    #####: 1434:         Container.Elements.EA (K .. J) := Src;
        -: 1435:      end;
        -: 1436:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert_vector.167:
    #####: 1317:   procedure Insert_Vector
        -: 1318:     (Container : in out Vector;
        -: 1319:      Before    : Extended_Index;
        -: 1320:      New_Item  : Vector)
        -: 1321:   is
    #####: 1322:      N : constant Count_Type := Length (New_Item);
        -: 1323:      J : Index_Type'Base;
        -: 1324:
        -: 1325:   begin
        -: 1326:      --  Use Insert_Space to create the "hole" (the destination slice) into
        -: 1327:      --  which we copy the source items.
        -: 1328:
    #####: 1329:      Insert_Space (Container, Before, Count => N);
        -: 1330:
    #####: 1331:      if N = 0 then
        -: 1332:
        -: 1333:         --  There's nothing else to do here (vetting of parameters was
        -: 1334:         --  performed already in Insert_Space), so we simply return.
        -: 1335:
    #####: 1336:         return;
        -: 1337:      end if;
        -: 1338:
        -: 1339:      --  We calculate the last index value of the destination slice using the
        -: 1340:      --  wider of Index_Type'Base and count_Type'Base.
        -: 1341:
        -: 1342:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1343:         J := (Before - 1) + Index_Type'Base (N);
        -: 1344:      else
        -: 1345:         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);
        -: 1346:      end if;
        -: 1347:
    #####: 1348:      if Container'Address /= New_Item'Address then
        -: 1349:
        -: 1350:         --  This is the simple case.  New_Item denotes an object different
        -: 1351:         --  from Container, so there's nothing special we need to do to copy
        -: 1352:         --  the source items to their destination, because all of the source
        -: 1353:         --  items are contiguous.
        -: 1354:
    #####: 1355:         Container.Elements.EA (Before .. J) :=
    #####: 1356:           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);
        -: 1357:
    #####: 1358:         return;
        -: 1359:      end if;
        -: 1360:
        -: 1361:      --  New_Item denotes the same object as Container, so an insertion has
        -: 1362:      --  potentially split the source items. The destination is always the
        -: 1363:      --  range [Before, J], but the source is [Index_Type'First, Before) and
        -: 1364:      --  (J, Container.Last]. We perform the copy in two steps, using each of
        -: 1365:      --  the two slices of the source items.
        -: 1366:
        -: 1367:      declare
    #####: 1368:         L : constant Index_Type'Base := Before - 1;
        -: 1369:
    #####: 1370:         subtype Src_Index_Subtype is Index_Type'Base range
        -: 1371:           Index_Type'First .. L;
        -: 1372:
    #####: 1373:         Src : Elements_Array renames
    #####: 1374:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1375:
        -: 1376:         K : Index_Type'Base;
        -: 1377:
        -: 1378:      begin
        -: 1379:         --  We first copy the source items that precede the space we
        -: 1380:         --  inserted. Index value K is the last index of that portion
        -: 1381:         --  destination that receives this slice of the source. (If Before
        -: 1382:         --  equals Index_Type'First, then this first source slice will be
        -: 1383:         --  empty, which is harmless.)
        -: 1384:
        -: 1385:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1386:            K := L + Index_Type'Base (Src'Length);
        -: 1387:         else
        -: 1388:            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);
        -: 1389:         end if;
        -: 1390:
    #####: 1391:         Container.Elements.EA (Before .. K) := Src;
        -: 1392:
    #####: 1393:         if Src'Length = N then
        -: 1394:
        -: 1395:            --  The new items were effectively appended to the container, so we
        -: 1396:            --  have already copied all of the items that need to be copied.
        -: 1397:            --  We return early here, even though the source slice below is
        -: 1398:            --  empty (so the assignment would be harmless), because we want to
        -: 1399:            --  avoid computing J + 1, which will overflow if J equals
        -: 1400:            --  Index_Type'Base'Last.
        -: 1401:
    #####: 1402:            return;
        -: 1403:         end if;
        -: 1404:      end;
        -: 1405:
        -: 1406:      declare
        -: 1407:         --  Note that we want to avoid computing J + 1 here, in case J equals
        -: 1408:         --  Index_Type'Base'Last. We prevent that by returning early above,
        -: 1409:         --  immediately after copying the first slice of the source, and
        -: 1410:         --  determining that this second slice of the source is empty.
        -: 1411:
    #####: 1412:         F : constant Index_Type'Base := J + 1;
        -: 1413:
    #####: 1414:         subtype Src_Index_Subtype is Index_Type'Base range
    #####: 1415:           F .. Container.Last;
        -: 1416:
    #####: 1417:         Src : Elements_Array renames
    #####: 1418:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1419:
        -: 1420:         K : Index_Type'Base;
        -: 1421:
        -: 1422:      begin
        -: 1423:         --  We next copy the source items that follow the space we inserted.
        -: 1424:         --  Index value K is the first index of that portion of the
        -: 1425:         --  destination that receives this slice of the source. (For the
        -: 1426:         --  reasons given above, this slice is guaranteed to be non-empty.)
        -: 1427:
        -: 1428:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1429:            K := F - Index_Type'Base (Src'Length);
        -: 1430:         else
        -: 1431:            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);
        -: 1432:         end if;
        -: 1433:
    #####: 1434:         Container.Elements.EA (K .. J) := Src;
        -: 1435:      end;
        -: 1436:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert_vector.296:
    #####: 1317:   procedure Insert_Vector
        -: 1318:     (Container : in out Vector;
        -: 1319:      Before    : Extended_Index;
        -: 1320:      New_Item  : Vector)
        -: 1321:   is
    #####: 1322:      N : constant Count_Type := Length (New_Item);
        -: 1323:      J : Index_Type'Base;
        -: 1324:
        -: 1325:   begin
        -: 1326:      --  Use Insert_Space to create the "hole" (the destination slice) into
        -: 1327:      --  which we copy the source items.
        -: 1328:
    #####: 1329:      Insert_Space (Container, Before, Count => N);
        -: 1330:
    #####: 1331:      if N = 0 then
        -: 1332:
        -: 1333:         --  There's nothing else to do here (vetting of parameters was
        -: 1334:         --  performed already in Insert_Space), so we simply return.
        -: 1335:
    #####: 1336:         return;
        -: 1337:      end if;
        -: 1338:
        -: 1339:      --  We calculate the last index value of the destination slice using the
        -: 1340:      --  wider of Index_Type'Base and count_Type'Base.
        -: 1341:
        -: 1342:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1343:         J := (Before - 1) + Index_Type'Base (N);
        -: 1344:      else
        -: 1345:         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);
        -: 1346:      end if;
        -: 1347:
    #####: 1348:      if Container'Address /= New_Item'Address then
        -: 1349:
        -: 1350:         --  This is the simple case.  New_Item denotes an object different
        -: 1351:         --  from Container, so there's nothing special we need to do to copy
        -: 1352:         --  the source items to their destination, because all of the source
        -: 1353:         --  items are contiguous.
        -: 1354:
    #####: 1355:         Container.Elements.EA (Before .. J) :=
    #####: 1356:           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);
        -: 1357:
    #####: 1358:         return;
        -: 1359:      end if;
        -: 1360:
        -: 1361:      --  New_Item denotes the same object as Container, so an insertion has
        -: 1362:      --  potentially split the source items. The destination is always the
        -: 1363:      --  range [Before, J], but the source is [Index_Type'First, Before) and
        -: 1364:      --  (J, Container.Last]. We perform the copy in two steps, using each of
        -: 1365:      --  the two slices of the source items.
        -: 1366:
        -: 1367:      declare
    #####: 1368:         L : constant Index_Type'Base := Before - 1;
        -: 1369:
    #####: 1370:         subtype Src_Index_Subtype is Index_Type'Base range
        -: 1371:           Index_Type'First .. L;
        -: 1372:
    #####: 1373:         Src : Elements_Array renames
    #####: 1374:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1375:
        -: 1376:         K : Index_Type'Base;
        -: 1377:
        -: 1378:      begin
        -: 1379:         --  We first copy the source items that precede the space we
        -: 1380:         --  inserted. Index value K is the last index of that portion
        -: 1381:         --  destination that receives this slice of the source. (If Before
        -: 1382:         --  equals Index_Type'First, then this first source slice will be
        -: 1383:         --  empty, which is harmless.)
        -: 1384:
        -: 1385:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1386:            K := L + Index_Type'Base (Src'Length);
        -: 1387:         else
        -: 1388:            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);
        -: 1389:         end if;
        -: 1390:
    #####: 1391:         Container.Elements.EA (Before .. K) := Src;
        -: 1392:
    #####: 1393:         if Src'Length = N then
        -: 1394:
        -: 1395:            --  The new items were effectively appended to the container, so we
        -: 1396:            --  have already copied all of the items that need to be copied.
        -: 1397:            --  We return early here, even though the source slice below is
        -: 1398:            --  empty (so the assignment would be harmless), because we want to
        -: 1399:            --  avoid computing J + 1, which will overflow if J equals
        -: 1400:            --  Index_Type'Base'Last.
        -: 1401:
    #####: 1402:            return;
        -: 1403:         end if;
        -: 1404:      end;
        -: 1405:
        -: 1406:      declare
        -: 1407:         --  Note that we want to avoid computing J + 1 here, in case J equals
        -: 1408:         --  Index_Type'Base'Last. We prevent that by returning early above,
        -: 1409:         --  immediately after copying the first slice of the source, and
        -: 1410:         --  determining that this second slice of the source is empty.
        -: 1411:
    #####: 1412:         F : constant Index_Type'Base := J + 1;
        -: 1413:
    #####: 1414:         subtype Src_Index_Subtype is Index_Type'Base range
    #####: 1415:           F .. Container.Last;
        -: 1416:
    #####: 1417:         Src : Elements_Array renames
    #####: 1418:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1419:
        -: 1420:         K : Index_Type'Base;
        -: 1421:
        -: 1422:      begin
        -: 1423:         --  We next copy the source items that follow the space we inserted.
        -: 1424:         --  Index value K is the first index of that portion of the
        -: 1425:         --  destination that receives this slice of the source. (For the
        -: 1426:         --  reasons given above, this slice is guaranteed to be non-empty.)
        -: 1427:
        -: 1428:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1429:            K := F - Index_Type'Base (Src'Length);
        -: 1430:         else
        -: 1431:            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);
        -: 1432:         end if;
        -: 1433:
    #####: 1434:         Container.Elements.EA (K .. J) := Src;
        -: 1435:      end;
        -: 1436:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert_vector.526:
    #####: 1317:   procedure Insert_Vector
        -: 1318:     (Container : in out Vector;
        -: 1319:      Before    : Extended_Index;
        -: 1320:      New_Item  : Vector)
        -: 1321:   is
    #####: 1322:      N : constant Count_Type := Length (New_Item);
        -: 1323:      J : Index_Type'Base;
        -: 1324:
        -: 1325:   begin
        -: 1326:      --  Use Insert_Space to create the "hole" (the destination slice) into
        -: 1327:      --  which we copy the source items.
        -: 1328:
    #####: 1329:      Insert_Space (Container, Before, Count => N);
        -: 1330:
    #####: 1331:      if N = 0 then
        -: 1332:
        -: 1333:         --  There's nothing else to do here (vetting of parameters was
        -: 1334:         --  performed already in Insert_Space), so we simply return.
        -: 1335:
    #####: 1336:         return;
        -: 1337:      end if;
        -: 1338:
        -: 1339:      --  We calculate the last index value of the destination slice using the
        -: 1340:      --  wider of Index_Type'Base and count_Type'Base.
        -: 1341:
        -: 1342:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1343:         J := (Before - 1) + Index_Type'Base (N);
        -: 1344:      else
        -: 1345:         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);
        -: 1346:      end if;
        -: 1347:
    #####: 1348:      if Container'Address /= New_Item'Address then
        -: 1349:
        -: 1350:         --  This is the simple case.  New_Item denotes an object different
        -: 1351:         --  from Container, so there's nothing special we need to do to copy
        -: 1352:         --  the source items to their destination, because all of the source
        -: 1353:         --  items are contiguous.
        -: 1354:
    #####: 1355:         Container.Elements.EA (Before .. J) :=
    #####: 1356:           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);
        -: 1357:
    #####: 1358:         return;
        -: 1359:      end if;
        -: 1360:
        -: 1361:      --  New_Item denotes the same object as Container, so an insertion has
        -: 1362:      --  potentially split the source items. The destination is always the
        -: 1363:      --  range [Before, J], but the source is [Index_Type'First, Before) and
        -: 1364:      --  (J, Container.Last]. We perform the copy in two steps, using each of
        -: 1365:      --  the two slices of the source items.
        -: 1366:
        -: 1367:      declare
    #####: 1368:         L : constant Index_Type'Base := Before - 1;
        -: 1369:
    #####: 1370:         subtype Src_Index_Subtype is Index_Type'Base range
        -: 1371:           Index_Type'First .. L;
        -: 1372:
    #####: 1373:         Src : Elements_Array renames
    #####: 1374:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1375:
        -: 1376:         K : Index_Type'Base;
        -: 1377:
        -: 1378:      begin
        -: 1379:         --  We first copy the source items that precede the space we
        -: 1380:         --  inserted. Index value K is the last index of that portion
        -: 1381:         --  destination that receives this slice of the source. (If Before
        -: 1382:         --  equals Index_Type'First, then this first source slice will be
        -: 1383:         --  empty, which is harmless.)
        -: 1384:
        -: 1385:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1386:            K := L + Index_Type'Base (Src'Length);
        -: 1387:         else
        -: 1388:            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);
        -: 1389:         end if;
        -: 1390:
    #####: 1391:         Container.Elements.EA (Before .. K) := Src;
        -: 1392:
    #####: 1393:         if Src'Length = N then
        -: 1394:
        -: 1395:            --  The new items were effectively appended to the container, so we
        -: 1396:            --  have already copied all of the items that need to be copied.
        -: 1397:            --  We return early here, even though the source slice below is
        -: 1398:            --  empty (so the assignment would be harmless), because we want to
        -: 1399:            --  avoid computing J + 1, which will overflow if J equals
        -: 1400:            --  Index_Type'Base'Last.
        -: 1401:
    #####: 1402:            return;
        -: 1403:         end if;
        -: 1404:      end;
        -: 1405:
        -: 1406:      declare
        -: 1407:         --  Note that we want to avoid computing J + 1 here, in case J equals
        -: 1408:         --  Index_Type'Base'Last. We prevent that by returning early above,
        -: 1409:         --  immediately after copying the first slice of the source, and
        -: 1410:         --  determining that this second slice of the source is empty.
        -: 1411:
    #####: 1412:         F : constant Index_Type'Base := J + 1;
        -: 1413:
    #####: 1414:         subtype Src_Index_Subtype is Index_Type'Base range
    #####: 1415:           F .. Container.Last;
        -: 1416:
    #####: 1417:         Src : Elements_Array renames
    #####: 1418:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1419:
        -: 1420:         K : Index_Type'Base;
        -: 1421:
        -: 1422:      begin
        -: 1423:         --  We next copy the source items that follow the space we inserted.
        -: 1424:         --  Index value K is the first index of that portion of the
        -: 1425:         --  destination that receives this slice of the source. (For the
        -: 1426:         --  reasons given above, this slice is guaranteed to be non-empty.)
        -: 1427:
        -: 1428:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1429:            K := F - Index_Type'Base (Src'Length);
        -: 1430:         else
        -: 1431:            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);
        -: 1432:         end if;
        -: 1433:
    #####: 1434:         Container.Elements.EA (K .. J) := Src;
        -: 1435:      end;
        -: 1436:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert_vector.655:
    #####: 1317:   procedure Insert_Vector
        -: 1318:     (Container : in out Vector;
        -: 1319:      Before    : Extended_Index;
        -: 1320:      New_Item  : Vector)
        -: 1321:   is
    #####: 1322:      N : constant Count_Type := Length (New_Item);
        -: 1323:      J : Index_Type'Base;
        -: 1324:
        -: 1325:   begin
        -: 1326:      --  Use Insert_Space to create the "hole" (the destination slice) into
        -: 1327:      --  which we copy the source items.
        -: 1328:
    #####: 1329:      Insert_Space (Container, Before, Count => N);
        -: 1330:
    #####: 1331:      if N = 0 then
        -: 1332:
        -: 1333:         --  There's nothing else to do here (vetting of parameters was
        -: 1334:         --  performed already in Insert_Space), so we simply return.
        -: 1335:
    #####: 1336:         return;
        -: 1337:      end if;
        -: 1338:
        -: 1339:      --  We calculate the last index value of the destination slice using the
        -: 1340:      --  wider of Index_Type'Base and count_Type'Base.
        -: 1341:
        -: 1342:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1343:         J := (Before - 1) + Index_Type'Base (N);
        -: 1344:      else
        -: 1345:         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);
        -: 1346:      end if;
        -: 1347:
    #####: 1348:      if Container'Address /= New_Item'Address then
        -: 1349:
        -: 1350:         --  This is the simple case.  New_Item denotes an object different
        -: 1351:         --  from Container, so there's nothing special we need to do to copy
        -: 1352:         --  the source items to their destination, because all of the source
        -: 1353:         --  items are contiguous.
        -: 1354:
    #####: 1355:         Container.Elements.EA (Before .. J) :=
    #####: 1356:           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);
        -: 1357:
    #####: 1358:         return;
        -: 1359:      end if;
        -: 1360:
        -: 1361:      --  New_Item denotes the same object as Container, so an insertion has
        -: 1362:      --  potentially split the source items. The destination is always the
        -: 1363:      --  range [Before, J], but the source is [Index_Type'First, Before) and
        -: 1364:      --  (J, Container.Last]. We perform the copy in two steps, using each of
        -: 1365:      --  the two slices of the source items.
        -: 1366:
        -: 1367:      declare
    #####: 1368:         L : constant Index_Type'Base := Before - 1;
        -: 1369:
    #####: 1370:         subtype Src_Index_Subtype is Index_Type'Base range
        -: 1371:           Index_Type'First .. L;
        -: 1372:
    #####: 1373:         Src : Elements_Array renames
    #####: 1374:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1375:
        -: 1376:         K : Index_Type'Base;
        -: 1377:
        -: 1378:      begin
        -: 1379:         --  We first copy the source items that precede the space we
        -: 1380:         --  inserted. Index value K is the last index of that portion
        -: 1381:         --  destination that receives this slice of the source. (If Before
        -: 1382:         --  equals Index_Type'First, then this first source slice will be
        -: 1383:         --  empty, which is harmless.)
        -: 1384:
        -: 1385:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1386:            K := L + Index_Type'Base (Src'Length);
        -: 1387:         else
        -: 1388:            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);
        -: 1389:         end if;
        -: 1390:
    #####: 1391:         Container.Elements.EA (Before .. K) := Src;
        -: 1392:
    #####: 1393:         if Src'Length = N then
        -: 1394:
        -: 1395:            --  The new items were effectively appended to the container, so we
        -: 1396:            --  have already copied all of the items that need to be copied.
        -: 1397:            --  We return early here, even though the source slice below is
        -: 1398:            --  empty (so the assignment would be harmless), because we want to
        -: 1399:            --  avoid computing J + 1, which will overflow if J equals
        -: 1400:            --  Index_Type'Base'Last.
        -: 1401:
    #####: 1402:            return;
        -: 1403:         end if;
        -: 1404:      end;
        -: 1405:
        -: 1406:      declare
        -: 1407:         --  Note that we want to avoid computing J + 1 here, in case J equals
        -: 1408:         --  Index_Type'Base'Last. We prevent that by returning early above,
        -: 1409:         --  immediately after copying the first slice of the source, and
        -: 1410:         --  determining that this second slice of the source is empty.
        -: 1411:
    #####: 1412:         F : constant Index_Type'Base := J + 1;
        -: 1413:
    #####: 1414:         subtype Src_Index_Subtype is Index_Type'Base range
    #####: 1415:           F .. Container.Last;
        -: 1416:
    #####: 1417:         Src : Elements_Array renames
    #####: 1418:                 Container.Elements.EA (Src_Index_Subtype);
        -: 1419:
        -: 1420:         K : Index_Type'Base;
        -: 1421:
        -: 1422:      begin
        -: 1423:         --  We next copy the source items that follow the space we inserted.
        -: 1424:         --  Index value K is the first index of that portion of the
        -: 1425:         --  destination that receives this slice of the source. (For the
        -: 1426:         --  reasons given above, this slice is guaranteed to be non-empty.)
        -: 1427:
        -: 1428:         if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1429:            K := F - Index_Type'Base (Src'Length);
        -: 1430:         else
        -: 1431:            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);
        -: 1432:         end if;
        -: 1433:
    #####: 1434:         Container.Elements.EA (K .. J) := Src;
        -: 1435:      end;
        -: 1436:   end Insert_Vector;
------------------
        -: 1437:
    #####: 1438:   procedure Insert_Vector
        -: 1439:     (Container : in out Vector;
        -: 1440:      Before    : Cursor;
        -: 1441:      New_Item  : Vector)
        -: 1442:   is
        -: 1443:      Index : Index_Type'Base;
        -: 1444:
        -: 1445:   begin
    #####: 1446:      if Checks and then Before.Container /= null
    #####: 1447:        and then Before.Container /= Container'Unrestricted_Access
        -: 1448:      then
    #####: 1449:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1450:      end if;
        -: 1451:
    #####: 1452:      if Is_Empty (New_Item) then
    #####: 1453:         return;
        -: 1454:      end if;
        -: 1455:
    #####: 1456:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1457:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1458:            raise Constraint_Error with
        -: 1459:              "vector is already at its maximum length";
        -: 1460:         end if;
        -: 1461:
    #####: 1462:         Index := Container.Last + 1;
        -: 1463:
        -: 1464:      else
    #####: 1465:         Index := Before.Index;
        -: 1466:      end if;
        -: 1467:
    #####: 1468:      Insert_Vector (Container, Index, New_Item);
        -: 1469:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert_vector__2.166:
    #####: 1438:   procedure Insert_Vector
        -: 1439:     (Container : in out Vector;
        -: 1440:      Before    : Cursor;
        -: 1441:      New_Item  : Vector)
        -: 1442:   is
        -: 1443:      Index : Index_Type'Base;
        -: 1444:
        -: 1445:   begin
    #####: 1446:      if Checks and then Before.Container /= null
    #####: 1447:        and then Before.Container /= Container'Unrestricted_Access
        -: 1448:      then
    #####: 1449:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1450:      end if;
        -: 1451:
    #####: 1452:      if Is_Empty (New_Item) then
    #####: 1453:         return;
        -: 1454:      end if;
        -: 1455:
    #####: 1456:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1457:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1458:            raise Constraint_Error with
        -: 1459:              "vector is already at its maximum length";
        -: 1460:         end if;
        -: 1461:
    #####: 1462:         Index := Container.Last + 1;
        -: 1463:
        -: 1464:      else
    #####: 1465:         Index := Before.Index;
        -: 1466:      end if;
        -: 1467:
    #####: 1468:      Insert_Vector (Container, Index, New_Item);
        -: 1469:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert_vector__2.295:
    #####: 1438:   procedure Insert_Vector
        -: 1439:     (Container : in out Vector;
        -: 1440:      Before    : Cursor;
        -: 1441:      New_Item  : Vector)
        -: 1442:   is
        -: 1443:      Index : Index_Type'Base;
        -: 1444:
        -: 1445:   begin
    #####: 1446:      if Checks and then Before.Container /= null
    #####: 1447:        and then Before.Container /= Container'Unrestricted_Access
        -: 1448:      then
    #####: 1449:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1450:      end if;
        -: 1451:
    #####: 1452:      if Is_Empty (New_Item) then
    #####: 1453:         return;
        -: 1454:      end if;
        -: 1455:
    #####: 1456:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1457:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1458:            raise Constraint_Error with
        -: 1459:              "vector is already at its maximum length";
        -: 1460:         end if;
        -: 1461:
    #####: 1462:         Index := Container.Last + 1;
        -: 1463:
        -: 1464:      else
    #####: 1465:         Index := Before.Index;
        -: 1466:      end if;
        -: 1467:
    #####: 1468:      Insert_Vector (Container, Index, New_Item);
        -: 1469:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert_vector__2.525:
    #####: 1438:   procedure Insert_Vector
        -: 1439:     (Container : in out Vector;
        -: 1440:      Before    : Cursor;
        -: 1441:      New_Item  : Vector)
        -: 1442:   is
        -: 1443:      Index : Index_Type'Base;
        -: 1444:
        -: 1445:   begin
    #####: 1446:      if Checks and then Before.Container /= null
    #####: 1447:        and then Before.Container /= Container'Unrestricted_Access
        -: 1448:      then
    #####: 1449:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1450:      end if;
        -: 1451:
    #####: 1452:      if Is_Empty (New_Item) then
    #####: 1453:         return;
        -: 1454:      end if;
        -: 1455:
    #####: 1456:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1457:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1458:            raise Constraint_Error with
        -: 1459:              "vector is already at its maximum length";
        -: 1460:         end if;
        -: 1461:
    #####: 1462:         Index := Container.Last + 1;
        -: 1463:
        -: 1464:      else
    #####: 1465:         Index := Before.Index;
        -: 1466:      end if;
        -: 1467:
    #####: 1468:      Insert_Vector (Container, Index, New_Item);
        -: 1469:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert_vector__2.654:
    #####: 1438:   procedure Insert_Vector
        -: 1439:     (Container : in out Vector;
        -: 1440:      Before    : Cursor;
        -: 1441:      New_Item  : Vector)
        -: 1442:   is
        -: 1443:      Index : Index_Type'Base;
        -: 1444:
        -: 1445:   begin
    #####: 1446:      if Checks and then Before.Container /= null
    #####: 1447:        and then Before.Container /= Container'Unrestricted_Access
        -: 1448:      then
    #####: 1449:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1450:      end if;
        -: 1451:
    #####: 1452:      if Is_Empty (New_Item) then
    #####: 1453:         return;
        -: 1454:      end if;
        -: 1455:
    #####: 1456:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1457:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1458:            raise Constraint_Error with
        -: 1459:              "vector is already at its maximum length";
        -: 1460:         end if;
        -: 1461:
    #####: 1462:         Index := Container.Last + 1;
        -: 1463:
        -: 1464:      else
    #####: 1465:         Index := Before.Index;
        -: 1466:      end if;
        -: 1467:
    #####: 1468:      Insert_Vector (Container, Index, New_Item);
        -: 1469:   end Insert_Vector;
------------------
        -: 1470:
    #####: 1471:   procedure Insert_Vector
        -: 1472:     (Container : in out Vector;
        -: 1473:      Before    : Cursor;
        -: 1474:      New_Item  : Vector;
        -: 1475:      Position  : out Cursor)
        -: 1476:   is
        -: 1477:      Index : Index_Type'Base;
        -: 1478:
        -: 1479:   begin
    #####: 1480:      if Checks and then Before.Container /= null
    #####: 1481:        and then Before.Container /= Container'Unrestricted_Access
        -: 1482:      then
    #####: 1483:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1484:      end if;
        -: 1485:
    #####: 1486:      if Is_Empty (New_Item) then
    #####: 1487:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1488:            Position := No_Element;
        -: 1489:         else
    #####: 1490:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1491:         end if;
        -: 1492:
    #####: 1493:         return;
        -: 1494:      end if;
        -: 1495:
    #####: 1496:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1497:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1498:            raise Constraint_Error with
        -: 1499:              "vector is already at its maximum length";
        -: 1500:         end if;
        -: 1501:
    #####: 1502:         Index := Container.Last + 1;
        -: 1503:
        -: 1504:      else
    #####: 1505:         Index := Before.Index;
        -: 1506:      end if;
        -: 1507:
    #####: 1508:      Insert_Vector (Container, Index, New_Item);
        -: 1509:
    #####: 1510:      Position := (Container'Unrestricted_Access, Index);
    #####: 1511:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert_vector__3.165:
    #####: 1471:   procedure Insert_Vector
        -: 1472:     (Container : in out Vector;
        -: 1473:      Before    : Cursor;
        -: 1474:      New_Item  : Vector;
        -: 1475:      Position  : out Cursor)
        -: 1476:   is
        -: 1477:      Index : Index_Type'Base;
        -: 1478:
        -: 1479:   begin
    #####: 1480:      if Checks and then Before.Container /= null
    #####: 1481:        and then Before.Container /= Container'Unrestricted_Access
        -: 1482:      then
    #####: 1483:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1484:      end if;
        -: 1485:
    #####: 1486:      if Is_Empty (New_Item) then
    #####: 1487:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1488:            Position := No_Element;
        -: 1489:         else
    #####: 1490:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1491:         end if;
        -: 1492:
    #####: 1493:         return;
        -: 1494:      end if;
        -: 1495:
    #####: 1496:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1497:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1498:            raise Constraint_Error with
        -: 1499:              "vector is already at its maximum length";
        -: 1500:         end if;
        -: 1501:
    #####: 1502:         Index := Container.Last + 1;
        -: 1503:
        -: 1504:      else
    #####: 1505:         Index := Before.Index;
        -: 1506:      end if;
        -: 1507:
    #####: 1508:      Insert_Vector (Container, Index, New_Item);
        -: 1509:
    #####: 1510:      Position := (Container'Unrestricted_Access, Index);
    #####: 1511:   end Insert_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert_vector__3.294:
    #####: 1471:   procedure Insert_Vector
        -: 1472:     (Container : in out Vector;
        -: 1473:      Before    : Cursor;
        -: 1474:      New_Item  : Vector;
        -: 1475:      Position  : out Cursor)
        -: 1476:   is
        -: 1477:      Index : Index_Type'Base;
        -: 1478:
        -: 1479:   begin
    #####: 1480:      if Checks and then Before.Container /= null
    #####: 1481:        and then Before.Container /= Container'Unrestricted_Access
        -: 1482:      then
    #####: 1483:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1484:      end if;
        -: 1485:
    #####: 1486:      if Is_Empty (New_Item) then
    #####: 1487:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1488:            Position := No_Element;
        -: 1489:         else
    #####: 1490:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1491:         end if;
        -: 1492:
    #####: 1493:         return;
        -: 1494:      end if;
        -: 1495:
    #####: 1496:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1497:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1498:            raise Constraint_Error with
        -: 1499:              "vector is already at its maximum length";
        -: 1500:         end if;
        -: 1501:
    #####: 1502:         Index := Container.Last + 1;
        -: 1503:
        -: 1504:      else
    #####: 1505:         Index := Before.Index;
        -: 1506:      end if;
        -: 1507:
    #####: 1508:      Insert_Vector (Container, Index, New_Item);
        -: 1509:
    #####: 1510:      Position := (Container'Unrestricted_Access, Index);
    #####: 1511:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert_vector__3.524:
    #####: 1471:   procedure Insert_Vector
        -: 1472:     (Container : in out Vector;
        -: 1473:      Before    : Cursor;
        -: 1474:      New_Item  : Vector;
        -: 1475:      Position  : out Cursor)
        -: 1476:   is
        -: 1477:      Index : Index_Type'Base;
        -: 1478:
        -: 1479:   begin
    #####: 1480:      if Checks and then Before.Container /= null
    #####: 1481:        and then Before.Container /= Container'Unrestricted_Access
        -: 1482:      then
    #####: 1483:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1484:      end if;
        -: 1485:
    #####: 1486:      if Is_Empty (New_Item) then
    #####: 1487:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1488:            Position := No_Element;
        -: 1489:         else
    #####: 1490:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1491:         end if;
        -: 1492:
    #####: 1493:         return;
        -: 1494:      end if;
        -: 1495:
    #####: 1496:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1497:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1498:            raise Constraint_Error with
        -: 1499:              "vector is already at its maximum length";
        -: 1500:         end if;
        -: 1501:
    #####: 1502:         Index := Container.Last + 1;
        -: 1503:
        -: 1504:      else
    #####: 1505:         Index := Before.Index;
        -: 1506:      end if;
        -: 1507:
    #####: 1508:      Insert_Vector (Container, Index, New_Item);
        -: 1509:
    #####: 1510:      Position := (Container'Unrestricted_Access, Index);
    #####: 1511:   end Insert_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert_vector__3.653:
    #####: 1471:   procedure Insert_Vector
        -: 1472:     (Container : in out Vector;
        -: 1473:      Before    : Cursor;
        -: 1474:      New_Item  : Vector;
        -: 1475:      Position  : out Cursor)
        -: 1476:   is
        -: 1477:      Index : Index_Type'Base;
        -: 1478:
        -: 1479:   begin
    #####: 1480:      if Checks and then Before.Container /= null
    #####: 1481:        and then Before.Container /= Container'Unrestricted_Access
        -: 1482:      then
    #####: 1483:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1484:      end if;
        -: 1485:
    #####: 1486:      if Is_Empty (New_Item) then
    #####: 1487:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1488:            Position := No_Element;
        -: 1489:         else
    #####: 1490:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1491:         end if;
        -: 1492:
    #####: 1493:         return;
        -: 1494:      end if;
        -: 1495:
    #####: 1496:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1497:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1498:            raise Constraint_Error with
        -: 1499:              "vector is already at its maximum length";
        -: 1500:         end if;
        -: 1501:
    #####: 1502:         Index := Container.Last + 1;
        -: 1503:
        -: 1504:      else
    #####: 1505:         Index := Before.Index;
        -: 1506:      end if;
        -: 1507:
    #####: 1508:      Insert_Vector (Container, Index, New_Item);
        -: 1509:
    #####: 1510:      Position := (Container'Unrestricted_Access, Index);
    #####: 1511:   end Insert_Vector;
------------------
        -: 1512:
    #####: 1513:   procedure Insert
        -: 1514:     (Container : in out Vector;
        -: 1515:      Before    : Cursor;
        -: 1516:      New_Item  : Element_Type;
        -: 1517:      Count     : Count_Type := 1)
        -: 1518:   is
        -: 1519:      Index : Index_Type'Base;
        -: 1520:
        -: 1521:   begin
    #####: 1522:      if Checks and then Before.Container /= null
    #####: 1523:        and then Before.Container /= Container'Unrestricted_Access
        -: 1524:      then
    #####: 1525:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1526:      end if;
        -: 1527:
    #####: 1528:      if Count = 0 then
    #####: 1529:         return;
        -: 1530:      end if;
        -: 1531:
    #####: 1532:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1533:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1534:            raise Constraint_Error with
        -: 1535:              "vector is already at its maximum length";
        -: 1536:         else
    #####: 1537:            Index := Container.Last + 1;
        -: 1538:         end if;
        -: 1539:
        -: 1540:      else
    #####: 1541:         Index := Before.Index;
        -: 1542:      end if;
        -: 1543:
    #####: 1544:      Insert (Container, Index, New_Item, Count);
        -: 1545:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert__5.164:
    #####: 1513:   procedure Insert
        -: 1514:     (Container : in out Vector;
        -: 1515:      Before    : Cursor;
        -: 1516:      New_Item  : Element_Type;
        -: 1517:      Count     : Count_Type := 1)
        -: 1518:   is
        -: 1519:      Index : Index_Type'Base;
        -: 1520:
        -: 1521:   begin
    #####: 1522:      if Checks and then Before.Container /= null
    #####: 1523:        and then Before.Container /= Container'Unrestricted_Access
        -: 1524:      then
    #####: 1525:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1526:      end if;
        -: 1527:
    #####: 1528:      if Count = 0 then
    #####: 1529:         return;
        -: 1530:      end if;
        -: 1531:
    #####: 1532:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1533:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1534:            raise Constraint_Error with
        -: 1535:              "vector is already at its maximum length";
        -: 1536:         else
    #####: 1537:            Index := Container.Last + 1;
        -: 1538:         end if;
        -: 1539:
        -: 1540:      else
    #####: 1541:         Index := Before.Index;
        -: 1542:      end if;
        -: 1543:
    #####: 1544:      Insert (Container, Index, New_Item, Count);
        -: 1545:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert__5.293:
    #####: 1513:   procedure Insert
        -: 1514:     (Container : in out Vector;
        -: 1515:      Before    : Cursor;
        -: 1516:      New_Item  : Element_Type;
        -: 1517:      Count     : Count_Type := 1)
        -: 1518:   is
        -: 1519:      Index : Index_Type'Base;
        -: 1520:
        -: 1521:   begin
    #####: 1522:      if Checks and then Before.Container /= null
    #####: 1523:        and then Before.Container /= Container'Unrestricted_Access
        -: 1524:      then
    #####: 1525:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1526:      end if;
        -: 1527:
    #####: 1528:      if Count = 0 then
    #####: 1529:         return;
        -: 1530:      end if;
        -: 1531:
    #####: 1532:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1533:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1534:            raise Constraint_Error with
        -: 1535:              "vector is already at its maximum length";
        -: 1536:         else
    #####: 1537:            Index := Container.Last + 1;
        -: 1538:         end if;
        -: 1539:
        -: 1540:      else
    #####: 1541:         Index := Before.Index;
        -: 1542:      end if;
        -: 1543:
    #####: 1544:      Insert (Container, Index, New_Item, Count);
        -: 1545:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert__5.523:
    #####: 1513:   procedure Insert
        -: 1514:     (Container : in out Vector;
        -: 1515:      Before    : Cursor;
        -: 1516:      New_Item  : Element_Type;
        -: 1517:      Count     : Count_Type := 1)
        -: 1518:   is
        -: 1519:      Index : Index_Type'Base;
        -: 1520:
        -: 1521:   begin
    #####: 1522:      if Checks and then Before.Container /= null
    #####: 1523:        and then Before.Container /= Container'Unrestricted_Access
        -: 1524:      then
    #####: 1525:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1526:      end if;
        -: 1527:
    #####: 1528:      if Count = 0 then
    #####: 1529:         return;
        -: 1530:      end if;
        -: 1531:
    #####: 1532:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1533:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1534:            raise Constraint_Error with
        -: 1535:              "vector is already at its maximum length";
        -: 1536:         else
    #####: 1537:            Index := Container.Last + 1;
        -: 1538:         end if;
        -: 1539:
        -: 1540:      else
    #####: 1541:         Index := Before.Index;
        -: 1542:      end if;
        -: 1543:
    #####: 1544:      Insert (Container, Index, New_Item, Count);
        -: 1545:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert__5.652:
    #####: 1513:   procedure Insert
        -: 1514:     (Container : in out Vector;
        -: 1515:      Before    : Cursor;
        -: 1516:      New_Item  : Element_Type;
        -: 1517:      Count     : Count_Type := 1)
        -: 1518:   is
        -: 1519:      Index : Index_Type'Base;
        -: 1520:
        -: 1521:   begin
    #####: 1522:      if Checks and then Before.Container /= null
    #####: 1523:        and then Before.Container /= Container'Unrestricted_Access
        -: 1524:      then
    #####: 1525:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1526:      end if;
        -: 1527:
    #####: 1528:      if Count = 0 then
    #####: 1529:         return;
        -: 1530:      end if;
        -: 1531:
    #####: 1532:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1533:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1534:            raise Constraint_Error with
        -: 1535:              "vector is already at its maximum length";
        -: 1536:         else
    #####: 1537:            Index := Container.Last + 1;
        -: 1538:         end if;
        -: 1539:
        -: 1540:      else
    #####: 1541:         Index := Before.Index;
        -: 1542:      end if;
        -: 1543:
    #####: 1544:      Insert (Container, Index, New_Item, Count);
        -: 1545:   end Insert;
------------------
        -: 1546:
    #####: 1547:   procedure Insert
        -: 1548:     (Container : in out Vector;
        -: 1549:      Before    : Cursor;
        -: 1550:      New_Item  : Element_Type;
        -: 1551:      Position  : out Cursor;
        -: 1552:      Count     : Count_Type := 1)
        -: 1553:   is
        -: 1554:      Index : Index_Type'Base;
        -: 1555:
        -: 1556:   begin
    #####: 1557:      if Checks and then Before.Container /= null
    #####: 1558:        and then Before.Container /= Container'Unrestricted_Access
        -: 1559:      then
    #####: 1560:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1561:      end if;
        -: 1562:
    #####: 1563:      if Count = 0 then
    #####: 1564:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1565:            Position := No_Element;
        -: 1566:         else
    #####: 1567:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1568:         end if;
        -: 1569:
    #####: 1570:         return;
        -: 1571:      end if;
        -: 1572:
    #####: 1573:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1574:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1575:            raise Constraint_Error with
        -: 1576:              "vector is already at its maximum length";
        -: 1577:         end if;
        -: 1578:
    #####: 1579:         Index := Container.Last + 1;
        -: 1580:
        -: 1581:      else
    #####: 1582:         Index := Before.Index;
        -: 1583:      end if;
        -: 1584:
    #####: 1585:      Insert (Container, Index, New_Item, Count);
        -: 1586:
    #####: 1587:      Position := (Container'Unrestricted_Access, Index);
    #####: 1588:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert__6.163:
    #####: 1547:   procedure Insert
        -: 1548:     (Container : in out Vector;
        -: 1549:      Before    : Cursor;
        -: 1550:      New_Item  : Element_Type;
        -: 1551:      Position  : out Cursor;
        -: 1552:      Count     : Count_Type := 1)
        -: 1553:   is
        -: 1554:      Index : Index_Type'Base;
        -: 1555:
        -: 1556:   begin
    #####: 1557:      if Checks and then Before.Container /= null
    #####: 1558:        and then Before.Container /= Container'Unrestricted_Access
        -: 1559:      then
    #####: 1560:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1561:      end if;
        -: 1562:
    #####: 1563:      if Count = 0 then
    #####: 1564:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1565:            Position := No_Element;
        -: 1566:         else
    #####: 1567:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1568:         end if;
        -: 1569:
    #####: 1570:         return;
        -: 1571:      end if;
        -: 1572:
    #####: 1573:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1574:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1575:            raise Constraint_Error with
        -: 1576:              "vector is already at its maximum length";
        -: 1577:         end if;
        -: 1578:
    #####: 1579:         Index := Container.Last + 1;
        -: 1580:
        -: 1581:      else
    #####: 1582:         Index := Before.Index;
        -: 1583:      end if;
        -: 1584:
    #####: 1585:      Insert (Container, Index, New_Item, Count);
        -: 1586:
    #####: 1587:      Position := (Container'Unrestricted_Access, Index);
    #####: 1588:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert__6.292:
    #####: 1547:   procedure Insert
        -: 1548:     (Container : in out Vector;
        -: 1549:      Before    : Cursor;
        -: 1550:      New_Item  : Element_Type;
        -: 1551:      Position  : out Cursor;
        -: 1552:      Count     : Count_Type := 1)
        -: 1553:   is
        -: 1554:      Index : Index_Type'Base;
        -: 1555:
        -: 1556:   begin
    #####: 1557:      if Checks and then Before.Container /= null
    #####: 1558:        and then Before.Container /= Container'Unrestricted_Access
        -: 1559:      then
    #####: 1560:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1561:      end if;
        -: 1562:
    #####: 1563:      if Count = 0 then
    #####: 1564:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1565:            Position := No_Element;
        -: 1566:         else
    #####: 1567:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1568:         end if;
        -: 1569:
    #####: 1570:         return;
        -: 1571:      end if;
        -: 1572:
    #####: 1573:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1574:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1575:            raise Constraint_Error with
        -: 1576:              "vector is already at its maximum length";
        -: 1577:         end if;
        -: 1578:
    #####: 1579:         Index := Container.Last + 1;
        -: 1580:
        -: 1581:      else
    #####: 1582:         Index := Before.Index;
        -: 1583:      end if;
        -: 1584:
    #####: 1585:      Insert (Container, Index, New_Item, Count);
        -: 1586:
    #####: 1587:      Position := (Container'Unrestricted_Access, Index);
    #####: 1588:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert__6.522:
    #####: 1547:   procedure Insert
        -: 1548:     (Container : in out Vector;
        -: 1549:      Before    : Cursor;
        -: 1550:      New_Item  : Element_Type;
        -: 1551:      Position  : out Cursor;
        -: 1552:      Count     : Count_Type := 1)
        -: 1553:   is
        -: 1554:      Index : Index_Type'Base;
        -: 1555:
        -: 1556:   begin
    #####: 1557:      if Checks and then Before.Container /= null
    #####: 1558:        and then Before.Container /= Container'Unrestricted_Access
        -: 1559:      then
    #####: 1560:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1561:      end if;
        -: 1562:
    #####: 1563:      if Count = 0 then
    #####: 1564:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1565:            Position := No_Element;
        -: 1566:         else
    #####: 1567:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1568:         end if;
        -: 1569:
    #####: 1570:         return;
        -: 1571:      end if;
        -: 1572:
    #####: 1573:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1574:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1575:            raise Constraint_Error with
        -: 1576:              "vector is already at its maximum length";
        -: 1577:         end if;
        -: 1578:
    #####: 1579:         Index := Container.Last + 1;
        -: 1580:
        -: 1581:      else
    #####: 1582:         Index := Before.Index;
        -: 1583:      end if;
        -: 1584:
    #####: 1585:      Insert (Container, Index, New_Item, Count);
        -: 1586:
    #####: 1587:      Position := (Container'Unrestricted_Access, Index);
    #####: 1588:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert__6.651:
    #####: 1547:   procedure Insert
        -: 1548:     (Container : in out Vector;
        -: 1549:      Before    : Cursor;
        -: 1550:      New_Item  : Element_Type;
        -: 1551:      Position  : out Cursor;
        -: 1552:      Count     : Count_Type := 1)
        -: 1553:   is
        -: 1554:      Index : Index_Type'Base;
        -: 1555:
        -: 1556:   begin
    #####: 1557:      if Checks and then Before.Container /= null
    #####: 1558:        and then Before.Container /= Container'Unrestricted_Access
        -: 1559:      then
    #####: 1560:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1561:      end if;
        -: 1562:
    #####: 1563:      if Count = 0 then
    #####: 1564:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1565:            Position := No_Element;
        -: 1566:         else
    #####: 1567:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1568:         end if;
        -: 1569:
    #####: 1570:         return;
        -: 1571:      end if;
        -: 1572:
    #####: 1573:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1574:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1575:            raise Constraint_Error with
        -: 1576:              "vector is already at its maximum length";
        -: 1577:         end if;
        -: 1578:
    #####: 1579:         Index := Container.Last + 1;
        -: 1580:
        -: 1581:      else
    #####: 1582:         Index := Before.Index;
        -: 1583:      end if;
        -: 1584:
    #####: 1585:      Insert (Container, Index, New_Item, Count);
        -: 1586:
    #####: 1587:      Position := (Container'Unrestricted_Access, Index);
    #####: 1588:   end Insert;
------------------
        -: 1589:
    #####: 1590:   procedure Insert
        -: 1591:     (Container : in out Vector;
        -: 1592:      Before    : Extended_Index;
        -: 1593:      Count     : Count_Type := 1)
        -: 1594:   is
    #####: 1595:      New_Item : Element_Type;  -- Default-initialized value
        -: 1596:      pragma Warnings (Off, New_Item);
        -: 1597:
        -: 1598:   begin
    #####: 1599:      Insert (Container, Before, New_Item, Count);
    #####: 1600:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert__7.162:
    #####: 1590:   procedure Insert
        -: 1591:     (Container : in out Vector;
        -: 1592:      Before    : Extended_Index;
        -: 1593:      Count     : Count_Type := 1)
        -: 1594:   is
        -: 1595:      New_Item : Element_Type;  -- Default-initialized value
        -: 1596:      pragma Warnings (Off, New_Item);
        -: 1597:
        -: 1598:   begin
    #####: 1599:      Insert (Container, Before, New_Item, Count);
    #####: 1600:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert__7.291:
    #####: 1590:   procedure Insert
        -: 1591:     (Container : in out Vector;
        -: 1592:      Before    : Extended_Index;
        -: 1593:      Count     : Count_Type := 1)
        -: 1594:   is
    #####: 1595:      New_Item : Element_Type;  -- Default-initialized value
        -: 1596:      pragma Warnings (Off, New_Item);
        -: 1597:
        -: 1598:   begin
    #####: 1599:      Insert (Container, Before, New_Item, Count);
    #####: 1600:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert__7.521:
    #####: 1590:   procedure Insert
        -: 1591:     (Container : in out Vector;
        -: 1592:      Before    : Extended_Index;
        -: 1593:      Count     : Count_Type := 1)
        -: 1594:   is
        -: 1595:      New_Item : Element_Type;  -- Default-initialized value
        -: 1596:      pragma Warnings (Off, New_Item);
        -: 1597:
        -: 1598:   begin
    #####: 1599:      Insert (Container, Before, New_Item, Count);
    #####: 1600:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert__7.650:
    #####: 1590:   procedure Insert
        -: 1591:     (Container : in out Vector;
        -: 1592:      Before    : Extended_Index;
        -: 1593:      Count     : Count_Type := 1)
        -: 1594:   is
    #####: 1595:      New_Item : Element_Type;  -- Default-initialized value
        -: 1596:      pragma Warnings (Off, New_Item);
        -: 1597:
        -: 1598:   begin
    #####: 1599:      Insert (Container, Before, New_Item, Count);
    #####: 1600:   end Insert;
------------------
        -: 1601:
    #####: 1602:   procedure Insert
        -: 1603:     (Container : in out Vector;
        -: 1604:      Before    : Cursor;
        -: 1605:      Position  : out Cursor;
        -: 1606:      Count     : Count_Type := 1)
        -: 1607:   is
    #####: 1608:      New_Item : Element_Type;  -- Default-initialized value
        -: 1609:      pragma Warnings (Off, New_Item);
        -: 1610:   begin
    #####: 1611:      Insert (Container, Before, New_Item, Position, Count);
    #####: 1612:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert__8.161:
    #####: 1602:   procedure Insert
        -: 1603:     (Container : in out Vector;
        -: 1604:      Before    : Cursor;
        -: 1605:      Position  : out Cursor;
        -: 1606:      Count     : Count_Type := 1)
        -: 1607:   is
        -: 1608:      New_Item : Element_Type;  -- Default-initialized value
        -: 1609:      pragma Warnings (Off, New_Item);
        -: 1610:   begin
    #####: 1611:      Insert (Container, Before, New_Item, Position, Count);
    #####: 1612:   end Insert;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert__8.290:
    #####: 1602:   procedure Insert
        -: 1603:     (Container : in out Vector;
        -: 1604:      Before    : Cursor;
        -: 1605:      Position  : out Cursor;
        -: 1606:      Count     : Count_Type := 1)
        -: 1607:   is
    #####: 1608:      New_Item : Element_Type;  -- Default-initialized value
        -: 1609:      pragma Warnings (Off, New_Item);
        -: 1610:   begin
    #####: 1611:      Insert (Container, Before, New_Item, Position, Count);
    #####: 1612:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert__8.520:
    #####: 1602:   procedure Insert
        -: 1603:     (Container : in out Vector;
        -: 1604:      Before    : Cursor;
        -: 1605:      Position  : out Cursor;
        -: 1606:      Count     : Count_Type := 1)
        -: 1607:   is
        -: 1608:      New_Item : Element_Type;  -- Default-initialized value
        -: 1609:      pragma Warnings (Off, New_Item);
        -: 1610:   begin
    #####: 1611:      Insert (Container, Before, New_Item, Position, Count);
    #####: 1612:   end Insert;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert__8.649:
    #####: 1602:   procedure Insert
        -: 1603:     (Container : in out Vector;
        -: 1604:      Before    : Cursor;
        -: 1605:      Position  : out Cursor;
        -: 1606:      Count     : Count_Type := 1)
        -: 1607:   is
    #####: 1608:      New_Item : Element_Type;  -- Default-initialized value
        -: 1609:      pragma Warnings (Off, New_Item);
        -: 1610:   begin
    #####: 1611:      Insert (Container, Before, New_Item, Position, Count);
    #####: 1612:   end Insert;
------------------
        -: 1613:
        -: 1614:   ------------------
        -: 1615:   -- Insert_Space --
        -: 1616:   ------------------
        -: 1617:
    #####: 1618:   procedure Insert_Space
        -: 1619:     (Container : in out Vector;
        -: 1620:      Before    : Extended_Index;
        -: 1621:      Count     : Count_Type := 1)
        -: 1622:   is
    #####: 1623:      Old_Length : constant Count_Type := Container.Length;
        -: 1624:
        -: 1625:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -: 1626:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -: 1627:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -: 1628:
        -: 1629:      Index : Index_Type'Base;  -- scratch for intermediate values
        -: 1630:      J     : Count_Type'Base;  -- scratch
        -: 1631:
        -: 1632:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -: 1633:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####: 1634:      Dst          : Elements_Access;  -- new, expanded internal array
        -: 1635:
        -: 1636:   begin
        -: 1637:      --  The tampering bits exist to prevent an item from being harmfully
        -: 1638:      --  manipulated while it is being visited. Query, Update, and Iterate
        -: 1639:      --  increment the busy count on entry, and decrement the count on
        -: 1640:      --  exit. Insert checks the count to determine whether it is being called
        -: 1641:      --  while the associated callback procedure is executing.
        -: 1642:
    #####: 1643:      TC_Check (Container.TC);
        -: 1644:
        -: 1645:      if Checks then
        -: 1646:         --  As a precondition on the generic actual Index_Type, the base type
        -: 1647:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -: 1648:         --  that Container.Last assumes when the vector is empty. However, we
        -: 1649:         --  do not allow that as the value for Index when specifying where the
        -: 1650:         --  new items should be inserted, so we must manually check. (That the
        -: 1651:         --  user is allowed to specify the value at all here is a consequence
        -: 1652:         --  of the declaration of the Extended_Index subtype, which includes
        -: 1653:         --  the values in the base range that immediately precede and
        -: 1654:         --  immediately follow the values in the Index_Type.)
        -: 1655:
    #####: 1656:         if Before < Index_Type'First then
    #####: 1657:            raise Constraint_Error with
        -: 1658:              "Before index is out of range (too small)";
        -: 1659:         end if;
        -: 1660:
        -: 1661:         --  We do allow a value greater than Container.Last to be specified as
        -: 1662:         --  the Index, but only if it's immediately greater. This allows for
        -: 1663:         --  the case of appending items to the back end of the vector. (It is
        -: 1664:         --  assumed that specifying an index value greater than Last + 1
        -: 1665:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1666:         --  is treated as a proper error.)
        -: 1667:
    #####: 1668:         if Before > Container.Last + 1 then
    #####: 1669:            raise Constraint_Error with
        -: 1670:              "Before index is out of range (too large)";
        -: 1671:         end if;
        -: 1672:      end if;
        -: 1673:
        -: 1674:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1675:      --  the container is busy, so we simply return.
        -: 1676:
    #####: 1677:      if Count = 0 then
    #####: 1678:         return;
        -: 1679:      end if;
        -: 1680:
        -: 1681:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1682:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1683:      --  we must check the sum of the current length and the insertion count.
        -: 1684:      --  Note: we cannot simply add these values, because of the possibility
        -: 1685:      --  of overflow.
        -: 1686:
    #####: 1687:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1688:         raise Constraint_Error with "Count is out of range";
        -: 1689:      end if;
        -: 1690:
        -: 1691:      --  It is now safe compute the length of the new vector, without fear of
        -: 1692:      --  overflow.
        -: 1693:
    #####: 1694:      New_Length := Old_Length + Count;
        -: 1695:
        -: 1696:      --  The second constraint is that the new Last index value cannot exceed
        -: 1697:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1698:      --  length (computed from the range of values in Index_Type), and then
        -: 1699:      --  compare the new length to the maximum length. If the new length is
        -: 1700:      --  acceptable, then we compute the new last index from that.
        -: 1701:
        -: 1702:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1703:         --  We have to handle the case when there might be more values in the
        -: 1704:         --  range of Index_Type than in the range of Count_Type.
        -: 1705:
        -: 1706:         if Index_Type'First <= 0 then
        -: 1707:
        -: 1708:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1709:            --  less than 0, so it is safe to compute the following sum without
        -: 1710:            --  fear of overflow. We need to suppress warnings, because
        -: 1711:            --  otherwise we get an error in -gnatwE mode.
        -: 1712:
        -: 1713:            pragma Warnings (Off);
    #####: 1714:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1715:            pragma Warnings (On);
        -: 1716:
        -: 1717:            if Index <= Index_Type'Last then
        -: 1718:
        -: 1719:               --  We have determined that range of Index_Type has at least as
        -: 1720:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1721:               --  maximum number of items that are allowed.
        -: 1722:
    #####: 1723:               Max_Length := Count_Type'Last;
        -: 1724:
        -: 1725:            else
        -: 1726:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1727:               --  so the maximum number of items is computed from the range of
        -: 1728:               --  the Index_Type.
        -: 1729:
        -: 1730:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1731:            end if;
        -: 1732:
        -: 1733:         else
        -: 1734:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1735:            --  the difference without fear of overflow (which we would have to
        -: 1736:            --  worry about if No_Index were less than 0, but that case is
        -: 1737:            --  handled above).
        -: 1738:
        -: 1739:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1740:               --  We have determined that range of Index_Type has at least as
        -: 1741:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1742:               --  maximum number of items that are allowed.
        -: 1743:
        -: 1744:               Max_Length := Count_Type'Last;
        -: 1745:
        -: 1746:            else
        -: 1747:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1748:               --  so the maximum number of items is computed from the range of
        -: 1749:               --  the Index_Type.
        -: 1750:
        -: 1751:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1752:            end if;
        -: 1753:         end if;
        -: 1754:
        -: 1755:      elsif Index_Type'First <= 0 then
        -: 1756:
        -: 1757:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1758:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1759:         --  overflow.
        -: 1760:
        -: 1761:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1762:
        -: 1763:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1764:
        -: 1765:            --  We have determined that range of Index_Type has at least as
        -: 1766:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1767:            --  number of items that are allowed.
        -: 1768:
        -: 1769:            Max_Length := Count_Type'Last;
        -: 1770:
        -: 1771:         else
        -: 1772:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1773:            --  so the maximum number of items is computed from the range of
        -: 1774:            --  the Index_Type.
        -: 1775:
        -: 1776:            Max_Length :=
        -: 1777:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1778:         end if;
        -: 1779:
        -: 1780:      else
        -: 1781:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1782:         --  difference without fear of overflow (which we would have to worry
        -: 1783:         --  about if No_Index were less than 0, but that case is handled
        -: 1784:         --  above).
        -: 1785:
        -: 1786:         Max_Length :=
        -: 1787:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1788:      end if;
        -: 1789:
        -: 1790:      --  We have just computed the maximum length (number of items). We must
        -: 1791:      --  now compare the requested length to the maximum length, as we do not
        -: 1792:      --  allow a vector expand beyond the maximum (because that would create
        -: 1793:      --  an internal array with a last index value greater than
        -: 1794:      --  Index_Type'Last, with no way to index those elements).
        -: 1795:
    #####: 1796:      if Checks and then New_Length > Max_Length then
    #####: 1797:         raise Constraint_Error with "Count is out of range";
        -: 1798:      end if;
        -: 1799:
        -: 1800:      --  New_Last is the last index value of the items in the container after
        -: 1801:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1802:      --  compute its value from the New_Length.
        -: 1803:
        -: 1804:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1805:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1806:      else
        -: 1807:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1808:      end if;
        -: 1809:
    #####: 1810:      if Container.Elements = null then
    #####: 1811:         pragma Assert (Container.Last = No_Index);
        -: 1812:
        -: 1813:         --  This is the simplest case, with which we must always begin: we're
        -: 1814:         --  inserting items into an empty vector that hasn't allocated an
        -: 1815:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1816:         --  here, because an empty container cannot be busy.
        -: 1817:
        -: 1818:         --  In order to preserve container invariants, we allocate the new
        -: 1819:         --  internal array first, before setting the Last index value, in case
        -: 1820:         --  the allocation fails (which can happen either because there is no
        -: 1821:         --  storage available, or because default-valued element
        -: 1822:         --  initialization fails).
        -: 1823:
    #####: 1824:         Container.Elements := new Elements_Type (New_Last);
        -: 1825:
        -: 1826:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1827:         --  safe to update the Last index, restoring container invariants.
        -: 1828:
    #####: 1829:         Container.Last := New_Last;
        -: 1830:
    #####: 1831:         return;
        -: 1832:      end if;
        -: 1833:
        -: 1834:      --  An internal array has already been allocated, so we must determine
        -: 1835:      --  whether there is enough unused storage for the new items.
        -: 1836:
    #####: 1837:      if New_Last <= Container.Elements.Last then
        -: 1838:
        -: 1839:         --  In this case, we're inserting space into a vector that has already
        -: 1840:         --  allocated an internal array, and the existing array has enough
        -: 1841:         --  unused storage for the new items.
        -: 1842:
        -: 1843:         declare
    #####: 1844:            EA : Elements_Array renames Container.Elements.EA;
        -: 1845:
        -: 1846:         begin
    #####: 1847:            if Before <= Container.Last then
        -: 1848:
        -: 1849:               --  The space is being inserted before some existing elements,
        -: 1850:               --  so we must slide the existing elements up to their new
        -: 1851:               --  home. We use the wider of Index_Type'Base and
        -: 1852:               --  Count_Type'Base as the type for intermediate index values.
        -: 1853:
        -: 1854:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1855:                  Index := Before + Index_Type'Base (Count);
        -: 1856:
        -: 1857:               else
        -: 1858:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1859:               end if;
        -: 1860:
    #####: 1861:               EA (Index .. New_Last) := EA (Before .. Container.Last);
        -: 1862:            end if;
        -: 1863:         end;
        -: 1864:
    #####: 1865:         Container.Last := New_Last;
    #####: 1866:         return;
        -: 1867:      end if;
        -: 1868:
        -: 1869:      --  In this case, we're inserting space into a vector that has already
        -: 1870:      --  allocated an internal array, but the existing array does not have
        -: 1871:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1872:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1873:      --  allocate an array whose length is some power-of-two factor of the
        -: 1874:      --  current array length. (The new array cannot have a length less than
        -: 1875:      --  the New_Length of the container, but its last index value cannot be
        -: 1876:      --  greater than Index_Type'Last.)
        -: 1877:
    #####: 1878:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1879:      while New_Capacity < New_Length loop
    #####: 1880:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1881:            New_Capacity := Count_Type'Last;
    #####: 1882:            exit;
        -: 1883:         end if;
        -: 1884:
    #####: 1885:         New_Capacity := 2 * New_Capacity;
    #####: 1886:      end loop;
        -: 1887:
    #####: 1888:      if New_Capacity > Max_Length then
        -: 1889:
        -: 1890:         --  We have reached the limit of capacity, so no further expansion
        -: 1891:         --  will occur. (This is not a problem, as there is never a need to
        -: 1892:         --  have more capacity than the maximum container length.)
        -: 1893:
    #####: 1894:         New_Capacity := Max_Length;
        -: 1895:      end if;
        -: 1896:
        -: 1897:      --  We have computed the length of the new internal array (and this is
        -: 1898:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1899:
        -: 1900:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1901:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1902:      else
        -: 1903:         Dst_Last :=
        -: 1904:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1905:      end if;
        -: 1906:
        -: 1907:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1908:      --  fails, we have not changed any container state, so no side-effect
        -: 1909:      --  will occur as a result of propagating the exception.
        -: 1910:
    #####: 1911:      Dst := new Elements_Type (Dst_Last);
        -: 1912:
        -: 1913:      --  We have our new internal array. All that needs to be done now is to
        -: 1914:      --  copy the existing items (if any) from the old array (the "source"
        -: 1915:      --  array, object SA below) to the new array (the "destination" array,
        -: 1916:      --  object DA below), and then deallocate the old array.
        -: 1917:
        -: 1918:      declare
    #####: 1919:         SA : Elements_Array renames Container.Elements.EA;  -- source
    #####: 1920:         DA : Elements_Array renames Dst.EA;                 -- destination
        -: 1921:
        -: 1922:      begin
    #####: 1923:         DA (Index_Type'First .. Before - 1) :=
    #####: 1924:           SA (Index_Type'First .. Before - 1);
        -: 1925:
    #####: 1926:         if Before <= Container.Last then
        -: 1927:
        -: 1928:            --  The space is being inserted before some existing elements, so
        -: 1929:            --  we must slide the existing elements up to their new home.
        -: 1930:
        -: 1931:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1932:               Index := Before + Index_Type'Base (Count);
        -: 1933:            else
        -: 1934:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1935:            end if;
        -: 1936:
    #####: 1937:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1938:         end if;
        -: 1939:
        -: 1940:      exception
    =====: 1941:         when others =>
    =====: 1942:            Free (Dst);
    =====: 1943:            raise;
        -: 1944:      end;
        -: 1945:
        -: 1946:      --  We have successfully copied the items onto the new array, so the
        -: 1947:      --  final thing to do is restore invariants, and deallocate the old
        -: 1948:      --  array.
        -: 1949:
        -: 1950:      declare
    #####: 1951:         X : Elements_Access := Container.Elements;
        -: 1952:
        -: 1953:      begin
        -: 1954:         --  We first isolate the old internal array, removing it from the
        -: 1955:         --  container and replacing it with the new internal array, before we
        -: 1956:         --  deallocate the old array (which can fail if finalization of
        -: 1957:         --  elements propagates an exception).
        -: 1958:
    #####: 1959:         Container.Elements := Dst;
    #####: 1960:         Container.Last := New_Last;
        -: 1961:
        -: 1962:         --  The container invariants have been restored, so it is now safe to
        -: 1963:         --  attempt to deallocate the old array.
        -: 1964:
    #####: 1965:         Free (X);
        -: 1966:      end;
        -: 1967:   end Insert_Space;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert_space.160:
    #####: 1618:   procedure Insert_Space
        -: 1619:     (Container : in out Vector;
        -: 1620:      Before    : Extended_Index;
        -: 1621:      Count     : Count_Type := 1)
        -: 1622:   is
    #####: 1623:      Old_Length : constant Count_Type := Container.Length;
        -: 1624:
        -: 1625:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -: 1626:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -: 1627:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -: 1628:
        -: 1629:      Index : Index_Type'Base;  -- scratch for intermediate values
        -: 1630:      J     : Count_Type'Base;  -- scratch
        -: 1631:
        -: 1632:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -: 1633:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####: 1634:      Dst          : Elements_Access;  -- new, expanded internal array
        -: 1635:
        -: 1636:   begin
        -: 1637:      --  The tampering bits exist to prevent an item from being harmfully
        -: 1638:      --  manipulated while it is being visited. Query, Update, and Iterate
        -: 1639:      --  increment the busy count on entry, and decrement the count on
        -: 1640:      --  exit. Insert checks the count to determine whether it is being called
        -: 1641:      --  while the associated callback procedure is executing.
        -: 1642:
    #####: 1643:      TC_Check (Container.TC);
        -: 1644:
        -: 1645:      if Checks then
        -: 1646:         --  As a precondition on the generic actual Index_Type, the base type
        -: 1647:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -: 1648:         --  that Container.Last assumes when the vector is empty. However, we
        -: 1649:         --  do not allow that as the value for Index when specifying where the
        -: 1650:         --  new items should be inserted, so we must manually check. (That the
        -: 1651:         --  user is allowed to specify the value at all here is a consequence
        -: 1652:         --  of the declaration of the Extended_Index subtype, which includes
        -: 1653:         --  the values in the base range that immediately precede and
        -: 1654:         --  immediately follow the values in the Index_Type.)
        -: 1655:
    #####: 1656:         if Before < Index_Type'First then
    #####: 1657:            raise Constraint_Error with
        -: 1658:              "Before index is out of range (too small)";
        -: 1659:         end if;
        -: 1660:
        -: 1661:         --  We do allow a value greater than Container.Last to be specified as
        -: 1662:         --  the Index, but only if it's immediately greater. This allows for
        -: 1663:         --  the case of appending items to the back end of the vector. (It is
        -: 1664:         --  assumed that specifying an index value greater than Last + 1
        -: 1665:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1666:         --  is treated as a proper error.)
        -: 1667:
    #####: 1668:         if Before > Container.Last + 1 then
    #####: 1669:            raise Constraint_Error with
        -: 1670:              "Before index is out of range (too large)";
        -: 1671:         end if;
        -: 1672:      end if;
        -: 1673:
        -: 1674:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1675:      --  the container is busy, so we simply return.
        -: 1676:
    #####: 1677:      if Count = 0 then
    #####: 1678:         return;
        -: 1679:      end if;
        -: 1680:
        -: 1681:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1682:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1683:      --  we must check the sum of the current length and the insertion count.
        -: 1684:      --  Note: we cannot simply add these values, because of the possibility
        -: 1685:      --  of overflow.
        -: 1686:
    #####: 1687:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1688:         raise Constraint_Error with "Count is out of range";
        -: 1689:      end if;
        -: 1690:
        -: 1691:      --  It is now safe compute the length of the new vector, without fear of
        -: 1692:      --  overflow.
        -: 1693:
    #####: 1694:      New_Length := Old_Length + Count;
        -: 1695:
        -: 1696:      --  The second constraint is that the new Last index value cannot exceed
        -: 1697:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1698:      --  length (computed from the range of values in Index_Type), and then
        -: 1699:      --  compare the new length to the maximum length. If the new length is
        -: 1700:      --  acceptable, then we compute the new last index from that.
        -: 1701:
        -: 1702:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1703:         --  We have to handle the case when there might be more values in the
        -: 1704:         --  range of Index_Type than in the range of Count_Type.
        -: 1705:
        -: 1706:         if Index_Type'First <= 0 then
        -: 1707:
        -: 1708:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1709:            --  less than 0, so it is safe to compute the following sum without
        -: 1710:            --  fear of overflow. We need to suppress warnings, because
        -: 1711:            --  otherwise we get an error in -gnatwE mode.
        -: 1712:
        -: 1713:            pragma Warnings (Off);
    #####: 1714:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1715:            pragma Warnings (On);
        -: 1716:
        -: 1717:            if Index <= Index_Type'Last then
        -: 1718:
        -: 1719:               --  We have determined that range of Index_Type has at least as
        -: 1720:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1721:               --  maximum number of items that are allowed.
        -: 1722:
    #####: 1723:               Max_Length := Count_Type'Last;
        -: 1724:
        -: 1725:            else
        -: 1726:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1727:               --  so the maximum number of items is computed from the range of
        -: 1728:               --  the Index_Type.
        -: 1729:
        -: 1730:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1731:            end if;
        -: 1732:
        -: 1733:         else
        -: 1734:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1735:            --  the difference without fear of overflow (which we would have to
        -: 1736:            --  worry about if No_Index were less than 0, but that case is
        -: 1737:            --  handled above).
        -: 1738:
        -: 1739:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1740:               --  We have determined that range of Index_Type has at least as
        -: 1741:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1742:               --  maximum number of items that are allowed.
        -: 1743:
        -: 1744:               Max_Length := Count_Type'Last;
        -: 1745:
        -: 1746:            else
        -: 1747:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1748:               --  so the maximum number of items is computed from the range of
        -: 1749:               --  the Index_Type.
        -: 1750:
        -: 1751:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1752:            end if;
        -: 1753:         end if;
        -: 1754:
        -: 1755:      elsif Index_Type'First <= 0 then
        -: 1756:
        -: 1757:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1758:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1759:         --  overflow.
        -: 1760:
        -: 1761:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1762:
        -: 1763:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1764:
        -: 1765:            --  We have determined that range of Index_Type has at least as
        -: 1766:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1767:            --  number of items that are allowed.
        -: 1768:
        -: 1769:            Max_Length := Count_Type'Last;
        -: 1770:
        -: 1771:         else
        -: 1772:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1773:            --  so the maximum number of items is computed from the range of
        -: 1774:            --  the Index_Type.
        -: 1775:
        -: 1776:            Max_Length :=
        -: 1777:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1778:         end if;
        -: 1779:
        -: 1780:      else
        -: 1781:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1782:         --  difference without fear of overflow (which we would have to worry
        -: 1783:         --  about if No_Index were less than 0, but that case is handled
        -: 1784:         --  above).
        -: 1785:
        -: 1786:         Max_Length :=
        -: 1787:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1788:      end if;
        -: 1789:
        -: 1790:      --  We have just computed the maximum length (number of items). We must
        -: 1791:      --  now compare the requested length to the maximum length, as we do not
        -: 1792:      --  allow a vector expand beyond the maximum (because that would create
        -: 1793:      --  an internal array with a last index value greater than
        -: 1794:      --  Index_Type'Last, with no way to index those elements).
        -: 1795:
    #####: 1796:      if Checks and then New_Length > Max_Length then
    #####: 1797:         raise Constraint_Error with "Count is out of range";
        -: 1798:      end if;
        -: 1799:
        -: 1800:      --  New_Last is the last index value of the items in the container after
        -: 1801:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1802:      --  compute its value from the New_Length.
        -: 1803:
        -: 1804:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1805:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1806:      else
        -: 1807:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1808:      end if;
        -: 1809:
    #####: 1810:      if Container.Elements = null then
    #####: 1811:         pragma Assert (Container.Last = No_Index);
        -: 1812:
        -: 1813:         --  This is the simplest case, with which we must always begin: we're
        -: 1814:         --  inserting items into an empty vector that hasn't allocated an
        -: 1815:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1816:         --  here, because an empty container cannot be busy.
        -: 1817:
        -: 1818:         --  In order to preserve container invariants, we allocate the new
        -: 1819:         --  internal array first, before setting the Last index value, in case
        -: 1820:         --  the allocation fails (which can happen either because there is no
        -: 1821:         --  storage available, or because default-valued element
        -: 1822:         --  initialization fails).
        -: 1823:
    #####: 1824:         Container.Elements := new Elements_Type (New_Last);
        -: 1825:
        -: 1826:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1827:         --  safe to update the Last index, restoring container invariants.
        -: 1828:
    #####: 1829:         Container.Last := New_Last;
        -: 1830:
    #####: 1831:         return;
        -: 1832:      end if;
        -: 1833:
        -: 1834:      --  An internal array has already been allocated, so we must determine
        -: 1835:      --  whether there is enough unused storage for the new items.
        -: 1836:
    #####: 1837:      if New_Last <= Container.Elements.Last then
        -: 1838:
        -: 1839:         --  In this case, we're inserting space into a vector that has already
        -: 1840:         --  allocated an internal array, and the existing array has enough
        -: 1841:         --  unused storage for the new items.
        -: 1842:
        -: 1843:         declare
    #####: 1844:            EA : Elements_Array renames Container.Elements.EA;
        -: 1845:
        -: 1846:         begin
    #####: 1847:            if Before <= Container.Last then
        -: 1848:
        -: 1849:               --  The space is being inserted before some existing elements,
        -: 1850:               --  so we must slide the existing elements up to their new
        -: 1851:               --  home. We use the wider of Index_Type'Base and
        -: 1852:               --  Count_Type'Base as the type for intermediate index values.
        -: 1853:
        -: 1854:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1855:                  Index := Before + Index_Type'Base (Count);
        -: 1856:
        -: 1857:               else
        -: 1858:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1859:               end if;
        -: 1860:
    #####: 1861:               EA (Index .. New_Last) := EA (Before .. Container.Last);
        -: 1862:            end if;
        -: 1863:         end;
        -: 1864:
    #####: 1865:         Container.Last := New_Last;
    #####: 1866:         return;
        -: 1867:      end if;
        -: 1868:
        -: 1869:      --  In this case, we're inserting space into a vector that has already
        -: 1870:      --  allocated an internal array, but the existing array does not have
        -: 1871:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1872:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1873:      --  allocate an array whose length is some power-of-two factor of the
        -: 1874:      --  current array length. (The new array cannot have a length less than
        -: 1875:      --  the New_Length of the container, but its last index value cannot be
        -: 1876:      --  greater than Index_Type'Last.)
        -: 1877:
    #####: 1878:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1879:      while New_Capacity < New_Length loop
    #####: 1880:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1881:            New_Capacity := Count_Type'Last;
    #####: 1882:            exit;
        -: 1883:         end if;
        -: 1884:
    #####: 1885:         New_Capacity := 2 * New_Capacity;
    #####: 1886:      end loop;
        -: 1887:
    #####: 1888:      if New_Capacity > Max_Length then
        -: 1889:
        -: 1890:         --  We have reached the limit of capacity, so no further expansion
        -: 1891:         --  will occur. (This is not a problem, as there is never a need to
        -: 1892:         --  have more capacity than the maximum container length.)
        -: 1893:
    #####: 1894:         New_Capacity := Max_Length;
        -: 1895:      end if;
        -: 1896:
        -: 1897:      --  We have computed the length of the new internal array (and this is
        -: 1898:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1899:
        -: 1900:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1901:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1902:      else
        -: 1903:         Dst_Last :=
        -: 1904:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1905:      end if;
        -: 1906:
        -: 1907:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1908:      --  fails, we have not changed any container state, so no side-effect
        -: 1909:      --  will occur as a result of propagating the exception.
        -: 1910:
    #####: 1911:      Dst := new Elements_Type (Dst_Last);
        -: 1912:
        -: 1913:      --  We have our new internal array. All that needs to be done now is to
        -: 1914:      --  copy the existing items (if any) from the old array (the "source"
        -: 1915:      --  array, object SA below) to the new array (the "destination" array,
        -: 1916:      --  object DA below), and then deallocate the old array.
        -: 1917:
        -: 1918:      declare
    #####: 1919:         SA : Elements_Array renames Container.Elements.EA;  -- source
    #####: 1920:         DA : Elements_Array renames Dst.EA;                 -- destination
        -: 1921:
        -: 1922:      begin
    #####: 1923:         DA (Index_Type'First .. Before - 1) :=
    #####: 1924:           SA (Index_Type'First .. Before - 1);
        -: 1925:
    #####: 1926:         if Before <= Container.Last then
        -: 1927:
        -: 1928:            --  The space is being inserted before some existing elements, so
        -: 1929:            --  we must slide the existing elements up to their new home.
        -: 1930:
        -: 1931:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1932:               Index := Before + Index_Type'Base (Count);
        -: 1933:            else
        -: 1934:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1935:            end if;
        -: 1936:
    #####: 1937:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1938:         end if;
        -: 1939:
        -: 1940:      exception
    =====: 1941:         when others =>
    =====: 1942:            Free (Dst);
    =====: 1943:            raise;
        -: 1944:      end;
        -: 1945:
        -: 1946:      --  We have successfully copied the items onto the new array, so the
        -: 1947:      --  final thing to do is restore invariants, and deallocate the old
        -: 1948:      --  array.
        -: 1949:
        -: 1950:      declare
    #####: 1951:         X : Elements_Access := Container.Elements;
        -: 1952:
        -: 1953:      begin
        -: 1954:         --  We first isolate the old internal array, removing it from the
        -: 1955:         --  container and replacing it with the new internal array, before we
        -: 1956:         --  deallocate the old array (which can fail if finalization of
        -: 1957:         --  elements propagates an exception).
        -: 1958:
    #####: 1959:         Container.Elements := Dst;
    #####: 1960:         Container.Last := New_Last;
        -: 1961:
        -: 1962:         --  The container invariants have been restored, so it is now safe to
        -: 1963:         --  attempt to deallocate the old array.
        -: 1964:
    #####: 1965:         Free (X);
        -: 1966:      end;
        -: 1967:   end Insert_Space;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert_space.289:
    #####: 1618:   procedure Insert_Space
        -: 1619:     (Container : in out Vector;
        -: 1620:      Before    : Extended_Index;
        -: 1621:      Count     : Count_Type := 1)
        -: 1622:   is
    #####: 1623:      Old_Length : constant Count_Type := Container.Length;
        -: 1624:
        -: 1625:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -: 1626:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -: 1627:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -: 1628:
        -: 1629:      Index : Index_Type'Base;  -- scratch for intermediate values
        -: 1630:      J     : Count_Type'Base;  -- scratch
        -: 1631:
        -: 1632:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -: 1633:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####: 1634:      Dst          : Elements_Access;  -- new, expanded internal array
        -: 1635:
        -: 1636:   begin
        -: 1637:      --  The tampering bits exist to prevent an item from being harmfully
        -: 1638:      --  manipulated while it is being visited. Query, Update, and Iterate
        -: 1639:      --  increment the busy count on entry, and decrement the count on
        -: 1640:      --  exit. Insert checks the count to determine whether it is being called
        -: 1641:      --  while the associated callback procedure is executing.
        -: 1642:
    #####: 1643:      TC_Check (Container.TC);
        -: 1644:
        -: 1645:      if Checks then
        -: 1646:         --  As a precondition on the generic actual Index_Type, the base type
        -: 1647:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -: 1648:         --  that Container.Last assumes when the vector is empty. However, we
        -: 1649:         --  do not allow that as the value for Index when specifying where the
        -: 1650:         --  new items should be inserted, so we must manually check. (That the
        -: 1651:         --  user is allowed to specify the value at all here is a consequence
        -: 1652:         --  of the declaration of the Extended_Index subtype, which includes
        -: 1653:         --  the values in the base range that immediately precede and
        -: 1654:         --  immediately follow the values in the Index_Type.)
        -: 1655:
    #####: 1656:         if Before < Index_Type'First then
    #####: 1657:            raise Constraint_Error with
        -: 1658:              "Before index is out of range (too small)";
        -: 1659:         end if;
        -: 1660:
        -: 1661:         --  We do allow a value greater than Container.Last to be specified as
        -: 1662:         --  the Index, but only if it's immediately greater. This allows for
        -: 1663:         --  the case of appending items to the back end of the vector. (It is
        -: 1664:         --  assumed that specifying an index value greater than Last + 1
        -: 1665:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1666:         --  is treated as a proper error.)
        -: 1667:
    #####: 1668:         if Before > Container.Last + 1 then
    #####: 1669:            raise Constraint_Error with
        -: 1670:              "Before index is out of range (too large)";
        -: 1671:         end if;
        -: 1672:      end if;
        -: 1673:
        -: 1674:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1675:      --  the container is busy, so we simply return.
        -: 1676:
    #####: 1677:      if Count = 0 then
    #####: 1678:         return;
        -: 1679:      end if;
        -: 1680:
        -: 1681:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1682:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1683:      --  we must check the sum of the current length and the insertion count.
        -: 1684:      --  Note: we cannot simply add these values, because of the possibility
        -: 1685:      --  of overflow.
        -: 1686:
    #####: 1687:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1688:         raise Constraint_Error with "Count is out of range";
        -: 1689:      end if;
        -: 1690:
        -: 1691:      --  It is now safe compute the length of the new vector, without fear of
        -: 1692:      --  overflow.
        -: 1693:
    #####: 1694:      New_Length := Old_Length + Count;
        -: 1695:
        -: 1696:      --  The second constraint is that the new Last index value cannot exceed
        -: 1697:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1698:      --  length (computed from the range of values in Index_Type), and then
        -: 1699:      --  compare the new length to the maximum length. If the new length is
        -: 1700:      --  acceptable, then we compute the new last index from that.
        -: 1701:
        -: 1702:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1703:         --  We have to handle the case when there might be more values in the
        -: 1704:         --  range of Index_Type than in the range of Count_Type.
        -: 1705:
        -: 1706:         if Index_Type'First <= 0 then
        -: 1707:
        -: 1708:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1709:            --  less than 0, so it is safe to compute the following sum without
        -: 1710:            --  fear of overflow. We need to suppress warnings, because
        -: 1711:            --  otherwise we get an error in -gnatwE mode.
        -: 1712:
        -: 1713:            pragma Warnings (Off);
    #####: 1714:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1715:            pragma Warnings (On);
        -: 1716:
        -: 1717:            if Index <= Index_Type'Last then
        -: 1718:
        -: 1719:               --  We have determined that range of Index_Type has at least as
        -: 1720:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1721:               --  maximum number of items that are allowed.
        -: 1722:
    #####: 1723:               Max_Length := Count_Type'Last;
        -: 1724:
        -: 1725:            else
        -: 1726:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1727:               --  so the maximum number of items is computed from the range of
        -: 1728:               --  the Index_Type.
        -: 1729:
        -: 1730:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1731:            end if;
        -: 1732:
        -: 1733:         else
        -: 1734:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1735:            --  the difference without fear of overflow (which we would have to
        -: 1736:            --  worry about if No_Index were less than 0, but that case is
        -: 1737:            --  handled above).
        -: 1738:
        -: 1739:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1740:               --  We have determined that range of Index_Type has at least as
        -: 1741:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1742:               --  maximum number of items that are allowed.
        -: 1743:
        -: 1744:               Max_Length := Count_Type'Last;
        -: 1745:
        -: 1746:            else
        -: 1747:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1748:               --  so the maximum number of items is computed from the range of
        -: 1749:               --  the Index_Type.
        -: 1750:
        -: 1751:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1752:            end if;
        -: 1753:         end if;
        -: 1754:
        -: 1755:      elsif Index_Type'First <= 0 then
        -: 1756:
        -: 1757:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1758:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1759:         --  overflow.
        -: 1760:
        -: 1761:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1762:
        -: 1763:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1764:
        -: 1765:            --  We have determined that range of Index_Type has at least as
        -: 1766:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1767:            --  number of items that are allowed.
        -: 1768:
        -: 1769:            Max_Length := Count_Type'Last;
        -: 1770:
        -: 1771:         else
        -: 1772:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1773:            --  so the maximum number of items is computed from the range of
        -: 1774:            --  the Index_Type.
        -: 1775:
        -: 1776:            Max_Length :=
        -: 1777:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1778:         end if;
        -: 1779:
        -: 1780:      else
        -: 1781:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1782:         --  difference without fear of overflow (which we would have to worry
        -: 1783:         --  about if No_Index were less than 0, but that case is handled
        -: 1784:         --  above).
        -: 1785:
        -: 1786:         Max_Length :=
        -: 1787:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1788:      end if;
        -: 1789:
        -: 1790:      --  We have just computed the maximum length (number of items). We must
        -: 1791:      --  now compare the requested length to the maximum length, as we do not
        -: 1792:      --  allow a vector expand beyond the maximum (because that would create
        -: 1793:      --  an internal array with a last index value greater than
        -: 1794:      --  Index_Type'Last, with no way to index those elements).
        -: 1795:
    #####: 1796:      if Checks and then New_Length > Max_Length then
    #####: 1797:         raise Constraint_Error with "Count is out of range";
        -: 1798:      end if;
        -: 1799:
        -: 1800:      --  New_Last is the last index value of the items in the container after
        -: 1801:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1802:      --  compute its value from the New_Length.
        -: 1803:
        -: 1804:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1805:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1806:      else
        -: 1807:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1808:      end if;
        -: 1809:
    #####: 1810:      if Container.Elements = null then
    #####: 1811:         pragma Assert (Container.Last = No_Index);
        -: 1812:
        -: 1813:         --  This is the simplest case, with which we must always begin: we're
        -: 1814:         --  inserting items into an empty vector that hasn't allocated an
        -: 1815:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1816:         --  here, because an empty container cannot be busy.
        -: 1817:
        -: 1818:         --  In order to preserve container invariants, we allocate the new
        -: 1819:         --  internal array first, before setting the Last index value, in case
        -: 1820:         --  the allocation fails (which can happen either because there is no
        -: 1821:         --  storage available, or because default-valued element
        -: 1822:         --  initialization fails).
        -: 1823:
    #####: 1824:         Container.Elements := new Elements_Type (New_Last);
        -: 1825:
        -: 1826:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1827:         --  safe to update the Last index, restoring container invariants.
        -: 1828:
    #####: 1829:         Container.Last := New_Last;
        -: 1830:
    #####: 1831:         return;
        -: 1832:      end if;
        -: 1833:
        -: 1834:      --  An internal array has already been allocated, so we must determine
        -: 1835:      --  whether there is enough unused storage for the new items.
        -: 1836:
    #####: 1837:      if New_Last <= Container.Elements.Last then
        -: 1838:
        -: 1839:         --  In this case, we're inserting space into a vector that has already
        -: 1840:         --  allocated an internal array, and the existing array has enough
        -: 1841:         --  unused storage for the new items.
        -: 1842:
        -: 1843:         declare
    #####: 1844:            EA : Elements_Array renames Container.Elements.EA;
        -: 1845:
        -: 1846:         begin
    #####: 1847:            if Before <= Container.Last then
        -: 1848:
        -: 1849:               --  The space is being inserted before some existing elements,
        -: 1850:               --  so we must slide the existing elements up to their new
        -: 1851:               --  home. We use the wider of Index_Type'Base and
        -: 1852:               --  Count_Type'Base as the type for intermediate index values.
        -: 1853:
        -: 1854:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1855:                  Index := Before + Index_Type'Base (Count);
        -: 1856:
        -: 1857:               else
        -: 1858:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1859:               end if;
        -: 1860:
    #####: 1861:               EA (Index .. New_Last) := EA (Before .. Container.Last);
        -: 1862:            end if;
        -: 1863:         end;
        -: 1864:
    #####: 1865:         Container.Last := New_Last;
    #####: 1866:         return;
        -: 1867:      end if;
        -: 1868:
        -: 1869:      --  In this case, we're inserting space into a vector that has already
        -: 1870:      --  allocated an internal array, but the existing array does not have
        -: 1871:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1872:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1873:      --  allocate an array whose length is some power-of-two factor of the
        -: 1874:      --  current array length. (The new array cannot have a length less than
        -: 1875:      --  the New_Length of the container, but its last index value cannot be
        -: 1876:      --  greater than Index_Type'Last.)
        -: 1877:
    #####: 1878:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1879:      while New_Capacity < New_Length loop
    #####: 1880:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1881:            New_Capacity := Count_Type'Last;
    #####: 1882:            exit;
        -: 1883:         end if;
        -: 1884:
    #####: 1885:         New_Capacity := 2 * New_Capacity;
    #####: 1886:      end loop;
        -: 1887:
    #####: 1888:      if New_Capacity > Max_Length then
        -: 1889:
        -: 1890:         --  We have reached the limit of capacity, so no further expansion
        -: 1891:         --  will occur. (This is not a problem, as there is never a need to
        -: 1892:         --  have more capacity than the maximum container length.)
        -: 1893:
    #####: 1894:         New_Capacity := Max_Length;
        -: 1895:      end if;
        -: 1896:
        -: 1897:      --  We have computed the length of the new internal array (and this is
        -: 1898:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1899:
        -: 1900:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1901:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1902:      else
        -: 1903:         Dst_Last :=
        -: 1904:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1905:      end if;
        -: 1906:
        -: 1907:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1908:      --  fails, we have not changed any container state, so no side-effect
        -: 1909:      --  will occur as a result of propagating the exception.
        -: 1910:
    #####: 1911:      Dst := new Elements_Type (Dst_Last);
        -: 1912:
        -: 1913:      --  We have our new internal array. All that needs to be done now is to
        -: 1914:      --  copy the existing items (if any) from the old array (the "source"
        -: 1915:      --  array, object SA below) to the new array (the "destination" array,
        -: 1916:      --  object DA below), and then deallocate the old array.
        -: 1917:
        -: 1918:      declare
    #####: 1919:         SA : Elements_Array renames Container.Elements.EA;  -- source
    #####: 1920:         DA : Elements_Array renames Dst.EA;                 -- destination
        -: 1921:
        -: 1922:      begin
    #####: 1923:         DA (Index_Type'First .. Before - 1) :=
    #####: 1924:           SA (Index_Type'First .. Before - 1);
        -: 1925:
    #####: 1926:         if Before <= Container.Last then
        -: 1927:
        -: 1928:            --  The space is being inserted before some existing elements, so
        -: 1929:            --  we must slide the existing elements up to their new home.
        -: 1930:
        -: 1931:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1932:               Index := Before + Index_Type'Base (Count);
        -: 1933:            else
        -: 1934:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1935:            end if;
        -: 1936:
    #####: 1937:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1938:         end if;
        -: 1939:
        -: 1940:      exception
    =====: 1941:         when others =>
    =====: 1942:            Free (Dst);
    =====: 1943:            raise;
        -: 1944:      end;
        -: 1945:
        -: 1946:      --  We have successfully copied the items onto the new array, so the
        -: 1947:      --  final thing to do is restore invariants, and deallocate the old
        -: 1948:      --  array.
        -: 1949:
        -: 1950:      declare
    #####: 1951:         X : Elements_Access := Container.Elements;
        -: 1952:
        -: 1953:      begin
        -: 1954:         --  We first isolate the old internal array, removing it from the
        -: 1955:         --  container and replacing it with the new internal array, before we
        -: 1956:         --  deallocate the old array (which can fail if finalization of
        -: 1957:         --  elements propagates an exception).
        -: 1958:
    #####: 1959:         Container.Elements := Dst;
    #####: 1960:         Container.Last := New_Last;
        -: 1961:
        -: 1962:         --  The container invariants have been restored, so it is now safe to
        -: 1963:         --  attempt to deallocate the old array.
        -: 1964:
    #####: 1965:         Free (X);
        -: 1966:      end;
        -: 1967:   end Insert_Space;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert_space.519:
    #####: 1618:   procedure Insert_Space
        -: 1619:     (Container : in out Vector;
        -: 1620:      Before    : Extended_Index;
        -: 1621:      Count     : Count_Type := 1)
        -: 1622:   is
    #####: 1623:      Old_Length : constant Count_Type := Container.Length;
        -: 1624:
        -: 1625:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -: 1626:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -: 1627:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -: 1628:
        -: 1629:      Index : Index_Type'Base;  -- scratch for intermediate values
        -: 1630:      J     : Count_Type'Base;  -- scratch
        -: 1631:
        -: 1632:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -: 1633:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####: 1634:      Dst          : Elements_Access;  -- new, expanded internal array
        -: 1635:
        -: 1636:   begin
        -: 1637:      --  The tampering bits exist to prevent an item from being harmfully
        -: 1638:      --  manipulated while it is being visited. Query, Update, and Iterate
        -: 1639:      --  increment the busy count on entry, and decrement the count on
        -: 1640:      --  exit. Insert checks the count to determine whether it is being called
        -: 1641:      --  while the associated callback procedure is executing.
        -: 1642:
    #####: 1643:      TC_Check (Container.TC);
        -: 1644:
        -: 1645:      if Checks then
        -: 1646:         --  As a precondition on the generic actual Index_Type, the base type
        -: 1647:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -: 1648:         --  that Container.Last assumes when the vector is empty. However, we
        -: 1649:         --  do not allow that as the value for Index when specifying where the
        -: 1650:         --  new items should be inserted, so we must manually check. (That the
        -: 1651:         --  user is allowed to specify the value at all here is a consequence
        -: 1652:         --  of the declaration of the Extended_Index subtype, which includes
        -: 1653:         --  the values in the base range that immediately precede and
        -: 1654:         --  immediately follow the values in the Index_Type.)
        -: 1655:
    #####: 1656:         if Before < Index_Type'First then
    #####: 1657:            raise Constraint_Error with
        -: 1658:              "Before index is out of range (too small)";
        -: 1659:         end if;
        -: 1660:
        -: 1661:         --  We do allow a value greater than Container.Last to be specified as
        -: 1662:         --  the Index, but only if it's immediately greater. This allows for
        -: 1663:         --  the case of appending items to the back end of the vector. (It is
        -: 1664:         --  assumed that specifying an index value greater than Last + 1
        -: 1665:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1666:         --  is treated as a proper error.)
        -: 1667:
    #####: 1668:         if Before > Container.Last + 1 then
    #####: 1669:            raise Constraint_Error with
        -: 1670:              "Before index is out of range (too large)";
        -: 1671:         end if;
        -: 1672:      end if;
        -: 1673:
        -: 1674:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1675:      --  the container is busy, so we simply return.
        -: 1676:
    #####: 1677:      if Count = 0 then
    #####: 1678:         return;
        -: 1679:      end if;
        -: 1680:
        -: 1681:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1682:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1683:      --  we must check the sum of the current length and the insertion count.
        -: 1684:      --  Note: we cannot simply add these values, because of the possibility
        -: 1685:      --  of overflow.
        -: 1686:
    #####: 1687:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1688:         raise Constraint_Error with "Count is out of range";
        -: 1689:      end if;
        -: 1690:
        -: 1691:      --  It is now safe compute the length of the new vector, without fear of
        -: 1692:      --  overflow.
        -: 1693:
    #####: 1694:      New_Length := Old_Length + Count;
        -: 1695:
        -: 1696:      --  The second constraint is that the new Last index value cannot exceed
        -: 1697:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1698:      --  length (computed from the range of values in Index_Type), and then
        -: 1699:      --  compare the new length to the maximum length. If the new length is
        -: 1700:      --  acceptable, then we compute the new last index from that.
        -: 1701:
        -: 1702:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1703:         --  We have to handle the case when there might be more values in the
        -: 1704:         --  range of Index_Type than in the range of Count_Type.
        -: 1705:
        -: 1706:         if Index_Type'First <= 0 then
        -: 1707:
        -: 1708:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1709:            --  less than 0, so it is safe to compute the following sum without
        -: 1710:            --  fear of overflow. We need to suppress warnings, because
        -: 1711:            --  otherwise we get an error in -gnatwE mode.
        -: 1712:
        -: 1713:            pragma Warnings (Off);
    #####: 1714:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1715:            pragma Warnings (On);
        -: 1716:
        -: 1717:            if Index <= Index_Type'Last then
        -: 1718:
        -: 1719:               --  We have determined that range of Index_Type has at least as
        -: 1720:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1721:               --  maximum number of items that are allowed.
        -: 1722:
    #####: 1723:               Max_Length := Count_Type'Last;
        -: 1724:
        -: 1725:            else
        -: 1726:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1727:               --  so the maximum number of items is computed from the range of
        -: 1728:               --  the Index_Type.
        -: 1729:
        -: 1730:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1731:            end if;
        -: 1732:
        -: 1733:         else
        -: 1734:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1735:            --  the difference without fear of overflow (which we would have to
        -: 1736:            --  worry about if No_Index were less than 0, but that case is
        -: 1737:            --  handled above).
        -: 1738:
        -: 1739:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1740:               --  We have determined that range of Index_Type has at least as
        -: 1741:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1742:               --  maximum number of items that are allowed.
        -: 1743:
        -: 1744:               Max_Length := Count_Type'Last;
        -: 1745:
        -: 1746:            else
        -: 1747:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1748:               --  so the maximum number of items is computed from the range of
        -: 1749:               --  the Index_Type.
        -: 1750:
        -: 1751:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1752:            end if;
        -: 1753:         end if;
        -: 1754:
        -: 1755:      elsif Index_Type'First <= 0 then
        -: 1756:
        -: 1757:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1758:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1759:         --  overflow.
        -: 1760:
        -: 1761:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1762:
        -: 1763:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1764:
        -: 1765:            --  We have determined that range of Index_Type has at least as
        -: 1766:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1767:            --  number of items that are allowed.
        -: 1768:
        -: 1769:            Max_Length := Count_Type'Last;
        -: 1770:
        -: 1771:         else
        -: 1772:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1773:            --  so the maximum number of items is computed from the range of
        -: 1774:            --  the Index_Type.
        -: 1775:
        -: 1776:            Max_Length :=
        -: 1777:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1778:         end if;
        -: 1779:
        -: 1780:      else
        -: 1781:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1782:         --  difference without fear of overflow (which we would have to worry
        -: 1783:         --  about if No_Index were less than 0, but that case is handled
        -: 1784:         --  above).
        -: 1785:
        -: 1786:         Max_Length :=
        -: 1787:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1788:      end if;
        -: 1789:
        -: 1790:      --  We have just computed the maximum length (number of items). We must
        -: 1791:      --  now compare the requested length to the maximum length, as we do not
        -: 1792:      --  allow a vector expand beyond the maximum (because that would create
        -: 1793:      --  an internal array with a last index value greater than
        -: 1794:      --  Index_Type'Last, with no way to index those elements).
        -: 1795:
    #####: 1796:      if Checks and then New_Length > Max_Length then
    #####: 1797:         raise Constraint_Error with "Count is out of range";
        -: 1798:      end if;
        -: 1799:
        -: 1800:      --  New_Last is the last index value of the items in the container after
        -: 1801:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1802:      --  compute its value from the New_Length.
        -: 1803:
        -: 1804:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1805:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1806:      else
        -: 1807:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1808:      end if;
        -: 1809:
    #####: 1810:      if Container.Elements = null then
    #####: 1811:         pragma Assert (Container.Last = No_Index);
        -: 1812:
        -: 1813:         --  This is the simplest case, with which we must always begin: we're
        -: 1814:         --  inserting items into an empty vector that hasn't allocated an
        -: 1815:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1816:         --  here, because an empty container cannot be busy.
        -: 1817:
        -: 1818:         --  In order to preserve container invariants, we allocate the new
        -: 1819:         --  internal array first, before setting the Last index value, in case
        -: 1820:         --  the allocation fails (which can happen either because there is no
        -: 1821:         --  storage available, or because default-valued element
        -: 1822:         --  initialization fails).
        -: 1823:
    #####: 1824:         Container.Elements := new Elements_Type (New_Last);
        -: 1825:
        -: 1826:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1827:         --  safe to update the Last index, restoring container invariants.
        -: 1828:
    #####: 1829:         Container.Last := New_Last;
        -: 1830:
    #####: 1831:         return;
        -: 1832:      end if;
        -: 1833:
        -: 1834:      --  An internal array has already been allocated, so we must determine
        -: 1835:      --  whether there is enough unused storage for the new items.
        -: 1836:
    #####: 1837:      if New_Last <= Container.Elements.Last then
        -: 1838:
        -: 1839:         --  In this case, we're inserting space into a vector that has already
        -: 1840:         --  allocated an internal array, and the existing array has enough
        -: 1841:         --  unused storage for the new items.
        -: 1842:
        -: 1843:         declare
    #####: 1844:            EA : Elements_Array renames Container.Elements.EA;
        -: 1845:
        -: 1846:         begin
    #####: 1847:            if Before <= Container.Last then
        -: 1848:
        -: 1849:               --  The space is being inserted before some existing elements,
        -: 1850:               --  so we must slide the existing elements up to their new
        -: 1851:               --  home. We use the wider of Index_Type'Base and
        -: 1852:               --  Count_Type'Base as the type for intermediate index values.
        -: 1853:
        -: 1854:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1855:                  Index := Before + Index_Type'Base (Count);
        -: 1856:
        -: 1857:               else
        -: 1858:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1859:               end if;
        -: 1860:
    #####: 1861:               EA (Index .. New_Last) := EA (Before .. Container.Last);
        -: 1862:            end if;
        -: 1863:         end;
        -: 1864:
    #####: 1865:         Container.Last := New_Last;
    #####: 1866:         return;
        -: 1867:      end if;
        -: 1868:
        -: 1869:      --  In this case, we're inserting space into a vector that has already
        -: 1870:      --  allocated an internal array, but the existing array does not have
        -: 1871:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1872:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1873:      --  allocate an array whose length is some power-of-two factor of the
        -: 1874:      --  current array length. (The new array cannot have a length less than
        -: 1875:      --  the New_Length of the container, but its last index value cannot be
        -: 1876:      --  greater than Index_Type'Last.)
        -: 1877:
    #####: 1878:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1879:      while New_Capacity < New_Length loop
    #####: 1880:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1881:            New_Capacity := Count_Type'Last;
    #####: 1882:            exit;
        -: 1883:         end if;
        -: 1884:
    #####: 1885:         New_Capacity := 2 * New_Capacity;
    #####: 1886:      end loop;
        -: 1887:
    #####: 1888:      if New_Capacity > Max_Length then
        -: 1889:
        -: 1890:         --  We have reached the limit of capacity, so no further expansion
        -: 1891:         --  will occur. (This is not a problem, as there is never a need to
        -: 1892:         --  have more capacity than the maximum container length.)
        -: 1893:
    #####: 1894:         New_Capacity := Max_Length;
        -: 1895:      end if;
        -: 1896:
        -: 1897:      --  We have computed the length of the new internal array (and this is
        -: 1898:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1899:
        -: 1900:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1901:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1902:      else
        -: 1903:         Dst_Last :=
        -: 1904:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1905:      end if;
        -: 1906:
        -: 1907:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1908:      --  fails, we have not changed any container state, so no side-effect
        -: 1909:      --  will occur as a result of propagating the exception.
        -: 1910:
    #####: 1911:      Dst := new Elements_Type (Dst_Last);
        -: 1912:
        -: 1913:      --  We have our new internal array. All that needs to be done now is to
        -: 1914:      --  copy the existing items (if any) from the old array (the "source"
        -: 1915:      --  array, object SA below) to the new array (the "destination" array,
        -: 1916:      --  object DA below), and then deallocate the old array.
        -: 1917:
        -: 1918:      declare
    #####: 1919:         SA : Elements_Array renames Container.Elements.EA;  -- source
    #####: 1920:         DA : Elements_Array renames Dst.EA;                 -- destination
        -: 1921:
        -: 1922:      begin
    #####: 1923:         DA (Index_Type'First .. Before - 1) :=
    #####: 1924:           SA (Index_Type'First .. Before - 1);
        -: 1925:
    #####: 1926:         if Before <= Container.Last then
        -: 1927:
        -: 1928:            --  The space is being inserted before some existing elements, so
        -: 1929:            --  we must slide the existing elements up to their new home.
        -: 1930:
        -: 1931:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1932:               Index := Before + Index_Type'Base (Count);
        -: 1933:            else
        -: 1934:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1935:            end if;
        -: 1936:
    #####: 1937:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1938:         end if;
        -: 1939:
        -: 1940:      exception
    =====: 1941:         when others =>
    =====: 1942:            Free (Dst);
    =====: 1943:            raise;
        -: 1944:      end;
        -: 1945:
        -: 1946:      --  We have successfully copied the items onto the new array, so the
        -: 1947:      --  final thing to do is restore invariants, and deallocate the old
        -: 1948:      --  array.
        -: 1949:
        -: 1950:      declare
    #####: 1951:         X : Elements_Access := Container.Elements;
        -: 1952:
        -: 1953:      begin
        -: 1954:         --  We first isolate the old internal array, removing it from the
        -: 1955:         --  container and replacing it with the new internal array, before we
        -: 1956:         --  deallocate the old array (which can fail if finalization of
        -: 1957:         --  elements propagates an exception).
        -: 1958:
    #####: 1959:         Container.Elements := Dst;
    #####: 1960:         Container.Last := New_Last;
        -: 1961:
        -: 1962:         --  The container invariants have been restored, so it is now safe to
        -: 1963:         --  attempt to deallocate the old array.
        -: 1964:
    #####: 1965:         Free (X);
        -: 1966:      end;
        -: 1967:   end Insert_Space;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert_space.648:
    #####: 1618:   procedure Insert_Space
        -: 1619:     (Container : in out Vector;
        -: 1620:      Before    : Extended_Index;
        -: 1621:      Count     : Count_Type := 1)
        -: 1622:   is
    #####: 1623:      Old_Length : constant Count_Type := Container.Length;
        -: 1624:
        -: 1625:      Max_Length : Count_Type'Base;  -- determined from range of Index_Type
        -: 1626:      New_Length : Count_Type'Base;  -- sum of current length and Count
        -: 1627:      New_Last   : Index_Type'Base;  -- last index of vector after insertion
        -: 1628:
        -: 1629:      Index : Index_Type'Base;  -- scratch for intermediate values
        -: 1630:      J     : Count_Type'Base;  -- scratch
        -: 1631:
        -: 1632:      New_Capacity : Count_Type'Base;  -- length of new, expanded array
        -: 1633:      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array
    #####: 1634:      Dst          : Elements_Access;  -- new, expanded internal array
        -: 1635:
        -: 1636:   begin
        -: 1637:      --  The tampering bits exist to prevent an item from being harmfully
        -: 1638:      --  manipulated while it is being visited. Query, Update, and Iterate
        -: 1639:      --  increment the busy count on entry, and decrement the count on
        -: 1640:      --  exit. Insert checks the count to determine whether it is being called
        -: 1641:      --  while the associated callback procedure is executing.
        -: 1642:
    #####: 1643:      TC_Check (Container.TC);
        -: 1644:
        -: 1645:      if Checks then
        -: 1646:         --  As a precondition on the generic actual Index_Type, the base type
        -: 1647:         --  must include Index_Type'Pred (Index_Type'First); this is the value
        -: 1648:         --  that Container.Last assumes when the vector is empty. However, we
        -: 1649:         --  do not allow that as the value for Index when specifying where the
        -: 1650:         --  new items should be inserted, so we must manually check. (That the
        -: 1651:         --  user is allowed to specify the value at all here is a consequence
        -: 1652:         --  of the declaration of the Extended_Index subtype, which includes
        -: 1653:         --  the values in the base range that immediately precede and
        -: 1654:         --  immediately follow the values in the Index_Type.)
        -: 1655:
    #####: 1656:         if Before < Index_Type'First then
    #####: 1657:            raise Constraint_Error with
        -: 1658:              "Before index is out of range (too small)";
        -: 1659:         end if;
        -: 1660:
        -: 1661:         --  We do allow a value greater than Container.Last to be specified as
        -: 1662:         --  the Index, but only if it's immediately greater. This allows for
        -: 1663:         --  the case of appending items to the back end of the vector. (It is
        -: 1664:         --  assumed that specifying an index value greater than Last + 1
        -: 1665:         --  indicates some deeper flaw in the caller's algorithm, so that case
        -: 1666:         --  is treated as a proper error.)
        -: 1667:
    #####: 1668:         if Before > Container.Last + 1 then
    #####: 1669:            raise Constraint_Error with
        -: 1670:              "Before index is out of range (too large)";
        -: 1671:         end if;
        -: 1672:      end if;
        -: 1673:
        -: 1674:      --  We treat inserting 0 items into the container as a no-op, even when
        -: 1675:      --  the container is busy, so we simply return.
        -: 1676:
    #####: 1677:      if Count = 0 then
    #####: 1678:         return;
        -: 1679:      end if;
        -: 1680:
        -: 1681:      --  There are two constraints we need to satisfy. The first constraint is
        -: 1682:      --  that a container cannot have more than Count_Type'Last elements, so
        -: 1683:      --  we must check the sum of the current length and the insertion count.
        -: 1684:      --  Note: we cannot simply add these values, because of the possibility
        -: 1685:      --  of overflow.
        -: 1686:
    #####: 1687:      if Checks and then Old_Length > Count_Type'Last - Count then
    #####: 1688:         raise Constraint_Error with "Count is out of range";
        -: 1689:      end if;
        -: 1690:
        -: 1691:      --  It is now safe compute the length of the new vector, without fear of
        -: 1692:      --  overflow.
        -: 1693:
    #####: 1694:      New_Length := Old_Length + Count;
        -: 1695:
        -: 1696:      --  The second constraint is that the new Last index value cannot exceed
        -: 1697:      --  Index_Type'Last. In each branch below, we calculate the maximum
        -: 1698:      --  length (computed from the range of values in Index_Type), and then
        -: 1699:      --  compare the new length to the maximum length. If the new length is
        -: 1700:      --  acceptable, then we compute the new last index from that.
        -: 1701:
        -: 1702:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 1703:         --  We have to handle the case when there might be more values in the
        -: 1704:         --  range of Index_Type than in the range of Count_Type.
        -: 1705:
        -: 1706:         if Index_Type'First <= 0 then
        -: 1707:
        -: 1708:            --  We know that No_Index (the same as Index_Type'First - 1) is
        -: 1709:            --  less than 0, so it is safe to compute the following sum without
        -: 1710:            --  fear of overflow. We need to suppress warnings, because
        -: 1711:            --  otherwise we get an error in -gnatwE mode.
        -: 1712:
        -: 1713:            pragma Warnings (Off);
    #####: 1714:            Index := No_Index + Index_Type'Base (Count_Type'Last);
        -: 1715:            pragma Warnings (On);
        -: 1716:
        -: 1717:            if Index <= Index_Type'Last then
        -: 1718:
        -: 1719:               --  We have determined that range of Index_Type has at least as
        -: 1720:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1721:               --  maximum number of items that are allowed.
        -: 1722:
    #####: 1723:               Max_Length := Count_Type'Last;
        -: 1724:
        -: 1725:            else
        -: 1726:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1727:               --  so the maximum number of items is computed from the range of
        -: 1728:               --  the Index_Type.
        -: 1729:
        -: 1730:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1731:            end if;
        -: 1732:
        -: 1733:         else
        -: 1734:            --  No_Index is equal or greater than 0, so we can safely compute
        -: 1735:            --  the difference without fear of overflow (which we would have to
        -: 1736:            --  worry about if No_Index were less than 0, but that case is
        -: 1737:            --  handled above).
        -: 1738:
        -: 1739:            if Index_Type'Last - No_Index >= Count_Type_Last then
        -: 1740:               --  We have determined that range of Index_Type has at least as
        -: 1741:               --  many values as in Count_Type, so Count_Type'Last is the
        -: 1742:               --  maximum number of items that are allowed.
        -: 1743:
        -: 1744:               Max_Length := Count_Type'Last;
        -: 1745:
        -: 1746:            else
        -: 1747:               --  The range of Index_Type has fewer values than in Count_Type,
        -: 1748:               --  so the maximum number of items is computed from the range of
        -: 1749:               --  the Index_Type.
        -: 1750:
        -: 1751:               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);
        -: 1752:            end if;
        -: 1753:         end if;
        -: 1754:
        -: 1755:      elsif Index_Type'First <= 0 then
        -: 1756:
        -: 1757:         --  We know that No_Index (the same as Index_Type'First - 1) is less
        -: 1758:         --  than 0, so it is safe to compute the following sum without fear of
        -: 1759:         --  overflow.
        -: 1760:
        -: 1761:         J := Count_Type'Base (No_Index) + Count_Type'Last;
        -: 1762:
        -: 1763:         if J <= Count_Type'Base (Index_Type'Last) then
        -: 1764:
        -: 1765:            --  We have determined that range of Index_Type has at least as
        -: 1766:            --  many values as in Count_Type, so Count_Type'Last is the maximum
        -: 1767:            --  number of items that are allowed.
        -: 1768:
        -: 1769:            Max_Length := Count_Type'Last;
        -: 1770:
        -: 1771:         else
        -: 1772:            --  The range of Index_Type has fewer values than Count_Type does,
        -: 1773:            --  so the maximum number of items is computed from the range of
        -: 1774:            --  the Index_Type.
        -: 1775:
        -: 1776:            Max_Length :=
        -: 1777:              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1778:         end if;
        -: 1779:
        -: 1780:      else
        -: 1781:         --  No_Index is equal or greater than 0, so we can safely compute the
        -: 1782:         --  difference without fear of overflow (which we would have to worry
        -: 1783:         --  about if No_Index were less than 0, but that case is handled
        -: 1784:         --  above).
        -: 1785:
        -: 1786:         Max_Length :=
        -: 1787:           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);
        -: 1788:      end if;
        -: 1789:
        -: 1790:      --  We have just computed the maximum length (number of items). We must
        -: 1791:      --  now compare the requested length to the maximum length, as we do not
        -: 1792:      --  allow a vector expand beyond the maximum (because that would create
        -: 1793:      --  an internal array with a last index value greater than
        -: 1794:      --  Index_Type'Last, with no way to index those elements).
        -: 1795:
    #####: 1796:      if Checks and then New_Length > Max_Length then
    #####: 1797:         raise Constraint_Error with "Count is out of range";
        -: 1798:      end if;
        -: 1799:
        -: 1800:      --  New_Last is the last index value of the items in the container after
        -: 1801:      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to
        -: 1802:      --  compute its value from the New_Length.
        -: 1803:
        -: 1804:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1805:         New_Last := No_Index + Index_Type'Base (New_Length);
        -: 1806:      else
        -: 1807:         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);
        -: 1808:      end if;
        -: 1809:
    #####: 1810:      if Container.Elements = null then
    #####: 1811:         pragma Assert (Container.Last = No_Index);
        -: 1812:
        -: 1813:         --  This is the simplest case, with which we must always begin: we're
        -: 1814:         --  inserting items into an empty vector that hasn't allocated an
        -: 1815:         --  internal array yet. Note that we don't need to check the busy bit
        -: 1816:         --  here, because an empty container cannot be busy.
        -: 1817:
        -: 1818:         --  In order to preserve container invariants, we allocate the new
        -: 1819:         --  internal array first, before setting the Last index value, in case
        -: 1820:         --  the allocation fails (which can happen either because there is no
        -: 1821:         --  storage available, or because default-valued element
        -: 1822:         --  initialization fails).
        -: 1823:
    #####: 1824:         Container.Elements := new Elements_Type (New_Last);
        -: 1825:
        -: 1826:         --  The allocation of the new, internal array succeeded, so it is now
        -: 1827:         --  safe to update the Last index, restoring container invariants.
        -: 1828:
    #####: 1829:         Container.Last := New_Last;
        -: 1830:
    #####: 1831:         return;
        -: 1832:      end if;
        -: 1833:
        -: 1834:      --  An internal array has already been allocated, so we must determine
        -: 1835:      --  whether there is enough unused storage for the new items.
        -: 1836:
    #####: 1837:      if New_Last <= Container.Elements.Last then
        -: 1838:
        -: 1839:         --  In this case, we're inserting space into a vector that has already
        -: 1840:         --  allocated an internal array, and the existing array has enough
        -: 1841:         --  unused storage for the new items.
        -: 1842:
        -: 1843:         declare
    #####: 1844:            EA : Elements_Array renames Container.Elements.EA;
        -: 1845:
        -: 1846:         begin
    #####: 1847:            if Before <= Container.Last then
        -: 1848:
        -: 1849:               --  The space is being inserted before some existing elements,
        -: 1850:               --  so we must slide the existing elements up to their new
        -: 1851:               --  home. We use the wider of Index_Type'Base and
        -: 1852:               --  Count_Type'Base as the type for intermediate index values.
        -: 1853:
        -: 1854:               if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1855:                  Index := Before + Index_Type'Base (Count);
        -: 1856:
        -: 1857:               else
        -: 1858:                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1859:               end if;
        -: 1860:
    #####: 1861:               EA (Index .. New_Last) := EA (Before .. Container.Last);
        -: 1862:            end if;
        -: 1863:         end;
        -: 1864:
    #####: 1865:         Container.Last := New_Last;
    #####: 1866:         return;
        -: 1867:      end if;
        -: 1868:
        -: 1869:      --  In this case, we're inserting space into a vector that has already
        -: 1870:      --  allocated an internal array, but the existing array does not have
        -: 1871:      --  enough storage, so we must allocate a new, longer array. In order to
        -: 1872:      --  guarantee that the amortized insertion cost is O(1), we always
        -: 1873:      --  allocate an array whose length is some power-of-two factor of the
        -: 1874:      --  current array length. (The new array cannot have a length less than
        -: 1875:      --  the New_Length of the container, but its last index value cannot be
        -: 1876:      --  greater than Index_Type'Last.)
        -: 1877:
    #####: 1878:      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);
    #####: 1879:      while New_Capacity < New_Length loop
    #####: 1880:         if New_Capacity > Count_Type'Last / 2 then
    #####: 1881:            New_Capacity := Count_Type'Last;
    #####: 1882:            exit;
        -: 1883:         end if;
        -: 1884:
    #####: 1885:         New_Capacity := 2 * New_Capacity;
    #####: 1886:      end loop;
        -: 1887:
    #####: 1888:      if New_Capacity > Max_Length then
        -: 1889:
        -: 1890:         --  We have reached the limit of capacity, so no further expansion
        -: 1891:         --  will occur. (This is not a problem, as there is never a need to
        -: 1892:         --  have more capacity than the maximum container length.)
        -: 1893:
    #####: 1894:         New_Capacity := Max_Length;
        -: 1895:      end if;
        -: 1896:
        -: 1897:      --  We have computed the length of the new internal array (and this is
        -: 1898:      --  what "vector capacity" means), so use that to compute its last index.
        -: 1899:
        -: 1900:      if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1901:         Dst_Last := No_Index + Index_Type'Base (New_Capacity);
        -: 1902:      else
        -: 1903:         Dst_Last :=
        -: 1904:           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);
        -: 1905:      end if;
        -: 1906:
        -: 1907:      --  Now we allocate the new, longer internal array. If the allocation
        -: 1908:      --  fails, we have not changed any container state, so no side-effect
        -: 1909:      --  will occur as a result of propagating the exception.
        -: 1910:
    #####: 1911:      Dst := new Elements_Type (Dst_Last);
        -: 1912:
        -: 1913:      --  We have our new internal array. All that needs to be done now is to
        -: 1914:      --  copy the existing items (if any) from the old array (the "source"
        -: 1915:      --  array, object SA below) to the new array (the "destination" array,
        -: 1916:      --  object DA below), and then deallocate the old array.
        -: 1917:
        -: 1918:      declare
    #####: 1919:         SA : Elements_Array renames Container.Elements.EA;  -- source
    #####: 1920:         DA : Elements_Array renames Dst.EA;                 -- destination
        -: 1921:
        -: 1922:      begin
    #####: 1923:         DA (Index_Type'First .. Before - 1) :=
    #####: 1924:           SA (Index_Type'First .. Before - 1);
        -: 1925:
    #####: 1926:         if Before <= Container.Last then
        -: 1927:
        -: 1928:            --  The space is being inserted before some existing elements, so
        -: 1929:            --  we must slide the existing elements up to their new home.
        -: 1930:
        -: 1931:            if Index_Type'Base'Last >= Count_Type_Last then
    #####: 1932:               Index := Before + Index_Type'Base (Count);
        -: 1933:            else
        -: 1934:               Index := Index_Type'Base (Count_Type'Base (Before) + Count);
        -: 1935:            end if;
        -: 1936:
    #####: 1937:            DA (Index .. New_Last) := SA (Before .. Container.Last);
        -: 1938:         end if;
        -: 1939:
        -: 1940:      exception
    =====: 1941:         when others =>
    =====: 1942:            Free (Dst);
    =====: 1943:            raise;
        -: 1944:      end;
        -: 1945:
        -: 1946:      --  We have successfully copied the items onto the new array, so the
        -: 1947:      --  final thing to do is restore invariants, and deallocate the old
        -: 1948:      --  array.
        -: 1949:
        -: 1950:      declare
    #####: 1951:         X : Elements_Access := Container.Elements;
        -: 1952:
        -: 1953:      begin
        -: 1954:         --  We first isolate the old internal array, removing it from the
        -: 1955:         --  container and replacing it with the new internal array, before we
        -: 1956:         --  deallocate the old array (which can fail if finalization of
        -: 1957:         --  elements propagates an exception).
        -: 1958:
    #####: 1959:         Container.Elements := Dst;
    #####: 1960:         Container.Last := New_Last;
        -: 1961:
        -: 1962:         --  The container invariants have been restored, so it is now safe to
        -: 1963:         --  attempt to deallocate the old array.
        -: 1964:
    #####: 1965:         Free (X);
        -: 1966:      end;
        -: 1967:   end Insert_Space;
------------------
        -: 1968:
    #####: 1969:   procedure Insert_Space
        -: 1970:     (Container : in out Vector;
        -: 1971:      Before    : Cursor;
        -: 1972:      Position  : out Cursor;
        -: 1973:      Count     : Count_Type := 1)
        -: 1974:   is
        -: 1975:      Index : Index_Type'Base;
        -: 1976:
        -: 1977:   begin
    #####: 1978:      if Checks and then Before.Container /= null
    #####: 1979:        and then Before.Container /= Container'Unrestricted_Access
        -: 1980:      then
    #####: 1981:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1982:      end if;
        -: 1983:
    #####: 1984:      if Count = 0 then
    #####: 1985:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1986:            Position := No_Element;
        -: 1987:         else
    #####: 1988:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1989:         end if;
        -: 1990:
    #####: 1991:         return;
        -: 1992:      end if;
        -: 1993:
    #####: 1994:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1995:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1996:            raise Constraint_Error with
        -: 1997:              "vector is already at its maximum length";
        -: 1998:         else
    #####: 1999:            Index := Container.Last + 1;
        -: 2000:         end if;
        -: 2001:
        -: 2002:      else
    #####: 2003:         Index := Before.Index;
        -: 2004:      end if;
        -: 2005:
    #####: 2006:      Insert_Space (Container, Index, Count);
        -: 2007:
    #####: 2008:      Position := (Container'Unrestricted_Access, Index);
    #####: 2009:   end Insert_Space;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__insert_space__2.159:
    #####: 1969:   procedure Insert_Space
        -: 1970:     (Container : in out Vector;
        -: 1971:      Before    : Cursor;
        -: 1972:      Position  : out Cursor;
        -: 1973:      Count     : Count_Type := 1)
        -: 1974:   is
        -: 1975:      Index : Index_Type'Base;
        -: 1976:
        -: 1977:   begin
    #####: 1978:      if Checks and then Before.Container /= null
    #####: 1979:        and then Before.Container /= Container'Unrestricted_Access
        -: 1980:      then
    #####: 1981:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1982:      end if;
        -: 1983:
    #####: 1984:      if Count = 0 then
    #####: 1985:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1986:            Position := No_Element;
        -: 1987:         else
    #####: 1988:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1989:         end if;
        -: 1990:
    #####: 1991:         return;
        -: 1992:      end if;
        -: 1993:
    #####: 1994:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1995:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1996:            raise Constraint_Error with
        -: 1997:              "vector is already at its maximum length";
        -: 1998:         else
    #####: 1999:            Index := Container.Last + 1;
        -: 2000:         end if;
        -: 2001:
        -: 2002:      else
    #####: 2003:         Index := Before.Index;
        -: 2004:      end if;
        -: 2005:
    #####: 2006:      Insert_Space (Container, Index, Count);
        -: 2007:
    #####: 2008:      Position := (Container'Unrestricted_Access, Index);
    #####: 2009:   end Insert_Space;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__insert_space__2.288:
    #####: 1969:   procedure Insert_Space
        -: 1970:     (Container : in out Vector;
        -: 1971:      Before    : Cursor;
        -: 1972:      Position  : out Cursor;
        -: 1973:      Count     : Count_Type := 1)
        -: 1974:   is
        -: 1975:      Index : Index_Type'Base;
        -: 1976:
        -: 1977:   begin
    #####: 1978:      if Checks and then Before.Container /= null
    #####: 1979:        and then Before.Container /= Container'Unrestricted_Access
        -: 1980:      then
    #####: 1981:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1982:      end if;
        -: 1983:
    #####: 1984:      if Count = 0 then
    #####: 1985:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1986:            Position := No_Element;
        -: 1987:         else
    #####: 1988:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1989:         end if;
        -: 1990:
    #####: 1991:         return;
        -: 1992:      end if;
        -: 1993:
    #####: 1994:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1995:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1996:            raise Constraint_Error with
        -: 1997:              "vector is already at its maximum length";
        -: 1998:         else
    #####: 1999:            Index := Container.Last + 1;
        -: 2000:         end if;
        -: 2001:
        -: 2002:      else
    #####: 2003:         Index := Before.Index;
        -: 2004:      end if;
        -: 2005:
    #####: 2006:      Insert_Space (Container, Index, Count);
        -: 2007:
    #####: 2008:      Position := (Container'Unrestricted_Access, Index);
    #####: 2009:   end Insert_Space;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__insert_space__2.518:
    #####: 1969:   procedure Insert_Space
        -: 1970:     (Container : in out Vector;
        -: 1971:      Before    : Cursor;
        -: 1972:      Position  : out Cursor;
        -: 1973:      Count     : Count_Type := 1)
        -: 1974:   is
        -: 1975:      Index : Index_Type'Base;
        -: 1976:
        -: 1977:   begin
    #####: 1978:      if Checks and then Before.Container /= null
    #####: 1979:        and then Before.Container /= Container'Unrestricted_Access
        -: 1980:      then
    #####: 1981:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1982:      end if;
        -: 1983:
    #####: 1984:      if Count = 0 then
    #####: 1985:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1986:            Position := No_Element;
        -: 1987:         else
    #####: 1988:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1989:         end if;
        -: 1990:
    #####: 1991:         return;
        -: 1992:      end if;
        -: 1993:
    #####: 1994:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1995:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1996:            raise Constraint_Error with
        -: 1997:              "vector is already at its maximum length";
        -: 1998:         else
    #####: 1999:            Index := Container.Last + 1;
        -: 2000:         end if;
        -: 2001:
        -: 2002:      else
    #####: 2003:         Index := Before.Index;
        -: 2004:      end if;
        -: 2005:
    #####: 2006:      Insert_Space (Container, Index, Count);
        -: 2007:
    #####: 2008:      Position := (Container'Unrestricted_Access, Index);
    #####: 2009:   end Insert_Space;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__insert_space__2.647:
    #####: 1969:   procedure Insert_Space
        -: 1970:     (Container : in out Vector;
        -: 1971:      Before    : Cursor;
        -: 1972:      Position  : out Cursor;
        -: 1973:      Count     : Count_Type := 1)
        -: 1974:   is
        -: 1975:      Index : Index_Type'Base;
        -: 1976:
        -: 1977:   begin
    #####: 1978:      if Checks and then Before.Container /= null
    #####: 1979:        and then Before.Container /= Container'Unrestricted_Access
        -: 1980:      then
    #####: 1981:         raise Program_Error with "Before cursor denotes wrong container";
        -: 1982:      end if;
        -: 1983:
    #####: 1984:      if Count = 0 then
    #####: 1985:         if Before.Container = null or else Before.Index > Container.Last then
    #####: 1986:            Position := No_Element;
        -: 1987:         else
    #####: 1988:            Position := (Container'Unrestricted_Access, Before.Index);
        -: 1989:         end if;
        -: 1990:
    #####: 1991:         return;
        -: 1992:      end if;
        -: 1993:
    #####: 1994:      if Before.Container = null or else Before.Index > Container.Last then
    #####: 1995:         if Checks and then Container.Last = Index_Type'Last then
    #####: 1996:            raise Constraint_Error with
        -: 1997:              "vector is already at its maximum length";
        -: 1998:         else
    #####: 1999:            Index := Container.Last + 1;
        -: 2000:         end if;
        -: 2001:
        -: 2002:      else
    #####: 2003:         Index := Before.Index;
        -: 2004:      end if;
        -: 2005:
    #####: 2006:      Insert_Space (Container, Index, Count);
        -: 2007:
    #####: 2008:      Position := (Container'Unrestricted_Access, Index);
    #####: 2009:   end Insert_Space;
------------------
        -: 2010:
        -: 2011:   --------------
        -: 2012:   -- Is_Empty --
        -: 2013:   --------------
        -: 2014:
    #####: 2015:   function Is_Empty (Container : Vector) return Boolean is
        -: 2016:   begin
    #####: 2017:      return Container.Last < Index_Type'First;
        -: 2018:   end Is_Empty;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__is_empty.158:
    #####: 2015:   function Is_Empty (Container : Vector) return Boolean is
        -: 2016:   begin
    #####: 2017:      return Container.Last < Index_Type'First;
        -: 2018:   end Is_Empty;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__is_empty.287:
    #####: 2015:   function Is_Empty (Container : Vector) return Boolean is
        -: 2016:   begin
    #####: 2017:      return Container.Last < Index_Type'First;
        -: 2018:   end Is_Empty;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__is_empty.517:
    #####: 2015:   function Is_Empty (Container : Vector) return Boolean is
        -: 2016:   begin
    #####: 2017:      return Container.Last < Index_Type'First;
        -: 2018:   end Is_Empty;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__is_empty.646:
    #####: 2015:   function Is_Empty (Container : Vector) return Boolean is
        -: 2016:   begin
    #####: 2017:      return Container.Last < Index_Type'First;
        -: 2018:   end Is_Empty;
------------------
        -: 2019:
        -: 2020:   -------------
        -: 2021:   -- Iterate --
        -: 2022:   -------------
        -: 2023:
    #####: 2024:   procedure Iterate
        -: 2025:     (Container : Vector;
        -: 2026:      Process   : not null access procedure (Position : Cursor))
        -: 2027:   is
    #####: 2028:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2029:   begin
    #####: 2030:      for Indx in Index_Type'First .. Container.Last loop
    #####: 2031:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2032:      end loop;
    #####: 2033:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__iterate.156:
    #####: 2024:   procedure Iterate
        -: 2025:     (Container : Vector;
        -: 2026:      Process   : not null access procedure (Position : Cursor))
        -: 2027:   is
    #####: 2028:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2029:   begin
    #####: 2030:      for Indx in Index_Type'First .. Container.Last loop
    #####: 2031:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2032:      end loop;
    #####: 2033:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__iterate.285:
    #####: 2024:   procedure Iterate
        -: 2025:     (Container : Vector;
        -: 2026:      Process   : not null access procedure (Position : Cursor))
        -: 2027:   is
    #####: 2028:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2029:   begin
    #####: 2030:      for Indx in Index_Type'First .. Container.Last loop
    #####: 2031:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2032:      end loop;
    #####: 2033:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__iterate.515:
    #####: 2024:   procedure Iterate
        -: 2025:     (Container : Vector;
        -: 2026:      Process   : not null access procedure (Position : Cursor))
        -: 2027:   is
    #####: 2028:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2029:   begin
    #####: 2030:      for Indx in Index_Type'First .. Container.Last loop
    #####: 2031:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2032:      end loop;
    #####: 2033:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__iterate.644:
    #####: 2024:   procedure Iterate
        -: 2025:     (Container : Vector;
        -: 2026:      Process   : not null access procedure (Position : Cursor))
        -: 2027:   is
    #####: 2028:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2029:   begin
    #####: 2030:      for Indx in Index_Type'First .. Container.Last loop
    #####: 2031:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2032:      end loop;
    #####: 2033:   end Iterate;
------------------
        -: 2034:
    #####: 2035:   function Iterate
        -: 2036:     (Container : Vector)
        -: 2037:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2038:   is
    #####: 2039:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2040:   begin
        -: 2041:      --  The value of its Index component influences the behavior of the First
        -: 2042:      --  and Last selector functions of the iterator object. When the Index
        -: 2043:      --  component is No_Index (as is the case here), this means the iterator
        -: 2044:      --  object was constructed without a start expression. This is a complete
        -: 2045:      --  iterator, meaning that the iteration starts from the (logical)
        -: 2046:      --  beginning of the sequence of items.
        -: 2047:
        -: 2048:      --  Note: For a forward iterator, Container.First is the beginning, and
        -: 2049:      --  for a reverse iterator, Container.Last is the beginning.
        -: 2050:
    #####: 2051:      return It : constant Iterator :=
    #####: 2052:                    (Limited_Controlled with
        -: 2053:                       Container => V,
        -: 2054:                       Index     => No_Index)
        -: 2055:      do
    #####: 2056:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2057:      end return;
    #####: 2058:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__iterate__2.149:
    #####: 2035:   function Iterate
        -: 2036:     (Container : Vector)
        -: 2037:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2038:   is
    #####: 2039:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2040:   begin
        -: 2041:      --  The value of its Index component influences the behavior of the First
        -: 2042:      --  and Last selector functions of the iterator object. When the Index
        -: 2043:      --  component is No_Index (as is the case here), this means the iterator
        -: 2044:      --  object was constructed without a start expression. This is a complete
        -: 2045:      --  iterator, meaning that the iteration starts from the (logical)
        -: 2046:      --  beginning of the sequence of items.
        -: 2047:
        -: 2048:      --  Note: For a forward iterator, Container.First is the beginning, and
        -: 2049:      --  for a reverse iterator, Container.Last is the beginning.
        -: 2050:
    #####: 2051:      return It : constant Iterator :=
    #####: 2052:                    (Limited_Controlled with
        -: 2053:                       Container => V,
        -: 2054:                       Index     => No_Index)
        -: 2055:      do
    #####: 2056:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2057:      end return;
    #####: 2058:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__iterate__2.278:
    #####: 2035:   function Iterate
        -: 2036:     (Container : Vector)
        -: 2037:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2038:   is
    #####: 2039:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2040:   begin
        -: 2041:      --  The value of its Index component influences the behavior of the First
        -: 2042:      --  and Last selector functions of the iterator object. When the Index
        -: 2043:      --  component is No_Index (as is the case here), this means the iterator
        -: 2044:      --  object was constructed without a start expression. This is a complete
        -: 2045:      --  iterator, meaning that the iteration starts from the (logical)
        -: 2046:      --  beginning of the sequence of items.
        -: 2047:
        -: 2048:      --  Note: For a forward iterator, Container.First is the beginning, and
        -: 2049:      --  for a reverse iterator, Container.Last is the beginning.
        -: 2050:
    #####: 2051:      return It : constant Iterator :=
    #####: 2052:                    (Limited_Controlled with
        -: 2053:                       Container => V,
        -: 2054:                       Index     => No_Index)
        -: 2055:      do
    #####: 2056:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2057:      end return;
    #####: 2058:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__iterate__2.508:
    #####: 2035:   function Iterate
        -: 2036:     (Container : Vector)
        -: 2037:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2038:   is
    #####: 2039:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2040:   begin
        -: 2041:      --  The value of its Index component influences the behavior of the First
        -: 2042:      --  and Last selector functions of the iterator object. When the Index
        -: 2043:      --  component is No_Index (as is the case here), this means the iterator
        -: 2044:      --  object was constructed without a start expression. This is a complete
        -: 2045:      --  iterator, meaning that the iteration starts from the (logical)
        -: 2046:      --  beginning of the sequence of items.
        -: 2047:
        -: 2048:      --  Note: For a forward iterator, Container.First is the beginning, and
        -: 2049:      --  for a reverse iterator, Container.Last is the beginning.
        -: 2050:
    #####: 2051:      return It : constant Iterator :=
    #####: 2052:                    (Limited_Controlled with
        -: 2053:                       Container => V,
        -: 2054:                       Index     => No_Index)
        -: 2055:      do
    #####: 2056:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2057:      end return;
    #####: 2058:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__iterate__2.637:
    #####: 2035:   function Iterate
        -: 2036:     (Container : Vector)
        -: 2037:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2038:   is
    #####: 2039:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2040:   begin
        -: 2041:      --  The value of its Index component influences the behavior of the First
        -: 2042:      --  and Last selector functions of the iterator object. When the Index
        -: 2043:      --  component is No_Index (as is the case here), this means the iterator
        -: 2044:      --  object was constructed without a start expression. This is a complete
        -: 2045:      --  iterator, meaning that the iteration starts from the (logical)
        -: 2046:      --  beginning of the sequence of items.
        -: 2047:
        -: 2048:      --  Note: For a forward iterator, Container.First is the beginning, and
        -: 2049:      --  for a reverse iterator, Container.Last is the beginning.
        -: 2050:
    #####: 2051:      return It : constant Iterator :=
    #####: 2052:                    (Limited_Controlled with
        -: 2053:                       Container => V,
        -: 2054:                       Index     => No_Index)
        -: 2055:      do
    #####: 2056:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2057:      end return;
    #####: 2058:   end Iterate;
------------------
        -: 2059:
    #####: 2060:   function Iterate
        -: 2061:     (Container : Vector;
        -: 2062:      Start     : Cursor)
        -: 2063:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2064:   is
    #####: 2065:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2066:   begin
        -: 2067:      --  It was formerly the case that when Start = No_Element, the partial
        -: 2068:      --  iterator was defined to behave the same as for a complete iterator,
        -: 2069:      --  and iterate over the entire sequence of items. However, those
        -: 2070:      --  semantics were unintuitive and arguably error-prone (it is too easy
        -: 2071:      --  to accidentally create an endless loop), and so they were changed,
        -: 2072:      --  per the ARG meeting in Denver on 2011/11. However, there was no
        -: 2073:      --  consensus about what positive meaning this corner case should have,
        -: 2074:      --  and so it was decided to simply raise an exception. This does imply,
        -: 2075:      --  however, that it is not possible to use a partial iterator to specify
        -: 2076:      --  an empty sequence of items.
        -: 2077:
        -: 2078:      if Checks then
    #####: 2079:         if Start.Container = null then
    #####: 2080:            raise Constraint_Error with
        -: 2081:              "Start position for iterator equals No_Element";
        -: 2082:         end if;
        -: 2083:
    #####: 2084:         if Start.Container /= V then
    #####: 2085:            raise Program_Error with
        -: 2086:              "Start cursor of Iterate designates wrong vector";
        -: 2087:         end if;
        -: 2088:
    #####: 2089:         if Start.Index > V.Last then
    #####: 2090:            raise Constraint_Error with
        -: 2091:              "Start position for iterator equals No_Element";
        -: 2092:         end if;
        -: 2093:      end if;
        -: 2094:
        -: 2095:      --  The value of its Index component influences the behavior of the First
        -: 2096:      --  and Last selector functions of the iterator object. When the Index
        -: 2097:      --  component is not No_Index (as is the case here), it means that this
        -: 2098:      --  is a partial iteration, over a subset of the complete sequence of
        -: 2099:      --  items. The iterator object was constructed with a start expression,
        -: 2100:      --  indicating the position from which the iteration begins. Note that
        -: 2101:      --  the start position has the same value irrespective of whether this
        -: 2102:      --  is a forward or reverse iteration.
        -: 2103:
    #####: 2104:      return It : constant Iterator :=
    #####: 2105:                    (Limited_Controlled with
        -: 2106:                       Container => V,
        -: 2107:                       Index     => Start.Index)
        -: 2108:      do
    #####: 2109:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2110:      end return;
    #####: 2111:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__iterate__3.142:
    #####: 2060:   function Iterate
        -: 2061:     (Container : Vector;
        -: 2062:      Start     : Cursor)
        -: 2063:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2064:   is
    #####: 2065:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2066:   begin
        -: 2067:      --  It was formerly the case that when Start = No_Element, the partial
        -: 2068:      --  iterator was defined to behave the same as for a complete iterator,
        -: 2069:      --  and iterate over the entire sequence of items. However, those
        -: 2070:      --  semantics were unintuitive and arguably error-prone (it is too easy
        -: 2071:      --  to accidentally create an endless loop), and so they were changed,
        -: 2072:      --  per the ARG meeting in Denver on 2011/11. However, there was no
        -: 2073:      --  consensus about what positive meaning this corner case should have,
        -: 2074:      --  and so it was decided to simply raise an exception. This does imply,
        -: 2075:      --  however, that it is not possible to use a partial iterator to specify
        -: 2076:      --  an empty sequence of items.
        -: 2077:
        -: 2078:      if Checks then
    #####: 2079:         if Start.Container = null then
    #####: 2080:            raise Constraint_Error with
        -: 2081:              "Start position for iterator equals No_Element";
        -: 2082:         end if;
        -: 2083:
    #####: 2084:         if Start.Container /= V then
    #####: 2085:            raise Program_Error with
        -: 2086:              "Start cursor of Iterate designates wrong vector";
        -: 2087:         end if;
        -: 2088:
    #####: 2089:         if Start.Index > V.Last then
    #####: 2090:            raise Constraint_Error with
        -: 2091:              "Start position for iterator equals No_Element";
        -: 2092:         end if;
        -: 2093:      end if;
        -: 2094:
        -: 2095:      --  The value of its Index component influences the behavior of the First
        -: 2096:      --  and Last selector functions of the iterator object. When the Index
        -: 2097:      --  component is not No_Index (as is the case here), it means that this
        -: 2098:      --  is a partial iteration, over a subset of the complete sequence of
        -: 2099:      --  items. The iterator object was constructed with a start expression,
        -: 2100:      --  indicating the position from which the iteration begins. Note that
        -: 2101:      --  the start position has the same value irrespective of whether this
        -: 2102:      --  is a forward or reverse iteration.
        -: 2103:
    #####: 2104:      return It : constant Iterator :=
    #####: 2105:                    (Limited_Controlled with
        -: 2106:                       Container => V,
        -: 2107:                       Index     => Start.Index)
        -: 2108:      do
    #####: 2109:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2110:      end return;
    #####: 2111:   end Iterate;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__iterate__3.271:
    #####: 2060:   function Iterate
        -: 2061:     (Container : Vector;
        -: 2062:      Start     : Cursor)
        -: 2063:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2064:   is
    #####: 2065:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2066:   begin
        -: 2067:      --  It was formerly the case that when Start = No_Element, the partial
        -: 2068:      --  iterator was defined to behave the same as for a complete iterator,
        -: 2069:      --  and iterate over the entire sequence of items. However, those
        -: 2070:      --  semantics were unintuitive and arguably error-prone (it is too easy
        -: 2071:      --  to accidentally create an endless loop), and so they were changed,
        -: 2072:      --  per the ARG meeting in Denver on 2011/11. However, there was no
        -: 2073:      --  consensus about what positive meaning this corner case should have,
        -: 2074:      --  and so it was decided to simply raise an exception. This does imply,
        -: 2075:      --  however, that it is not possible to use a partial iterator to specify
        -: 2076:      --  an empty sequence of items.
        -: 2077:
        -: 2078:      if Checks then
    #####: 2079:         if Start.Container = null then
    #####: 2080:            raise Constraint_Error with
        -: 2081:              "Start position for iterator equals No_Element";
        -: 2082:         end if;
        -: 2083:
    #####: 2084:         if Start.Container /= V then
    #####: 2085:            raise Program_Error with
        -: 2086:              "Start cursor of Iterate designates wrong vector";
        -: 2087:         end if;
        -: 2088:
    #####: 2089:         if Start.Index > V.Last then
    #####: 2090:            raise Constraint_Error with
        -: 2091:              "Start position for iterator equals No_Element";
        -: 2092:         end if;
        -: 2093:      end if;
        -: 2094:
        -: 2095:      --  The value of its Index component influences the behavior of the First
        -: 2096:      --  and Last selector functions of the iterator object. When the Index
        -: 2097:      --  component is not No_Index (as is the case here), it means that this
        -: 2098:      --  is a partial iteration, over a subset of the complete sequence of
        -: 2099:      --  items. The iterator object was constructed with a start expression,
        -: 2100:      --  indicating the position from which the iteration begins. Note that
        -: 2101:      --  the start position has the same value irrespective of whether this
        -: 2102:      --  is a forward or reverse iteration.
        -: 2103:
    #####: 2104:      return It : constant Iterator :=
    #####: 2105:                    (Limited_Controlled with
        -: 2106:                       Container => V,
        -: 2107:                       Index     => Start.Index)
        -: 2108:      do
    #####: 2109:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2110:      end return;
    #####: 2111:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__iterate__3.501:
    #####: 2060:   function Iterate
        -: 2061:     (Container : Vector;
        -: 2062:      Start     : Cursor)
        -: 2063:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2064:   is
    #####: 2065:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2066:   begin
        -: 2067:      --  It was formerly the case that when Start = No_Element, the partial
        -: 2068:      --  iterator was defined to behave the same as for a complete iterator,
        -: 2069:      --  and iterate over the entire sequence of items. However, those
        -: 2070:      --  semantics were unintuitive and arguably error-prone (it is too easy
        -: 2071:      --  to accidentally create an endless loop), and so they were changed,
        -: 2072:      --  per the ARG meeting in Denver on 2011/11. However, there was no
        -: 2073:      --  consensus about what positive meaning this corner case should have,
        -: 2074:      --  and so it was decided to simply raise an exception. This does imply,
        -: 2075:      --  however, that it is not possible to use a partial iterator to specify
        -: 2076:      --  an empty sequence of items.
        -: 2077:
        -: 2078:      if Checks then
    #####: 2079:         if Start.Container = null then
    #####: 2080:            raise Constraint_Error with
        -: 2081:              "Start position for iterator equals No_Element";
        -: 2082:         end if;
        -: 2083:
    #####: 2084:         if Start.Container /= V then
    #####: 2085:            raise Program_Error with
        -: 2086:              "Start cursor of Iterate designates wrong vector";
        -: 2087:         end if;
        -: 2088:
    #####: 2089:         if Start.Index > V.Last then
    #####: 2090:            raise Constraint_Error with
        -: 2091:              "Start position for iterator equals No_Element";
        -: 2092:         end if;
        -: 2093:      end if;
        -: 2094:
        -: 2095:      --  The value of its Index component influences the behavior of the First
        -: 2096:      --  and Last selector functions of the iterator object. When the Index
        -: 2097:      --  component is not No_Index (as is the case here), it means that this
        -: 2098:      --  is a partial iteration, over a subset of the complete sequence of
        -: 2099:      --  items. The iterator object was constructed with a start expression,
        -: 2100:      --  indicating the position from which the iteration begins. Note that
        -: 2101:      --  the start position has the same value irrespective of whether this
        -: 2102:      --  is a forward or reverse iteration.
        -: 2103:
    #####: 2104:      return It : constant Iterator :=
    #####: 2105:                    (Limited_Controlled with
        -: 2106:                       Container => V,
        -: 2107:                       Index     => Start.Index)
        -: 2108:      do
    #####: 2109:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2110:      end return;
    #####: 2111:   end Iterate;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__iterate__3.630:
    #####: 2060:   function Iterate
        -: 2061:     (Container : Vector;
        -: 2062:      Start     : Cursor)
        -: 2063:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class
        -: 2064:   is
    #####: 2065:      V : constant Vector_Access := Container'Unrestricted_Access;
        -: 2066:   begin
        -: 2067:      --  It was formerly the case that when Start = No_Element, the partial
        -: 2068:      --  iterator was defined to behave the same as for a complete iterator,
        -: 2069:      --  and iterate over the entire sequence of items. However, those
        -: 2070:      --  semantics were unintuitive and arguably error-prone (it is too easy
        -: 2071:      --  to accidentally create an endless loop), and so they were changed,
        -: 2072:      --  per the ARG meeting in Denver on 2011/11. However, there was no
        -: 2073:      --  consensus about what positive meaning this corner case should have,
        -: 2074:      --  and so it was decided to simply raise an exception. This does imply,
        -: 2075:      --  however, that it is not possible to use a partial iterator to specify
        -: 2076:      --  an empty sequence of items.
        -: 2077:
        -: 2078:      if Checks then
    #####: 2079:         if Start.Container = null then
    #####: 2080:            raise Constraint_Error with
        -: 2081:              "Start position for iterator equals No_Element";
        -: 2082:         end if;
        -: 2083:
    #####: 2084:         if Start.Container /= V then
    #####: 2085:            raise Program_Error with
        -: 2086:              "Start cursor of Iterate designates wrong vector";
        -: 2087:         end if;
        -: 2088:
    #####: 2089:         if Start.Index > V.Last then
    #####: 2090:            raise Constraint_Error with
        -: 2091:              "Start position for iterator equals No_Element";
        -: 2092:         end if;
        -: 2093:      end if;
        -: 2094:
        -: 2095:      --  The value of its Index component influences the behavior of the First
        -: 2096:      --  and Last selector functions of the iterator object. When the Index
        -: 2097:      --  component is not No_Index (as is the case here), it means that this
        -: 2098:      --  is a partial iteration, over a subset of the complete sequence of
        -: 2099:      --  items. The iterator object was constructed with a start expression,
        -: 2100:      --  indicating the position from which the iteration begins. Note that
        -: 2101:      --  the start position has the same value irrespective of whether this
        -: 2102:      --  is a forward or reverse iteration.
        -: 2103:
    #####: 2104:      return It : constant Iterator :=
    #####: 2105:                    (Limited_Controlled with
        -: 2106:                       Container => V,
        -: 2107:                       Index     => Start.Index)
        -: 2108:      do
    #####: 2109:         Busy (Container.TC'Unrestricted_Access.all);
        -: 2110:      end return;
    #####: 2111:   end Iterate;
------------------
        -: 2112:
        -: 2113:   ----------
        -: 2114:   -- Last --
        -: 2115:   ----------
        -: 2116:
    #####: 2117:   function Last (Container : Vector) return Cursor is
        -: 2118:   begin
    #####: 2119:      if Is_Empty (Container) then
    #####: 2120:         return No_Element;
        -: 2121:      else
    #####: 2122:         return (Container'Unrestricted_Access, Container.Last);
        -: 2123:      end if;
        -: 2124:   end Last;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__last.141:
    #####: 2117:   function Last (Container : Vector) return Cursor is
        -: 2118:   begin
    #####: 2119:      if Is_Empty (Container) then
    #####: 2120:         return No_Element;
        -: 2121:      else
    #####: 2122:         return (Container'Unrestricted_Access, Container.Last);
        -: 2123:      end if;
        -: 2124:   end Last;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__last.270:
    #####: 2117:   function Last (Container : Vector) return Cursor is
        -: 2118:   begin
    #####: 2119:      if Is_Empty (Container) then
    #####: 2120:         return No_Element;
        -: 2121:      else
    #####: 2122:         return (Container'Unrestricted_Access, Container.Last);
        -: 2123:      end if;
        -: 2124:   end Last;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__last.500:
    #####: 2117:   function Last (Container : Vector) return Cursor is
        -: 2118:   begin
    #####: 2119:      if Is_Empty (Container) then
    #####: 2120:         return No_Element;
        -: 2121:      else
    #####: 2122:         return (Container'Unrestricted_Access, Container.Last);
        -: 2123:      end if;
        -: 2124:   end Last;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__last.629:
    #####: 2117:   function Last (Container : Vector) return Cursor is
        -: 2118:   begin
    #####: 2119:      if Is_Empty (Container) then
    #####: 2120:         return No_Element;
        -: 2121:      else
    #####: 2122:         return (Container'Unrestricted_Access, Container.Last);
        -: 2123:      end if;
        -: 2124:   end Last;
------------------
        -: 2125:
    #####: 2126:   function Last (Object : Iterator) return Cursor is
        -: 2127:   begin
        -: 2128:      --  The value of the iterator object's Index component influences the
        -: 2129:      --  behavior of the Last (and First) selector function.
        -: 2130:
        -: 2131:      --  When the Index component is No_Index, this means the iterator
        -: 2132:      --  object was constructed without a start expression, in which case the
        -: 2133:      --  (reverse) iteration starts from the (logical) beginning of the entire
        -: 2134:      --  sequence (corresponding to Container.Last, for a reverse iterator).
        -: 2135:
        -: 2136:      --  Otherwise, this is iteration over a partial sequence of items.
        -: 2137:      --  When the Index component is not No_Index, the iterator object was
        -: 2138:      --  constructed with a start expression, that specifies the position
        -: 2139:      --  from which the (reverse) partial iteration begins.
        -: 2140:
    #####: 2141:      if Object.Index = No_Index then
    #####: 2142:         return Last (Object.Container.all);
        -: 2143:      else
    #####: 2144:         return Cursor'(Object.Container, Object.Index);
        -: 2145:      end if;
        -: 2146:   end Last;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__last__3.2:
    #####: 2126:   function Last (Object : Iterator) return Cursor is
        -: 2127:   begin
        -: 2128:      --  The value of the iterator object's Index component influences the
        -: 2129:      --  behavior of the Last (and First) selector function.
        -: 2130:
        -: 2131:      --  When the Index component is No_Index, this means the iterator
        -: 2132:      --  object was constructed without a start expression, in which case the
        -: 2133:      --  (reverse) iteration starts from the (logical) beginning of the entire
        -: 2134:      --  sequence (corresponding to Container.Last, for a reverse iterator).
        -: 2135:
        -: 2136:      --  Otherwise, this is iteration over a partial sequence of items.
        -: 2137:      --  When the Index component is not No_Index, the iterator object was
        -: 2138:      --  constructed with a start expression, that specifies the position
        -: 2139:      --  from which the (reverse) partial iteration begins.
        -: 2140:
    #####: 2141:      if Object.Index = No_Index then
    #####: 2142:         return Last (Object.Container.all);
        -: 2143:      else
    #####: 2144:         return Cursor'(Object.Container, Object.Index);
        -: 2145:      end if;
        -: 2146:   end Last;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__last__3.47:
    #####: 2126:   function Last (Object : Iterator) return Cursor is
        -: 2127:   begin
        -: 2128:      --  The value of the iterator object's Index component influences the
        -: 2129:      --  behavior of the Last (and First) selector function.
        -: 2130:
        -: 2131:      --  When the Index component is No_Index, this means the iterator
        -: 2132:      --  object was constructed without a start expression, in which case the
        -: 2133:      --  (reverse) iteration starts from the (logical) beginning of the entire
        -: 2134:      --  sequence (corresponding to Container.Last, for a reverse iterator).
        -: 2135:
        -: 2136:      --  Otherwise, this is iteration over a partial sequence of items.
        -: 2137:      --  When the Index component is not No_Index, the iterator object was
        -: 2138:      --  constructed with a start expression, that specifies the position
        -: 2139:      --  from which the (reverse) partial iteration begins.
        -: 2140:
    #####: 2141:      if Object.Index = No_Index then
    #####: 2142:         return Last (Object.Container.all);
        -: 2143:      else
    #####: 2144:         return Cursor'(Object.Container, Object.Index);
        -: 2145:      end if;
        -: 2146:   end Last;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__last__3.361:
    #####: 2126:   function Last (Object : Iterator) return Cursor is
        -: 2127:   begin
        -: 2128:      --  The value of the iterator object's Index component influences the
        -: 2129:      --  behavior of the Last (and First) selector function.
        -: 2130:
        -: 2131:      --  When the Index component is No_Index, this means the iterator
        -: 2132:      --  object was constructed without a start expression, in which case the
        -: 2133:      --  (reverse) iteration starts from the (logical) beginning of the entire
        -: 2134:      --  sequence (corresponding to Container.Last, for a reverse iterator).
        -: 2135:
        -: 2136:      --  Otherwise, this is iteration over a partial sequence of items.
        -: 2137:      --  When the Index component is not No_Index, the iterator object was
        -: 2138:      --  constructed with a start expression, that specifies the position
        -: 2139:      --  from which the (reverse) partial iteration begins.
        -: 2140:
    #####: 2141:      if Object.Index = No_Index then
    #####: 2142:         return Last (Object.Container.all);
        -: 2143:      else
    #####: 2144:         return Cursor'(Object.Container, Object.Index);
        -: 2145:      end if;
        -: 2146:   end Last;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__last__3.406:
    #####: 2126:   function Last (Object : Iterator) return Cursor is
        -: 2127:   begin
        -: 2128:      --  The value of the iterator object's Index component influences the
        -: 2129:      --  behavior of the Last (and First) selector function.
        -: 2130:
        -: 2131:      --  When the Index component is No_Index, this means the iterator
        -: 2132:      --  object was constructed without a start expression, in which case the
        -: 2133:      --  (reverse) iteration starts from the (logical) beginning of the entire
        -: 2134:      --  sequence (corresponding to Container.Last, for a reverse iterator).
        -: 2135:
        -: 2136:      --  Otherwise, this is iteration over a partial sequence of items.
        -: 2137:      --  When the Index component is not No_Index, the iterator object was
        -: 2138:      --  constructed with a start expression, that specifies the position
        -: 2139:      --  from which the (reverse) partial iteration begins.
        -: 2140:
    #####: 2141:      if Object.Index = No_Index then
    #####: 2142:         return Last (Object.Container.all);
        -: 2143:      else
    #####: 2144:         return Cursor'(Object.Container, Object.Index);
        -: 2145:      end if;
        -: 2146:   end Last;
------------------
        -: 2147:
        -: 2148:   ------------------
        -: 2149:   -- Last_Element --
        -: 2150:   ------------------
        -: 2151:
    #####: 2152:   function Last_Element (Container : Vector) return Element_Type is
        -: 2153:   begin
    #####: 2154:      if Checks and then Container.Last = No_Index then
    #####: 2155:         raise Constraint_Error with "Container is empty";
        -: 2156:      else
    #####: 2157:         return Container.Elements.EA (Container.Last);
        -: 2158:      end if;
        -: 2159:   end Last_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__last_element.140:
    #####: 2152:   function Last_Element (Container : Vector) return Element_Type is
        -: 2153:   begin
    #####: 2154:      if Checks and then Container.Last = No_Index then
    #####: 2155:         raise Constraint_Error with "Container is empty";
        -: 2156:      else
    #####: 2157:         return Container.Elements.EA (Container.Last);
        -: 2158:      end if;
        -: 2159:   end Last_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__last_element.269:
    #####: 2152:   function Last_Element (Container : Vector) return Element_Type is
        -: 2153:   begin
    #####: 2154:      if Checks and then Container.Last = No_Index then
    #####: 2155:         raise Constraint_Error with "Container is empty";
        -: 2156:      else
    #####: 2157:         return Container.Elements.EA (Container.Last);
        -: 2158:      end if;
        -: 2159:   end Last_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__last_element.499:
    #####: 2152:   function Last_Element (Container : Vector) return Element_Type is
        -: 2153:   begin
    #####: 2154:      if Checks and then Container.Last = No_Index then
    #####: 2155:         raise Constraint_Error with "Container is empty";
        -: 2156:      else
    #####: 2157:         return Container.Elements.EA (Container.Last);
        -: 2158:      end if;
        -: 2159:   end Last_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__last_element.628:
    #####: 2152:   function Last_Element (Container : Vector) return Element_Type is
        -: 2153:   begin
    #####: 2154:      if Checks and then Container.Last = No_Index then
    #####: 2155:         raise Constraint_Error with "Container is empty";
        -: 2156:      else
    #####: 2157:         return Container.Elements.EA (Container.Last);
        -: 2158:      end if;
        -: 2159:   end Last_Element;
------------------
        -: 2160:
        -: 2161:   ----------------
        -: 2162:   -- Last_Index --
        -: 2163:   ----------------
        -: 2164:
    #####: 2165:   function Last_Index (Container : Vector) return Extended_Index is
        -: 2166:   begin
    #####: 2167:      return Container.Last;
        -: 2168:   end Last_Index;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__last_index.139:
    #####: 2165:   function Last_Index (Container : Vector) return Extended_Index is
        -: 2166:   begin
    #####: 2167:      return Container.Last;
        -: 2168:   end Last_Index;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__last_index.268:
    #####: 2165:   function Last_Index (Container : Vector) return Extended_Index is
        -: 2166:   begin
    #####: 2167:      return Container.Last;
        -: 2168:   end Last_Index;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__last_index.498:
    #####: 2165:   function Last_Index (Container : Vector) return Extended_Index is
        -: 2166:   begin
    #####: 2167:      return Container.Last;
        -: 2168:   end Last_Index;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__last_index.627:
    #####: 2165:   function Last_Index (Container : Vector) return Extended_Index is
        -: 2166:   begin
    #####: 2167:      return Container.Last;
        -: 2168:   end Last_Index;
------------------
        -: 2169:
        -: 2170:   ------------
        -: 2171:   -- Length --
        -: 2172:   ------------
        -: 2173:
    #####: 2174:   function Length (Container : Vector) return Count_Type is
    #####: 2175:      L : constant Index_Type'Base := Container.Last;
    #####: 2176:      F : constant Index_Type := Index_Type'First;
        -: 2177:
        -: 2178:   begin
        -: 2179:      --  The base range of the index type (Index_Type'Base) might not include
        -: 2180:      --  all values for length (Count_Type). Contrariwise, the index type
        -: 2181:      --  might include values outside the range of length.  Hence we use
        -: 2182:      --  whatever type is wider for intermediate values when calculating
        -: 2183:      --  length. Note that no matter what the index type is, the maximum
        -: 2184:      --  length to which a vector is allowed to grow is always the minimum
        -: 2185:      --  of Count_Type'Last and (IT'Last - IT'First + 1).
        -: 2186:
        -: 2187:      --  For example, an Index_Type with range -127 .. 127 is only guaranteed
        -: 2188:      --  to have a base range of -128 .. 127, but the corresponding vector
        -: 2189:      --  would have lengths in the range 0 .. 255. In this case we would need
        -: 2190:      --  to use Count_Type'Base for intermediate values.
        -: 2191:
        -: 2192:      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The
        -: 2193:      --  vector would have a maximum length of 10, but the index values lie
        -: 2194:      --  outside the range of Count_Type (which is only 32 bits). In this
        -: 2195:      --  case we would need to use Index_Type'Base for intermediate values.
        -: 2196:
        -: 2197:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####: 2198:         return Count_Type'Base (L) - Count_Type'Base (F) + 1;
        -: 2199:      else
        -: 2200:         return Count_Type (L - F + 1);
        -: 2201:      end if;
        -: 2202:   end Length;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__length.138:
    #####: 2174:   function Length (Container : Vector) return Count_Type is
    #####: 2175:      L : constant Index_Type'Base := Container.Last;
    #####: 2176:      F : constant Index_Type := Index_Type'First;
        -: 2177:
        -: 2178:   begin
        -: 2179:      --  The base range of the index type (Index_Type'Base) might not include
        -: 2180:      --  all values for length (Count_Type). Contrariwise, the index type
        -: 2181:      --  might include values outside the range of length.  Hence we use
        -: 2182:      --  whatever type is wider for intermediate values when calculating
        -: 2183:      --  length. Note that no matter what the index type is, the maximum
        -: 2184:      --  length to which a vector is allowed to grow is always the minimum
        -: 2185:      --  of Count_Type'Last and (IT'Last - IT'First + 1).
        -: 2186:
        -: 2187:      --  For example, an Index_Type with range -127 .. 127 is only guaranteed
        -: 2188:      --  to have a base range of -128 .. 127, but the corresponding vector
        -: 2189:      --  would have lengths in the range 0 .. 255. In this case we would need
        -: 2190:      --  to use Count_Type'Base for intermediate values.
        -: 2191:
        -: 2192:      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The
        -: 2193:      --  vector would have a maximum length of 10, but the index values lie
        -: 2194:      --  outside the range of Count_Type (which is only 32 bits). In this
        -: 2195:      --  case we would need to use Index_Type'Base for intermediate values.
        -: 2196:
        -: 2197:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####: 2198:         return Count_Type'Base (L) - Count_Type'Base (F) + 1;
        -: 2199:      else
        -: 2200:         return Count_Type (L - F + 1);
        -: 2201:      end if;
        -: 2202:   end Length;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__length.267:
    #####: 2174:   function Length (Container : Vector) return Count_Type is
    #####: 2175:      L : constant Index_Type'Base := Container.Last;
    #####: 2176:      F : constant Index_Type := Index_Type'First;
        -: 2177:
        -: 2178:   begin
        -: 2179:      --  The base range of the index type (Index_Type'Base) might not include
        -: 2180:      --  all values for length (Count_Type). Contrariwise, the index type
        -: 2181:      --  might include values outside the range of length.  Hence we use
        -: 2182:      --  whatever type is wider for intermediate values when calculating
        -: 2183:      --  length. Note that no matter what the index type is, the maximum
        -: 2184:      --  length to which a vector is allowed to grow is always the minimum
        -: 2185:      --  of Count_Type'Last and (IT'Last - IT'First + 1).
        -: 2186:
        -: 2187:      --  For example, an Index_Type with range -127 .. 127 is only guaranteed
        -: 2188:      --  to have a base range of -128 .. 127, but the corresponding vector
        -: 2189:      --  would have lengths in the range 0 .. 255. In this case we would need
        -: 2190:      --  to use Count_Type'Base for intermediate values.
        -: 2191:
        -: 2192:      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The
        -: 2193:      --  vector would have a maximum length of 10, but the index values lie
        -: 2194:      --  outside the range of Count_Type (which is only 32 bits). In this
        -: 2195:      --  case we would need to use Index_Type'Base for intermediate values.
        -: 2196:
        -: 2197:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####: 2198:         return Count_Type'Base (L) - Count_Type'Base (F) + 1;
        -: 2199:      else
        -: 2200:         return Count_Type (L - F + 1);
        -: 2201:      end if;
        -: 2202:   end Length;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__length.497:
    #####: 2174:   function Length (Container : Vector) return Count_Type is
    #####: 2175:      L : constant Index_Type'Base := Container.Last;
    #####: 2176:      F : constant Index_Type := Index_Type'First;
        -: 2177:
        -: 2178:   begin
        -: 2179:      --  The base range of the index type (Index_Type'Base) might not include
        -: 2180:      --  all values for length (Count_Type). Contrariwise, the index type
        -: 2181:      --  might include values outside the range of length.  Hence we use
        -: 2182:      --  whatever type is wider for intermediate values when calculating
        -: 2183:      --  length. Note that no matter what the index type is, the maximum
        -: 2184:      --  length to which a vector is allowed to grow is always the minimum
        -: 2185:      --  of Count_Type'Last and (IT'Last - IT'First + 1).
        -: 2186:
        -: 2187:      --  For example, an Index_Type with range -127 .. 127 is only guaranteed
        -: 2188:      --  to have a base range of -128 .. 127, but the corresponding vector
        -: 2189:      --  would have lengths in the range 0 .. 255. In this case we would need
        -: 2190:      --  to use Count_Type'Base for intermediate values.
        -: 2191:
        -: 2192:      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The
        -: 2193:      --  vector would have a maximum length of 10, but the index values lie
        -: 2194:      --  outside the range of Count_Type (which is only 32 bits). In this
        -: 2195:      --  case we would need to use Index_Type'Base for intermediate values.
        -: 2196:
        -: 2197:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####: 2198:         return Count_Type'Base (L) - Count_Type'Base (F) + 1;
        -: 2199:      else
        -: 2200:         return Count_Type (L - F + 1);
        -: 2201:      end if;
        -: 2202:   end Length;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__length.626:
    #####: 2174:   function Length (Container : Vector) return Count_Type is
    #####: 2175:      L : constant Index_Type'Base := Container.Last;
    #####: 2176:      F : constant Index_Type := Index_Type'First;
        -: 2177:
        -: 2178:   begin
        -: 2179:      --  The base range of the index type (Index_Type'Base) might not include
        -: 2180:      --  all values for length (Count_Type). Contrariwise, the index type
        -: 2181:      --  might include values outside the range of length.  Hence we use
        -: 2182:      --  whatever type is wider for intermediate values when calculating
        -: 2183:      --  length. Note that no matter what the index type is, the maximum
        -: 2184:      --  length to which a vector is allowed to grow is always the minimum
        -: 2185:      --  of Count_Type'Last and (IT'Last - IT'First + 1).
        -: 2186:
        -: 2187:      --  For example, an Index_Type with range -127 .. 127 is only guaranteed
        -: 2188:      --  to have a base range of -128 .. 127, but the corresponding vector
        -: 2189:      --  would have lengths in the range 0 .. 255. In this case we would need
        -: 2190:      --  to use Count_Type'Base for intermediate values.
        -: 2191:
        -: 2192:      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The
        -: 2193:      --  vector would have a maximum length of 10, but the index values lie
        -: 2194:      --  outside the range of Count_Type (which is only 32 bits). In this
        -: 2195:      --  case we would need to use Index_Type'Base for intermediate values.
        -: 2196:
        -: 2197:      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then
    #####: 2198:         return Count_Type'Base (L) - Count_Type'Base (F) + 1;
        -: 2199:      else
        -: 2200:         return Count_Type (L - F + 1);
        -: 2201:      end if;
        -: 2202:   end Length;
------------------
        -: 2203:
        -: 2204:   ----------
        -: 2205:   -- Move --
        -: 2206:   ----------
        -: 2207:
    #####: 2208:   procedure Move
        -: 2209:     (Target : in out Vector;
        -: 2210:      Source : in out Vector)
        -: 2211:   is
        -: 2212:   begin
    #####: 2213:      if Target'Address = Source'Address then
    #####: 2214:         return;
        -: 2215:      end if;
        -: 2216:
    #####: 2217:      TC_Check (Target.TC);
    #####: 2218:      TC_Check (Source.TC);
        -: 2219:
        -: 2220:      declare
    #####: 2221:         Target_Elements : constant Elements_Access := Target.Elements;
        -: 2222:      begin
    #####: 2223:         Target.Elements := Source.Elements;
    #####: 2224:         Source.Elements := Target_Elements;
        -: 2225:      end;
        -: 2226:
    #####: 2227:      Target.Last := Source.Last;
    #####: 2228:      Source.Last := No_Index;
        -: 2229:   end Move;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__move.137:
    #####: 2208:   procedure Move
        -: 2209:     (Target : in out Vector;
        -: 2210:      Source : in out Vector)
        -: 2211:   is
        -: 2212:   begin
    #####: 2213:      if Target'Address = Source'Address then
    #####: 2214:         return;
        -: 2215:      end if;
        -: 2216:
    #####: 2217:      TC_Check (Target.TC);
    #####: 2218:      TC_Check (Source.TC);
        -: 2219:
        -: 2220:      declare
    #####: 2221:         Target_Elements : constant Elements_Access := Target.Elements;
        -: 2222:      begin
    #####: 2223:         Target.Elements := Source.Elements;
    #####: 2224:         Source.Elements := Target_Elements;
        -: 2225:      end;
        -: 2226:
    #####: 2227:      Target.Last := Source.Last;
    #####: 2228:      Source.Last := No_Index;
        -: 2229:   end Move;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__move.266:
    #####: 2208:   procedure Move
        -: 2209:     (Target : in out Vector;
        -: 2210:      Source : in out Vector)
        -: 2211:   is
        -: 2212:   begin
    #####: 2213:      if Target'Address = Source'Address then
    #####: 2214:         return;
        -: 2215:      end if;
        -: 2216:
    #####: 2217:      TC_Check (Target.TC);
    #####: 2218:      TC_Check (Source.TC);
        -: 2219:
        -: 2220:      declare
    #####: 2221:         Target_Elements : constant Elements_Access := Target.Elements;
        -: 2222:      begin
    #####: 2223:         Target.Elements := Source.Elements;
    #####: 2224:         Source.Elements := Target_Elements;
        -: 2225:      end;
        -: 2226:
    #####: 2227:      Target.Last := Source.Last;
    #####: 2228:      Source.Last := No_Index;
        -: 2229:   end Move;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__move.496:
    #####: 2208:   procedure Move
        -: 2209:     (Target : in out Vector;
        -: 2210:      Source : in out Vector)
        -: 2211:   is
        -: 2212:   begin
    #####: 2213:      if Target'Address = Source'Address then
    #####: 2214:         return;
        -: 2215:      end if;
        -: 2216:
    #####: 2217:      TC_Check (Target.TC);
    #####: 2218:      TC_Check (Source.TC);
        -: 2219:
        -: 2220:      declare
    #####: 2221:         Target_Elements : constant Elements_Access := Target.Elements;
        -: 2222:      begin
    #####: 2223:         Target.Elements := Source.Elements;
    #####: 2224:         Source.Elements := Target_Elements;
        -: 2225:      end;
        -: 2226:
    #####: 2227:      Target.Last := Source.Last;
    #####: 2228:      Source.Last := No_Index;
        -: 2229:   end Move;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__move.625:
    #####: 2208:   procedure Move
        -: 2209:     (Target : in out Vector;
        -: 2210:      Source : in out Vector)
        -: 2211:   is
        -: 2212:   begin
    #####: 2213:      if Target'Address = Source'Address then
    #####: 2214:         return;
        -: 2215:      end if;
        -: 2216:
    #####: 2217:      TC_Check (Target.TC);
    #####: 2218:      TC_Check (Source.TC);
        -: 2219:
        -: 2220:      declare
    #####: 2221:         Target_Elements : constant Elements_Access := Target.Elements;
        -: 2222:      begin
    #####: 2223:         Target.Elements := Source.Elements;
    #####: 2224:         Source.Elements := Target_Elements;
        -: 2225:      end;
        -: 2226:
    #####: 2227:      Target.Last := Source.Last;
    #####: 2228:      Source.Last := No_Index;
        -: 2229:   end Move;
------------------
        -: 2230:
        -: 2231:   ----------
        -: 2232:   -- Next --
        -: 2233:   ----------
        -: 2234:
    #####: 2235:   function Next (Position : Cursor) return Cursor is
        -: 2236:   begin
    #####: 2237:      if Position.Container = null then
    #####: 2238:         return No_Element;
    #####: 2239:      elsif Position.Index < Position.Container.Last then
    #####: 2240:         return (Position.Container, Position.Index + 1);
        -: 2241:      else
    #####: 2242:         return No_Element;
        -: 2243:      end if;
        -: 2244:   end Next;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__next.136:
    #####: 2235:   function Next (Position : Cursor) return Cursor is
        -: 2236:   begin
    #####: 2237:      if Position.Container = null then
    #####: 2238:         return No_Element;
    #####: 2239:      elsif Position.Index < Position.Container.Last then
    #####: 2240:         return (Position.Container, Position.Index + 1);
        -: 2241:      else
    #####: 2242:         return No_Element;
        -: 2243:      end if;
        -: 2244:   end Next;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__next.265:
    #####: 2235:   function Next (Position : Cursor) return Cursor is
        -: 2236:   begin
    #####: 2237:      if Position.Container = null then
    #####: 2238:         return No_Element;
    #####: 2239:      elsif Position.Index < Position.Container.Last then
    #####: 2240:         return (Position.Container, Position.Index + 1);
        -: 2241:      else
    #####: 2242:         return No_Element;
        -: 2243:      end if;
        -: 2244:   end Next;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__next.495:
    #####: 2235:   function Next (Position : Cursor) return Cursor is
        -: 2236:   begin
    #####: 2237:      if Position.Container = null then
    #####: 2238:         return No_Element;
    #####: 2239:      elsif Position.Index < Position.Container.Last then
    #####: 2240:         return (Position.Container, Position.Index + 1);
        -: 2241:      else
    #####: 2242:         return No_Element;
        -: 2243:      end if;
        -: 2244:   end Next;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__next.624:
    #####: 2235:   function Next (Position : Cursor) return Cursor is
        -: 2236:   begin
    #####: 2237:      if Position.Container = null then
    #####: 2238:         return No_Element;
    #####: 2239:      elsif Position.Index < Position.Container.Last then
    #####: 2240:         return (Position.Container, Position.Index + 1);
        -: 2241:      else
    #####: 2242:         return No_Element;
        -: 2243:      end if;
        -: 2244:   end Next;
------------------
        -: 2245:
    #####: 2246:   function Next (Object : Iterator; Position : Cursor) return Cursor is
        -: 2247:   begin
    #####: 2248:      if Position.Container = null then
    #####: 2249:         return No_Element;
    #####: 2250:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2251:         raise Program_Error with
        -: 2252:           "Position cursor of Next designates wrong vector";
        -: 2253:      else
    #####: 2254:         return Next (Position);
        -: 2255:      end if;
        -: 2256:   end Next;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__next__4.4:
    #####: 2246:   function Next (Object : Iterator; Position : Cursor) return Cursor is
        -: 2247:   begin
    #####: 2248:      if Position.Container = null then
    #####: 2249:         return No_Element;
    #####: 2250:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2251:         raise Program_Error with
        -: 2252:           "Position cursor of Next designates wrong vector";
        -: 2253:      else
    #####: 2254:         return Next (Position);
        -: 2255:      end if;
        -: 2256:   end Next;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__next__4.49:
    #####: 2246:   function Next (Object : Iterator; Position : Cursor) return Cursor is
        -: 2247:   begin
    #####: 2248:      if Position.Container = null then
    #####: 2249:         return No_Element;
    #####: 2250:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2251:         raise Program_Error with
        -: 2252:           "Position cursor of Next designates wrong vector";
        -: 2253:      else
    #####: 2254:         return Next (Position);
        -: 2255:      end if;
        -: 2256:   end Next;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__next__4.363:
    #####: 2246:   function Next (Object : Iterator; Position : Cursor) return Cursor is
        -: 2247:   begin
    #####: 2248:      if Position.Container = null then
    #####: 2249:         return No_Element;
    #####: 2250:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2251:         raise Program_Error with
        -: 2252:           "Position cursor of Next designates wrong vector";
        -: 2253:      else
    #####: 2254:         return Next (Position);
        -: 2255:      end if;
        -: 2256:   end Next;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__next__4.408:
    #####: 2246:   function Next (Object : Iterator; Position : Cursor) return Cursor is
        -: 2247:   begin
    #####: 2248:      if Position.Container = null then
    #####: 2249:         return No_Element;
    #####: 2250:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2251:         raise Program_Error with
        -: 2252:           "Position cursor of Next designates wrong vector";
        -: 2253:      else
    #####: 2254:         return Next (Position);
        -: 2255:      end if;
        -: 2256:   end Next;
------------------
        -: 2257:
    #####: 2258:   procedure Next (Position : in out Cursor) is
        -: 2259:   begin
    #####: 2260:      if Position.Container = null then
    #####: 2261:         return;
    #####: 2262:      elsif Position.Index < Position.Container.Last then
    #####: 2263:         Position.Index := Position.Index + 1;
        -: 2264:      else
    #####: 2265:         Position := No_Element;
        -: 2266:      end if;
    #####: 2267:   end Next;
        -: 2268:
        -: 2269:   -------------
        -: 2270:   -- Prepend --
        -: 2271:   -------------
        -: 2272:
    #####: 2273:   procedure Prepend
        -: 2274:     (Container : in out Vector;
        -: 2275:      New_Item  : Element_Type;
        -: 2276:      Count     : Count_Type := 1)
        -: 2277:   is
        -: 2278:   begin
    #####: 2279:      Insert (Container, Index_Type'First, New_Item, Count);
    #####: 2280:   end Prepend;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__prepend__2.135:
    #####: 2273:   procedure Prepend
        -: 2274:     (Container : in out Vector;
        -: 2275:      New_Item  : Element_Type;
        -: 2276:      Count     : Count_Type := 1)
        -: 2277:   is
        -: 2278:   begin
    #####: 2279:      Insert (Container, Index_Type'First, New_Item, Count);
    #####: 2280:   end Prepend;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__prepend__2.264:
    #####: 2273:   procedure Prepend
        -: 2274:     (Container : in out Vector;
        -: 2275:      New_Item  : Element_Type;
        -: 2276:      Count     : Count_Type := 1)
        -: 2277:   is
        -: 2278:   begin
    #####: 2279:      Insert (Container, Index_Type'First, New_Item, Count);
    #####: 2280:   end Prepend;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__prepend__2.494:
    #####: 2273:   procedure Prepend
        -: 2274:     (Container : in out Vector;
        -: 2275:      New_Item  : Element_Type;
        -: 2276:      Count     : Count_Type := 1)
        -: 2277:   is
        -: 2278:   begin
    #####: 2279:      Insert (Container, Index_Type'First, New_Item, Count);
    #####: 2280:   end Prepend;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__prepend__2.623:
    #####: 2273:   procedure Prepend
        -: 2274:     (Container : in out Vector;
        -: 2275:      New_Item  : Element_Type;
        -: 2276:      Count     : Count_Type := 1)
        -: 2277:   is
        -: 2278:   begin
    #####: 2279:      Insert (Container, Index_Type'First, New_Item, Count);
    #####: 2280:   end Prepend;
------------------
        -: 2281:
        -: 2282:   --------------------
        -: 2283:   -- Prepend_Vector --
        -: 2284:   --------------------
        -: 2285:
    #####: 2286:   procedure Prepend_Vector (Container : in out Vector; New_Item : Vector) is
        -: 2287:   begin
    #####: 2288:      Insert_Vector (Container, Index_Type'First, New_Item);
    #####: 2289:   end Prepend_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__prepend_vector.134:
    #####: 2286:   procedure Prepend_Vector (Container : in out Vector; New_Item : Vector) is
        -: 2287:   begin
    #####: 2288:      Insert_Vector (Container, Index_Type'First, New_Item);
    #####: 2289:   end Prepend_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__prepend_vector.263:
    #####: 2286:   procedure Prepend_Vector (Container : in out Vector; New_Item : Vector) is
        -: 2287:   begin
    #####: 2288:      Insert_Vector (Container, Index_Type'First, New_Item);
    #####: 2289:   end Prepend_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__prepend_vector.493:
    #####: 2286:   procedure Prepend_Vector (Container : in out Vector; New_Item : Vector) is
        -: 2287:   begin
    #####: 2288:      Insert_Vector (Container, Index_Type'First, New_Item);
    #####: 2289:   end Prepend_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__prepend_vector.622:
    #####: 2286:   procedure Prepend_Vector (Container : in out Vector; New_Item : Vector) is
        -: 2287:   begin
    #####: 2288:      Insert_Vector (Container, Index_Type'First, New_Item);
    #####: 2289:   end Prepend_Vector;
------------------
        -: 2290:
        -: 2291:   --------------
        -: 2292:   -- Previous --
        -: 2293:   --------------
        -: 2294:
    #####: 2295:   function Previous (Position : Cursor) return Cursor is
        -: 2296:   begin
    #####: 2297:      if Position.Container = null then
    #####: 2298:         return No_Element;
    #####: 2299:      elsif Position.Index > Index_Type'First then
    #####: 2300:         return (Position.Container, Position.Index - 1);
        -: 2301:      else
    #####: 2302:         return No_Element;
        -: 2303:      end if;
        -: 2304:   end Previous;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__previous.133:
    #####: 2295:   function Previous (Position : Cursor) return Cursor is
        -: 2296:   begin
    #####: 2297:      if Position.Container = null then
    #####: 2298:         return No_Element;
    #####: 2299:      elsif Position.Index > Index_Type'First then
    #####: 2300:         return (Position.Container, Position.Index - 1);
        -: 2301:      else
    #####: 2302:         return No_Element;
        -: 2303:      end if;
        -: 2304:   end Previous;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__previous.262:
    #####: 2295:   function Previous (Position : Cursor) return Cursor is
        -: 2296:   begin
    #####: 2297:      if Position.Container = null then
    #####: 2298:         return No_Element;
    #####: 2299:      elsif Position.Index > Index_Type'First then
    #####: 2300:         return (Position.Container, Position.Index - 1);
        -: 2301:      else
    #####: 2302:         return No_Element;
        -: 2303:      end if;
        -: 2304:   end Previous;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__previous.492:
    #####: 2295:   function Previous (Position : Cursor) return Cursor is
        -: 2296:   begin
    #####: 2297:      if Position.Container = null then
    #####: 2298:         return No_Element;
    #####: 2299:      elsif Position.Index > Index_Type'First then
    #####: 2300:         return (Position.Container, Position.Index - 1);
        -: 2301:      else
    #####: 2302:         return No_Element;
        -: 2303:      end if;
        -: 2304:   end Previous;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__previous.621:
    #####: 2295:   function Previous (Position : Cursor) return Cursor is
        -: 2296:   begin
    #####: 2297:      if Position.Container = null then
    #####: 2298:         return No_Element;
    #####: 2299:      elsif Position.Index > Index_Type'First then
    #####: 2300:         return (Position.Container, Position.Index - 1);
        -: 2301:      else
    #####: 2302:         return No_Element;
        -: 2303:      end if;
        -: 2304:   end Previous;
------------------
        -: 2305:
    #####: 2306:   function Previous (Object : Iterator; Position : Cursor) return Cursor is
        -: 2307:   begin
    #####: 2308:      if Position.Container = null then
    #####: 2309:         return No_Element;
    #####: 2310:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2311:         raise Program_Error with
        -: 2312:           "Position cursor of Previous designates wrong vector";
        -: 2313:      else
    #####: 2314:         return Previous (Position);
        -: 2315:      end if;
        -: 2316:   end Previous;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__previous__4.0:
    #####: 2306:   function Previous (Object : Iterator; Position : Cursor) return Cursor is
        -: 2307:   begin
    #####: 2308:      if Position.Container = null then
    #####: 2309:         return No_Element;
    #####: 2310:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2311:         raise Program_Error with
        -: 2312:           "Position cursor of Previous designates wrong vector";
        -: 2313:      else
    #####: 2314:         return Previous (Position);
        -: 2315:      end if;
        -: 2316:   end Previous;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__previous__4.45:
    #####: 2306:   function Previous (Object : Iterator; Position : Cursor) return Cursor is
        -: 2307:   begin
    #####: 2308:      if Position.Container = null then
    #####: 2309:         return No_Element;
    #####: 2310:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2311:         raise Program_Error with
        -: 2312:           "Position cursor of Previous designates wrong vector";
        -: 2313:      else
    #####: 2314:         return Previous (Position);
        -: 2315:      end if;
        -: 2316:   end Previous;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__previous__4.359:
    #####: 2306:   function Previous (Object : Iterator; Position : Cursor) return Cursor is
        -: 2307:   begin
    #####: 2308:      if Position.Container = null then
    #####: 2309:         return No_Element;
    #####: 2310:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2311:         raise Program_Error with
        -: 2312:           "Position cursor of Previous designates wrong vector";
        -: 2313:      else
    #####: 2314:         return Previous (Position);
        -: 2315:      end if;
        -: 2316:   end Previous;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__previous__4.404:
    #####: 2306:   function Previous (Object : Iterator; Position : Cursor) return Cursor is
        -: 2307:   begin
    #####: 2308:      if Position.Container = null then
    #####: 2309:         return No_Element;
    #####: 2310:      elsif Checks and then Position.Container /= Object.Container then
    #####: 2311:         raise Program_Error with
        -: 2312:           "Position cursor of Previous designates wrong vector";
        -: 2313:      else
    #####: 2314:         return Previous (Position);
        -: 2315:      end if;
        -: 2316:   end Previous;
------------------
        -: 2317:
        -: 2318:   procedure Previous (Position : in out Cursor) is
        -: 2319:   begin
        -: 2320:      if Position.Container = null then
        -: 2321:         return;
        -: 2322:      elsif Position.Index > Index_Type'First then
        -: 2323:         Position.Index := Position.Index - 1;
        -: 2324:      else
        -: 2325:         Position := No_Element;
        -: 2326:      end if;
        -: 2327:   end Previous;
        -: 2328:
        -: 2329:   ----------------------
        -: 2330:   -- Pseudo_Reference --
        -: 2331:   ----------------------
        -: 2332:
    #####: 2333:   function Pseudo_Reference
        -: 2334:     (Container : aliased Vector'Class) return Reference_Control_Type
        -: 2335:   is
    #####: 2336:      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;
        -: 2337:   begin
    #####: 2338:      return R : constant Reference_Control_Type := (Controlled with TC) do
    #####: 2339:         Busy (TC.all);
        -: 2340:      end return;
        -: 2341:   end Pseudo_Reference;
        -: 2342:
        -: 2343:   ---------------
        -: 2344:   -- Put_Image --
        -: 2345:   ---------------
        -: 2346:
    #####: 2347:   procedure Put_Image
        -: 2348:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector)
        -: 2349:   is
    #####: 2350:      First_Time : Boolean := True;
        -: 2351:      use System.Put_Images;
        -: 2352:   begin
    #####: 2353:      Array_Before (S);
        -: 2354:
    #####: 2355:      for X of V loop
    #####: 2356:         if First_Time then
    #####: 2357:            First_Time := False;
        -: 2358:         else
    #####: 2359:            Simple_Array_Between (S);
        -: 2360:         end if;
        -: 2361:
    #####: 2362:         Element_Type'Put_Image (S, X);
        -: 2363:      end loop;
        -: 2364:
    #####: 2365:      Array_After (S);
    #####: 2366:   end Put_Image;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__put_image.127:
    #####: 2347:   procedure Put_Image
        -: 2348:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector)
        -: 2349:   is
    #####: 2350:      First_Time : Boolean := True;
        -: 2351:      use System.Put_Images;
        -: 2352:   begin
    #####: 2353:      Array_Before (S);
        -: 2354:
    #####: 2355:      for X of V loop
    #####: 2356:         if First_Time then
    #####: 2357:            First_Time := False;
        -: 2358:         else
    #####: 2359:            Simple_Array_Between (S);
        -: 2360:         end if;
        -: 2361:
    #####: 2362:         Element_Type'Put_Image (S, X);
        -: 2363:      end loop;
        -: 2364:
    #####: 2365:      Array_After (S);
    #####: 2366:   end Put_Image;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__put_image.255:
    #####: 2347:   procedure Put_Image
        -: 2348:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector)
        -: 2349:   is
    #####: 2350:      First_Time : Boolean := True;
        -: 2351:      use System.Put_Images;
        -: 2352:   begin
    #####: 2353:      Array_Before (S);
        -: 2354:
    #####: 2355:      for X of V loop
    #####: 2356:         if First_Time then
    #####: 2357:            First_Time := False;
        -: 2358:         else
    #####: 2359:            Simple_Array_Between (S);
        -: 2360:         end if;
        -: 2361:
    #####: 2362:         Element_Type'Put_Image (S, X);
        -: 2363:      end loop;
        -: 2364:
    #####: 2365:      Array_After (S);
    #####: 2366:   end Put_Image;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__put_image.486:
    #####: 2347:   procedure Put_Image
        -: 2348:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector)
        -: 2349:   is
    #####: 2350:      First_Time : Boolean := True;
        -: 2351:      use System.Put_Images;
        -: 2352:   begin
    #####: 2353:      Array_Before (S);
        -: 2354:
    #####: 2355:      for X of V loop
    #####: 2356:         if First_Time then
    #####: 2357:            First_Time := False;
        -: 2358:         else
    #####: 2359:            Simple_Array_Between (S);
        -: 2360:         end if;
        -: 2361:
    #####: 2362:         Element_Type'Put_Image (S, X);
        -: 2363:      end loop;
        -: 2364:
    #####: 2365:      Array_After (S);
    #####: 2366:   end Put_Image;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__put_image.614:
    #####: 2347:   procedure Put_Image
        -: 2348:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector)
        -: 2349:   is
    #####: 2350:      First_Time : Boolean := True;
        -: 2351:      use System.Put_Images;
        -: 2352:   begin
    #####: 2353:      Array_Before (S);
        -: 2354:
    #####: 2355:      for X of V loop
    #####: 2356:         if First_Time then
    #####: 2357:            First_Time := False;
        -: 2358:         else
    #####: 2359:            Simple_Array_Between (S);
        -: 2360:         end if;
        -: 2361:
    #####: 2362:         Element_Type'Put_Image (S, X);
        -: 2363:      end loop;
        -: 2364:
    #####: 2365:      Array_After (S);
    #####: 2366:   end Put_Image;
------------------
        -: 2367:
        -: 2368:   -------------------
        -: 2369:   -- Query_Element --
        -: 2370:   -------------------
        -: 2371:
    #####: 2372:   procedure Query_Element
        -: 2373:     (Container : Vector;
        -: 2374:      Index     : Index_Type;
        -: 2375:      Process   : not null access procedure (Element : Element_Type))
        -: 2376:   is
    #####: 2377:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2378:   begin
    #####: 2379:      if Checks and then Index > Container.Last then
    #####: 2380:         raise Constraint_Error with "Index is out of range";
        -: 2381:      end if;
        -: 2382:
    #####: 2383:      Process (Container.Elements.EA (Index));
    #####: 2384:   end Query_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__query_element.125:
    #####: 2372:   procedure Query_Element
        -: 2373:     (Container : Vector;
        -: 2374:      Index     : Index_Type;
        -: 2375:      Process   : not null access procedure (Element : Element_Type))
        -: 2376:   is
    #####: 2377:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2378:   begin
    #####: 2379:      if Checks and then Index > Container.Last then
    #####: 2380:         raise Constraint_Error with "Index is out of range";
        -: 2381:      end if;
        -: 2382:
    #####: 2383:      Process (Container.Elements.EA (Index));
    #####: 2384:   end Query_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__query_element.253:
    #####: 2372:   procedure Query_Element
        -: 2373:     (Container : Vector;
        -: 2374:      Index     : Index_Type;
        -: 2375:      Process   : not null access procedure (Element : Element_Type))
        -: 2376:   is
    #####: 2377:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2378:   begin
    #####: 2379:      if Checks and then Index > Container.Last then
    #####: 2380:         raise Constraint_Error with "Index is out of range";
        -: 2381:      end if;
        -: 2382:
    #####: 2383:      Process (Container.Elements.EA (Index));
    #####: 2384:   end Query_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__query_element.484:
    #####: 2372:   procedure Query_Element
        -: 2373:     (Container : Vector;
        -: 2374:      Index     : Index_Type;
        -: 2375:      Process   : not null access procedure (Element : Element_Type))
        -: 2376:   is
    #####: 2377:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2378:   begin
    #####: 2379:      if Checks and then Index > Container.Last then
    #####: 2380:         raise Constraint_Error with "Index is out of range";
        -: 2381:      end if;
        -: 2382:
    #####: 2383:      Process (Container.Elements.EA (Index));
    #####: 2384:   end Query_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__query_element.612:
    #####: 2372:   procedure Query_Element
        -: 2373:     (Container : Vector;
        -: 2374:      Index     : Index_Type;
        -: 2375:      Process   : not null access procedure (Element : Element_Type))
        -: 2376:   is
    #####: 2377:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2378:   begin
    #####: 2379:      if Checks and then Index > Container.Last then
    #####: 2380:         raise Constraint_Error with "Index is out of range";
        -: 2381:      end if;
        -: 2382:
    #####: 2383:      Process (Container.Elements.EA (Index));
    #####: 2384:   end Query_Element;
------------------
        -: 2385:
        -: 2386:   procedure Query_Element
        -: 2387:     (Position : Cursor;
        -: 2388:      Process  : not null access procedure (Element : Element_Type))
        -: 2389:   is
        -: 2390:   begin
        -: 2391:      if Checks and then Position.Container = null then
        -: 2392:         raise Constraint_Error with "Position cursor has no element";
        -: 2393:      else
        -: 2394:         Query_Element (Position.Container.all, Position.Index, Process);
        -: 2395:      end if;
        -: 2396:   end Query_Element;
        -: 2397:
        -: 2398:   ----------
        -: 2399:   -- Read --
        -: 2400:   ----------
        -: 2401:
    #####: 2402:   procedure Read
        -: 2403:     (Stream    : not null access Root_Stream_Type'Class;
        -: 2404:      Container : out Vector)
        -: 2405:   is
        -: 2406:      Length : Count_Type'Base;
    #####: 2407:      Last   : Index_Type'Base := No_Index;
        -: 2408:
        -: 2409:   begin
    #####: 2410:      Clear (Container);
        -: 2411:
    #####: 2412:      Count_Type'Base'Read (Stream, Length);
        -: 2413:
    #####: 2414:      if Length > Capacity (Container) then
    #####: 2415:         Reserve_Capacity (Container, Capacity => Length);
        -: 2416:      end if;
        -: 2417:
    #####: 2418:      for J in Count_Type range 1 .. Length loop
    #####: 2419:         Last := Last + 1;
    #####: 2420:         Element_Type'Read (Stream, Container.Elements.EA (Last));
    #####: 2421:         Container.Last := Last;
    #####: 2422:      end loop;
    #####: 2423:   end Read;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__read.124:
    #####: 2402:   procedure Read
        -: 2403:     (Stream    : not null access Root_Stream_Type'Class;
        -: 2404:      Container : out Vector)
        -: 2405:   is
        -: 2406:      Length : Count_Type'Base;
    #####: 2407:      Last   : Index_Type'Base := No_Index;
        -: 2408:
        -: 2409:   begin
    #####: 2410:      Clear (Container);
        -: 2411:
    #####: 2412:      Count_Type'Base'Read (Stream, Length);
        -: 2413:
    #####: 2414:      if Length > Capacity (Container) then
    #####: 2415:         Reserve_Capacity (Container, Capacity => Length);
        -: 2416:      end if;
        -: 2417:
    #####: 2418:      for J in Count_Type range 1 .. Length loop
    #####: 2419:         Last := Last + 1;
    #####: 2420:         Element_Type'Read (Stream, Container.Elements.EA (Last));
    #####: 2421:         Container.Last := Last;
    #####: 2422:      end loop;
    #####: 2423:   end Read;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__read.251:
    #####: 2402:   procedure Read
        -: 2403:     (Stream    : not null access Root_Stream_Type'Class;
        -: 2404:      Container : out Vector)
        -: 2405:   is
        -: 2406:      Length : Count_Type'Base;
    #####: 2407:      Last   : Index_Type'Base := No_Index;
        -: 2408:
        -: 2409:   begin
    #####: 2410:      Clear (Container);
        -: 2411:
    #####: 2412:      Count_Type'Base'Read (Stream, Length);
        -: 2413:
    #####: 2414:      if Length > Capacity (Container) then
    #####: 2415:         Reserve_Capacity (Container, Capacity => Length);
        -: 2416:      end if;
        -: 2417:
    #####: 2418:      for J in Count_Type range 1 .. Length loop
    #####: 2419:         Last := Last + 1;
    #####: 2420:         Element_Type'Read (Stream, Container.Elements.EA (Last));
    #####: 2421:         Container.Last := Last;
    #####: 2422:      end loop;
    #####: 2423:   end Read;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__read.483:
    #####: 2402:   procedure Read
        -: 2403:     (Stream    : not null access Root_Stream_Type'Class;
        -: 2404:      Container : out Vector)
        -: 2405:   is
        -: 2406:      Length : Count_Type'Base;
    #####: 2407:      Last   : Index_Type'Base := No_Index;
        -: 2408:
        -: 2409:   begin
    #####: 2410:      Clear (Container);
        -: 2411:
    #####: 2412:      Count_Type'Base'Read (Stream, Length);
        -: 2413:
    #####: 2414:      if Length > Capacity (Container) then
    #####: 2415:         Reserve_Capacity (Container, Capacity => Length);
        -: 2416:      end if;
        -: 2417:
    #####: 2418:      for J in Count_Type range 1 .. Length loop
    #####: 2419:         Last := Last + 1;
    #####: 2420:         Element_Type'Read (Stream, Container.Elements.EA (Last));
    #####: 2421:         Container.Last := Last;
    #####: 2422:      end loop;
    #####: 2423:   end Read;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__read.610:
    #####: 2402:   procedure Read
        -: 2403:     (Stream    : not null access Root_Stream_Type'Class;
        -: 2404:      Container : out Vector)
        -: 2405:   is
        -: 2406:      Length : Count_Type'Base;
    #####: 2407:      Last   : Index_Type'Base := No_Index;
        -: 2408:
        -: 2409:   begin
    #####: 2410:      Clear (Container);
        -: 2411:
    #####: 2412:      Count_Type'Base'Read (Stream, Length);
        -: 2413:
    #####: 2414:      if Length > Capacity (Container) then
    #####: 2415:         Reserve_Capacity (Container, Capacity => Length);
        -: 2416:      end if;
        -: 2417:
    #####: 2418:      for J in Count_Type range 1 .. Length loop
    #####: 2419:         Last := Last + 1;
    #####: 2420:         Element_Type'Read (Stream, Container.Elements.EA (Last));
    #####: 2421:         Container.Last := Last;
    #####: 2422:      end loop;
    #####: 2423:   end Read;
------------------
        -: 2424:
        -: 2425:   procedure Read
        -: 2426:     (Stream   : not null access Root_Stream_Type'Class;
        -: 2427:      Position : out Cursor)
        -: 2428:   is
        -: 2429:   begin
        -: 2430:      raise Program_Error with "attempt to stream vector cursor";
        -: 2431:   end Read;
        -: 2432:
        -: 2433:   procedure Read
        -: 2434:     (Stream : not null access Root_Stream_Type'Class;
        -: 2435:      Item   : out Reference_Type)
        -: 2436:   is
        -: 2437:   begin
        -: 2438:      raise Program_Error with "attempt to stream reference";
        -: 2439:   end Read;
        -: 2440:
        -: 2441:   procedure Read
        -: 2442:     (Stream : not null access Root_Stream_Type'Class;
        -: 2443:      Item   : out Constant_Reference_Type)
        -: 2444:   is
        -: 2445:   begin
        -: 2446:      raise Program_Error with "attempt to stream reference";
        -: 2447:   end Read;
        -: 2448:
        -: 2449:   ---------------
        -: 2450:   -- Reference --
        -: 2451:   ---------------
        -: 2452:
    #####: 2453:   function Reference
        -: 2454:     (Container : aliased in out Vector;
        -: 2455:      Position  : Cursor) return Reference_Type
        -: 2456:   is
        -: 2457:   begin
        -: 2458:      if Checks then
    #####: 2459:         if Position.Container = null then
    #####: 2460:            raise Constraint_Error with "Position cursor has no element";
        -: 2461:         end if;
        -: 2462:
    #####: 2463:         if Position.Container /= Container'Unrestricted_Access then
    #####: 2464:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2465:         end if;
        -: 2466:
    #####: 2467:         if Position.Index > Position.Container.Last then
    #####: 2468:            raise Constraint_Error with "Position cursor is out of range";
        -: 2469:         end if;
        -: 2470:      end if;
        -: 2471:
        -: 2472:      declare
    #####: 2473:         TC : constant Tamper_Counts_Access :=
        -: 2474:           Container.TC'Unrestricted_Access;
        -: 2475:      begin
    #####: 2476:         return R : constant Reference_Type :=
    #####: 2477:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####: 2478:            Control => (Controlled with TC))
        -: 2479:         do
    #####: 2480:            Busy (TC.all);
        -: 2481:         end return;
        -: 2482:      end;
        -: 2483:   end Reference;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reference.122:
    #####: 2453:   function Reference
        -: 2454:     (Container : aliased in out Vector;
        -: 2455:      Position  : Cursor) return Reference_Type
        -: 2456:   is
        -: 2457:   begin
        -: 2458:      if Checks then
    #####: 2459:         if Position.Container = null then
    #####: 2460:            raise Constraint_Error with "Position cursor has no element";
        -: 2461:         end if;
        -: 2462:
    #####: 2463:         if Position.Container /= Container'Unrestricted_Access then
    #####: 2464:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2465:         end if;
        -: 2466:
    #####: 2467:         if Position.Index > Position.Container.Last then
    #####: 2468:            raise Constraint_Error with "Position cursor is out of range";
        -: 2469:         end if;
        -: 2470:      end if;
        -: 2471:
        -: 2472:      declare
    #####: 2473:         TC : constant Tamper_Counts_Access :=
        -: 2474:           Container.TC'Unrestricted_Access;
        -: 2475:      begin
    #####: 2476:         return R : constant Reference_Type :=
    #####: 2477:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####: 2478:            Control => (Controlled with TC))
        -: 2479:         do
    #####: 2480:            Busy (TC.all);
        -: 2481:         end return;
        -: 2482:      end;
        -: 2483:   end Reference;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reference.249:
    #####: 2453:   function Reference
        -: 2454:     (Container : aliased in out Vector;
        -: 2455:      Position  : Cursor) return Reference_Type
        -: 2456:   is
        -: 2457:   begin
        -: 2458:      if Checks then
    #####: 2459:         if Position.Container = null then
    #####: 2460:            raise Constraint_Error with "Position cursor has no element";
        -: 2461:         end if;
        -: 2462:
    #####: 2463:         if Position.Container /= Container'Unrestricted_Access then
    #####: 2464:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2465:         end if;
        -: 2466:
    #####: 2467:         if Position.Index > Position.Container.Last then
    #####: 2468:            raise Constraint_Error with "Position cursor is out of range";
        -: 2469:         end if;
        -: 2470:      end if;
        -: 2471:
        -: 2472:      declare
    #####: 2473:         TC : constant Tamper_Counts_Access :=
        -: 2474:           Container.TC'Unrestricted_Access;
        -: 2475:      begin
    #####: 2476:         return R : constant Reference_Type :=
    #####: 2477:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####: 2478:            Control => (Controlled with TC))
        -: 2479:         do
    #####: 2480:            Busy (TC.all);
        -: 2481:         end return;
        -: 2482:      end;
        -: 2483:   end Reference;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reference.481:
    #####: 2453:   function Reference
        -: 2454:     (Container : aliased in out Vector;
        -: 2455:      Position  : Cursor) return Reference_Type
        -: 2456:   is
        -: 2457:   begin
        -: 2458:      if Checks then
    #####: 2459:         if Position.Container = null then
    #####: 2460:            raise Constraint_Error with "Position cursor has no element";
        -: 2461:         end if;
        -: 2462:
    #####: 2463:         if Position.Container /= Container'Unrestricted_Access then
    #####: 2464:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2465:         end if;
        -: 2466:
    #####: 2467:         if Position.Index > Position.Container.Last then
    #####: 2468:            raise Constraint_Error with "Position cursor is out of range";
        -: 2469:         end if;
        -: 2470:      end if;
        -: 2471:
        -: 2472:      declare
    #####: 2473:         TC : constant Tamper_Counts_Access :=
        -: 2474:           Container.TC'Unrestricted_Access;
        -: 2475:      begin
    #####: 2476:         return R : constant Reference_Type :=
    #####: 2477:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####: 2478:            Control => (Controlled with TC))
        -: 2479:         do
    #####: 2480:            Busy (TC.all);
        -: 2481:         end return;
        -: 2482:      end;
        -: 2483:   end Reference;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reference.608:
    #####: 2453:   function Reference
        -: 2454:     (Container : aliased in out Vector;
        -: 2455:      Position  : Cursor) return Reference_Type
        -: 2456:   is
        -: 2457:   begin
        -: 2458:      if Checks then
    #####: 2459:         if Position.Container = null then
    #####: 2460:            raise Constraint_Error with "Position cursor has no element";
        -: 2461:         end if;
        -: 2462:
    #####: 2463:         if Position.Container /= Container'Unrestricted_Access then
    #####: 2464:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2465:         end if;
        -: 2466:
    #####: 2467:         if Position.Index > Position.Container.Last then
    #####: 2468:            raise Constraint_Error with "Position cursor is out of range";
        -: 2469:         end if;
        -: 2470:      end if;
        -: 2471:
        -: 2472:      declare
    #####: 2473:         TC : constant Tamper_Counts_Access :=
        -: 2474:           Container.TC'Unrestricted_Access;
        -: 2475:      begin
    #####: 2476:         return R : constant Reference_Type :=
    #####: 2477:           (Element => Container.Elements.EA (Position.Index)'Access,
    #####: 2478:            Control => (Controlled with TC))
        -: 2479:         do
    #####: 2480:            Busy (TC.all);
        -: 2481:         end return;
        -: 2482:      end;
        -: 2483:   end Reference;
------------------
        -: 2484:
    #####: 2485:   function Reference
        -: 2486:     (Container : aliased in out Vector;
        -: 2487:      Index     : Index_Type) return Reference_Type
        -: 2488:   is
        -: 2489:   begin
    #####: 2490:      if Checks and then Index > Container.Last then
    #####: 2491:         raise Constraint_Error with "Index is out of range";
        -: 2492:      end if;
        -: 2493:
        -: 2494:      declare
    #####: 2495:         TC : constant Tamper_Counts_Access :=
        -: 2496:           Container.TC'Unrestricted_Access;
        -: 2497:      begin
    #####: 2498:         return R : constant Reference_Type :=
    #####: 2499:           (Element => Container.Elements.EA (Index)'Access,
    #####: 2500:            Control => (Controlled with TC))
        -: 2501:         do
    #####: 2502:            Busy (TC.all);
        -: 2503:         end return;
        -: 2504:      end;
        -: 2505:   end Reference;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reference__2.117:
    #####: 2485:   function Reference
        -: 2486:     (Container : aliased in out Vector;
        -: 2487:      Index     : Index_Type) return Reference_Type
        -: 2488:   is
        -: 2489:   begin
    #####: 2490:      if Checks and then Index > Container.Last then
    #####: 2491:         raise Constraint_Error with "Index is out of range";
        -: 2492:      end if;
        -: 2493:
        -: 2494:      declare
    #####: 2495:         TC : constant Tamper_Counts_Access :=
        -: 2496:           Container.TC'Unrestricted_Access;
        -: 2497:      begin
    #####: 2498:         return R : constant Reference_Type :=
    #####: 2499:           (Element => Container.Elements.EA (Index)'Access,
    #####: 2500:            Control => (Controlled with TC))
        -: 2501:         do
    #####: 2502:            Busy (TC.all);
        -: 2503:         end return;
        -: 2504:      end;
        -: 2505:   end Reference;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reference__2.244:
    #####: 2485:   function Reference
        -: 2486:     (Container : aliased in out Vector;
        -: 2487:      Index     : Index_Type) return Reference_Type
        -: 2488:   is
        -: 2489:   begin
    #####: 2490:      if Checks and then Index > Container.Last then
    #####: 2491:         raise Constraint_Error with "Index is out of range";
        -: 2492:      end if;
        -: 2493:
        -: 2494:      declare
    #####: 2495:         TC : constant Tamper_Counts_Access :=
        -: 2496:           Container.TC'Unrestricted_Access;
        -: 2497:      begin
    #####: 2498:         return R : constant Reference_Type :=
    #####: 2499:           (Element => Container.Elements.EA (Index)'Access,
    #####: 2500:            Control => (Controlled with TC))
        -: 2501:         do
    #####: 2502:            Busy (TC.all);
        -: 2503:         end return;
        -: 2504:      end;
        -: 2505:   end Reference;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reference__2.476:
    #####: 2485:   function Reference
        -: 2486:     (Container : aliased in out Vector;
        -: 2487:      Index     : Index_Type) return Reference_Type
        -: 2488:   is
        -: 2489:   begin
    #####: 2490:      if Checks and then Index > Container.Last then
    #####: 2491:         raise Constraint_Error with "Index is out of range";
        -: 2492:      end if;
        -: 2493:
        -: 2494:      declare
    #####: 2495:         TC : constant Tamper_Counts_Access :=
        -: 2496:           Container.TC'Unrestricted_Access;
        -: 2497:      begin
    #####: 2498:         return R : constant Reference_Type :=
    #####: 2499:           (Element => Container.Elements.EA (Index)'Access,
    #####: 2500:            Control => (Controlled with TC))
        -: 2501:         do
    #####: 2502:            Busy (TC.all);
        -: 2503:         end return;
        -: 2504:      end;
        -: 2505:   end Reference;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reference__2.603:
    #####: 2485:   function Reference
        -: 2486:     (Container : aliased in out Vector;
        -: 2487:      Index     : Index_Type) return Reference_Type
        -: 2488:   is
        -: 2489:   begin
    #####: 2490:      if Checks and then Index > Container.Last then
    #####: 2491:         raise Constraint_Error with "Index is out of range";
        -: 2492:      end if;
        -: 2493:
        -: 2494:      declare
    #####: 2495:         TC : constant Tamper_Counts_Access :=
        -: 2496:           Container.TC'Unrestricted_Access;
        -: 2497:      begin
    #####: 2498:         return R : constant Reference_Type :=
    #####: 2499:           (Element => Container.Elements.EA (Index)'Access,
    #####: 2500:            Control => (Controlled with TC))
        -: 2501:         do
    #####: 2502:            Busy (TC.all);
        -: 2503:         end return;
        -: 2504:      end;
        -: 2505:   end Reference;
------------------
        -: 2506:
        -: 2507:   ---------------------
        -: 2508:   -- Replace_Element --
        -: 2509:   ---------------------
        -: 2510:
    #####: 2511:   procedure Replace_Element
        -: 2512:     (Container : in out Vector;
        -: 2513:      Index     : Index_Type;
        -: 2514:      New_Item  : Element_Type)
        -: 2515:   is
        -: 2516:   begin
    #####: 2517:      TE_Check (Container.TC);
        -: 2518:
    #####: 2519:      if Checks and then Index > Container.Last then
    #####: 2520:         raise Constraint_Error with "Index is out of range";
        -: 2521:      end if;
        -: 2522:
    #####: 2523:      Container.Elements.EA (Index) := New_Item;
    #####: 2524:   end Replace_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__replace_element.116:
    #####: 2511:   procedure Replace_Element
        -: 2512:     (Container : in out Vector;
        -: 2513:      Index     : Index_Type;
        -: 2514:      New_Item  : Element_Type)
        -: 2515:   is
        -: 2516:   begin
    #####: 2517:      TE_Check (Container.TC);
        -: 2518:
    #####: 2519:      if Checks and then Index > Container.Last then
    #####: 2520:         raise Constraint_Error with "Index is out of range";
        -: 2521:      end if;
        -: 2522:
    #####: 2523:      Container.Elements.EA (Index) := New_Item;
    #####: 2524:   end Replace_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__replace_element.243:
    #####: 2511:   procedure Replace_Element
        -: 2512:     (Container : in out Vector;
        -: 2513:      Index     : Index_Type;
        -: 2514:      New_Item  : Element_Type)
        -: 2515:   is
        -: 2516:   begin
    #####: 2517:      TE_Check (Container.TC);
        -: 2518:
    #####: 2519:      if Checks and then Index > Container.Last then
    #####: 2520:         raise Constraint_Error with "Index is out of range";
        -: 2521:      end if;
        -: 2522:
    #####: 2523:      Container.Elements.EA (Index) := New_Item;
    #####: 2524:   end Replace_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__replace_element.475:
    #####: 2511:   procedure Replace_Element
        -: 2512:     (Container : in out Vector;
        -: 2513:      Index     : Index_Type;
        -: 2514:      New_Item  : Element_Type)
        -: 2515:   is
        -: 2516:   begin
    #####: 2517:      TE_Check (Container.TC);
        -: 2518:
    #####: 2519:      if Checks and then Index > Container.Last then
    #####: 2520:         raise Constraint_Error with "Index is out of range";
        -: 2521:      end if;
        -: 2522:
    #####: 2523:      Container.Elements.EA (Index) := New_Item;
    #####: 2524:   end Replace_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__replace_element.602:
    #####: 2511:   procedure Replace_Element
        -: 2512:     (Container : in out Vector;
        -: 2513:      Index     : Index_Type;
        -: 2514:      New_Item  : Element_Type)
        -: 2515:   is
        -: 2516:   begin
    #####: 2517:      TE_Check (Container.TC);
        -: 2518:
    #####: 2519:      if Checks and then Index > Container.Last then
    #####: 2520:         raise Constraint_Error with "Index is out of range";
        -: 2521:      end if;
        -: 2522:
    #####: 2523:      Container.Elements.EA (Index) := New_Item;
    #####: 2524:   end Replace_Element;
------------------
        -: 2525:
    #####: 2526:   procedure Replace_Element
        -: 2527:     (Container : in out Vector;
        -: 2528:      Position  : Cursor;
        -: 2529:      New_Item  : Element_Type)
        -: 2530:   is
        -: 2531:   begin
    #####: 2532:      TE_Check (Container.TC);
        -: 2533:
        -: 2534:      if Checks then
    #####: 2535:         if Position.Container = null then
    #####: 2536:            raise Constraint_Error with "Position cursor has no element";
        -: 2537:
    #####: 2538:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 2539:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2540:
    #####: 2541:         elsif Position.Index > Container.Last then
    #####: 2542:            raise Constraint_Error with "Position cursor is out of range";
        -: 2543:         end if;
        -: 2544:      end if;
        -: 2545:
    #####: 2546:      Container.Elements.EA (Position.Index) := New_Item;
    #####: 2547:   end Replace_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__replace_element__2.115:
    #####: 2526:   procedure Replace_Element
        -: 2527:     (Container : in out Vector;
        -: 2528:      Position  : Cursor;
        -: 2529:      New_Item  : Element_Type)
        -: 2530:   is
        -: 2531:   begin
    #####: 2532:      TE_Check (Container.TC);
        -: 2533:
        -: 2534:      if Checks then
    #####: 2535:         if Position.Container = null then
    #####: 2536:            raise Constraint_Error with "Position cursor has no element";
        -: 2537:
    #####: 2538:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 2539:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2540:
    #####: 2541:         elsif Position.Index > Container.Last then
    #####: 2542:            raise Constraint_Error with "Position cursor is out of range";
        -: 2543:         end if;
        -: 2544:      end if;
        -: 2545:
    #####: 2546:      Container.Elements.EA (Position.Index) := New_Item;
    #####: 2547:   end Replace_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__replace_element__2.242:
    #####: 2526:   procedure Replace_Element
        -: 2527:     (Container : in out Vector;
        -: 2528:      Position  : Cursor;
        -: 2529:      New_Item  : Element_Type)
        -: 2530:   is
        -: 2531:   begin
    #####: 2532:      TE_Check (Container.TC);
        -: 2533:
        -: 2534:      if Checks then
    #####: 2535:         if Position.Container = null then
    #####: 2536:            raise Constraint_Error with "Position cursor has no element";
        -: 2537:
    #####: 2538:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 2539:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2540:
    #####: 2541:         elsif Position.Index > Container.Last then
    #####: 2542:            raise Constraint_Error with "Position cursor is out of range";
        -: 2543:         end if;
        -: 2544:      end if;
        -: 2545:
    #####: 2546:      Container.Elements.EA (Position.Index) := New_Item;
    #####: 2547:   end Replace_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__replace_element__2.474:
    #####: 2526:   procedure Replace_Element
        -: 2527:     (Container : in out Vector;
        -: 2528:      Position  : Cursor;
        -: 2529:      New_Item  : Element_Type)
        -: 2530:   is
        -: 2531:   begin
    #####: 2532:      TE_Check (Container.TC);
        -: 2533:
        -: 2534:      if Checks then
    #####: 2535:         if Position.Container = null then
    #####: 2536:            raise Constraint_Error with "Position cursor has no element";
        -: 2537:
    #####: 2538:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 2539:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2540:
    #####: 2541:         elsif Position.Index > Container.Last then
    #####: 2542:            raise Constraint_Error with "Position cursor is out of range";
        -: 2543:         end if;
        -: 2544:      end if;
        -: 2545:
    #####: 2546:      Container.Elements.EA (Position.Index) := New_Item;
    #####: 2547:   end Replace_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__replace_element__2.601:
    #####: 2526:   procedure Replace_Element
        -: 2527:     (Container : in out Vector;
        -: 2528:      Position  : Cursor;
        -: 2529:      New_Item  : Element_Type)
        -: 2530:   is
        -: 2531:   begin
    #####: 2532:      TE_Check (Container.TC);
        -: 2533:
        -: 2534:      if Checks then
    #####: 2535:         if Position.Container = null then
    #####: 2536:            raise Constraint_Error with "Position cursor has no element";
        -: 2537:
    #####: 2538:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 2539:            raise Program_Error with "Position cursor denotes wrong container";
        -: 2540:
    #####: 2541:         elsif Position.Index > Container.Last then
    #####: 2542:            raise Constraint_Error with "Position cursor is out of range";
        -: 2543:         end if;
        -: 2544:      end if;
        -: 2545:
    #####: 2546:      Container.Elements.EA (Position.Index) := New_Item;
    #####: 2547:   end Replace_Element;
------------------
        -: 2548:
        -: 2549:   ----------------------
        -: 2550:   -- Reserve_Capacity --
        -: 2551:   ----------------------
        -: 2552:
    #####: 2553:   procedure Reserve_Capacity
        -: 2554:     (Container : in out Vector;
        -: 2555:      Capacity  : Count_Type)
        -: 2556:   is
    #####: 2557:      N : constant Count_Type := Length (Container);
        -: 2558:
        -: 2559:      Index : Count_Type'Base;
        -: 2560:      Last  : Index_Type'Base;
        -: 2561:
        -: 2562:   begin
        -: 2563:      --  Reserve_Capacity can be used to either expand the storage available
        -: 2564:      --  for elements (this would be its typical use, in anticipation of
        -: 2565:      --  future insertion), or to trim back storage. In the latter case,
        -: 2566:      --  storage can only be trimmed back to the limit of the container
        -: 2567:      --  length. Note that Reserve_Capacity neither deletes (active) elements
        -: 2568:      --  nor inserts elements; it only affects container capacity, never
        -: 2569:      --  container length.
        -: 2570:
    #####: 2571:      if Capacity = 0 then
        -: 2572:
        -: 2573:         --  This is a request to trim back storage, to the minimum amount
        -: 2574:         --  possible given the current state of the container.
        -: 2575:
    #####: 2576:         if N = 0 then
        -: 2577:
        -: 2578:            --  The container is empty, so in this unique case we can
        -: 2579:            --  deallocate the entire internal array. Note that an empty
        -: 2580:            --  container can never be busy, so there's no need to check the
        -: 2581:            --  tampering bits.
        -: 2582:
        -: 2583:            declare
    #####: 2584:               X : Elements_Access := Container.Elements;
        -: 2585:
        -: 2586:            begin
        -: 2587:               --  First we remove the internal array from the container, to
        -: 2588:               --  handle the case when the deallocation raises an exception.
        -: 2589:
    #####: 2590:               Container.Elements := null;
        -: 2591:
        -: 2592:               --  Container invariants have been restored, so it is now safe
        -: 2593:               --  to attempt to deallocate the internal array.
        -: 2594:
    #####: 2595:               Free (X);
        -: 2596:            end;
        -: 2597:
    #####: 2598:         elsif N < Container.Elements.EA'Length then
        -: 2599:
        -: 2600:            --  The container is not empty, and the current length is less than
        -: 2601:            --  the current capacity, so there's storage available to trim. In
        -: 2602:            --  this case, we allocate a new internal array having a length
        -: 2603:            --  that exactly matches the number of items in the
        -: 2604:            --  container. (Reserve_Capacity does not delete active elements,
        -: 2605:            --  so this is the best we can do with respect to minimizing
        -: 2606:            --  storage).
        -: 2607:
    #####: 2608:            TC_Check (Container.TC);
        -: 2609:
        -: 2610:            declare
    #####: 2611:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2612:                 Index_Type'First .. Container.Last;
        -: 2613:
    #####: 2614:               Src : Elements_Array renames
    #####: 2615:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2616:
    #####: 2617:               X : Elements_Access := Container.Elements;
        -: 2618:
        -: 2619:            begin
        -: 2620:               --  Although we have isolated the old internal array that we're
        -: 2621:               --  going to deallocate, we don't deallocate it until we have
        -: 2622:               --  successfully allocated a new one. If there is an exception
        -: 2623:               --  during allocation (either because there is not enough
        -: 2624:               --  storage, or because initialization of the elements fails),
        -: 2625:               --  we let it propagate without causing any side-effect.
        -: 2626:
    #####: 2627:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2628:
        -: 2629:               --  We have successfully allocated a new internal array (with a
        -: 2630:               --  smaller length than the old one, and containing a copy of
        -: 2631:               --  just the active elements in the container), so it is now
        -: 2632:               --  safe to attempt to deallocate the old array. The old array
        -: 2633:               --  has been isolated, and container invariants have been
        -: 2634:               --  restored, so if the deallocation fails (because finalization
        -: 2635:               --  of the elements fails), we simply let it propagate.
        -: 2636:
    #####: 2637:               Free (X);
        -: 2638:            end;
        -: 2639:         end if;
        -: 2640:
    #####: 2641:         return;
        -: 2642:      end if;
        -: 2643:
        -: 2644:      --  Reserve_Capacity can be used to expand the storage available for
        -: 2645:      --  elements, but we do not let the capacity grow beyond the number of
        -: 2646:      --  values in Index_Type'Range. (Were it otherwise, there would be no way
        -: 2647:      --  to refer to the elements with an index value greater than
        -: 2648:      --  Index_Type'Last, so that storage would be wasted.) Here we compute
        -: 2649:      --  the Last index value of the new internal array, in a way that avoids
        -: 2650:      --  any possibility of overflow.
        -: 2651:
        -: 2652:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 2653:
        -: 2654:         --  We perform a two-part test. First we determine whether the
        -: 2655:         --  computed Last value lies in the base range of the type, and then
        -: 2656:         --  determine whether it lies in the range of the index (sub)type.
        -: 2657:
        -: 2658:         --  Last must satisfy this relation:
        -: 2659:         --    First + Length - 1 <= Last
        -: 2660:         --  We regroup terms:
        -: 2661:         --    First - 1 <= Last - Length
        -: 2662:         --  Which can rewrite as:
        -: 2663:         --    No_Index <= Last - Length
        -: 2664:
        -: 2665:         if Checks and then
    #####: 2666:           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index
        -: 2667:         then
    #####: 2668:            raise Constraint_Error with "Capacity is out of range";
        -: 2669:         end if;
        -: 2670:
        -: 2671:         --  We now know that the computed value of Last is within the base
        -: 2672:         --  range of the type, so it is safe to compute its value:
        -: 2673:
    #####: 2674:         Last := No_Index + Index_Type'Base (Capacity);
        -: 2675:
        -: 2676:         --  Finally we test whether the value is within the range of the
        -: 2677:         --  generic actual index subtype:
        -: 2678:
        -: 2679:         if Checks and then Last > Index_Type'Last then
        -: 2680:            raise Constraint_Error with "Capacity is out of range";
        -: 2681:         end if;
        -: 2682:
        -: 2683:      elsif Index_Type'First <= 0 then
        -: 2684:
        -: 2685:         --  Here we can compute Last directly, in the normal way. We know that
        -: 2686:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 2687:         --  adding the (positive) value of Capacity.
        -: 2688:
        -: 2689:         Index := Count_Type'Base (No_Index) + Capacity;  -- Last
        -: 2690:
        -: 2691:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 2692:            raise Constraint_Error with "Capacity is out of range";
        -: 2693:         end if;
        -: 2694:
        -: 2695:         --  We know that the computed value (having type Count_Type) of Last
        -: 2696:         --  is within the range of the generic actual index subtype, so it is
        -: 2697:         --  safe to convert to Index_Type:
        -: 2698:
        -: 2699:         Last := Index_Type'Base (Index);
        -: 2700:
        -: 2701:      else
        -: 2702:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 2703:         --  must test the length indirectly (by working backwards from the
        -: 2704:         --  largest possible value of Last), in order to prevent overflow.
        -: 2705:
        -: 2706:         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index
        -: 2707:
        -: 2708:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 2709:            raise Constraint_Error with "Capacity is out of range";
        -: 2710:         end if;
        -: 2711:
        -: 2712:         --  We have determined that the value of Capacity would not create a
        -: 2713:         --  Last index value outside of the range of Index_Type, so we can now
        -: 2714:         --  safely compute its value.
        -: 2715:
        -: 2716:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);
        -: 2717:      end if;
        -: 2718:
        -: 2719:      --  The requested capacity is non-zero, but we don't know yet whether
        -: 2720:      --  this is a request for expansion or contraction of storage.
        -: 2721:
    #####: 2722:      if Container.Elements = null then
        -: 2723:
        -: 2724:         --  The container is empty (it doesn't even have an internal array),
        -: 2725:         --  so this represents a request to allocate (expand) storage having
        -: 2726:         --  the given capacity.
        -: 2727:
    #####: 2728:         Container.Elements := new Elements_Type (Last);
    #####: 2729:         return;
        -: 2730:      end if;
        -: 2731:
    #####: 2732:      if Capacity <= N then
        -: 2733:
        -: 2734:         --  This is a request to trim back storage, but only to the limit of
        -: 2735:         --  what's already in the container. (Reserve_Capacity never deletes
        -: 2736:         --  active elements, it only reclaims excess storage.)
        -: 2737:
    #####: 2738:         if N < Container.Elements.EA'Length then
        -: 2739:
        -: 2740:            --  The container is not empty (because the requested capacity is
        -: 2741:            --  positive, and less than or equal to the container length), and
        -: 2742:            --  the current length is less than the current capacity, so
        -: 2743:            --  there's storage available to trim. In this case, we allocate a
        -: 2744:            --  new internal array having a length that exactly matches the
        -: 2745:            --  number of items in the container.
        -: 2746:
    #####: 2747:            TC_Check (Container.TC);
        -: 2748:
        -: 2749:            declare
    #####: 2750:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2751:                 Index_Type'First .. Container.Last;
        -: 2752:
    #####: 2753:               Src : Elements_Array renames
    #####: 2754:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2755:
    #####: 2756:               X : Elements_Access := Container.Elements;
        -: 2757:
        -: 2758:            begin
        -: 2759:               --  Although we have isolated the old internal array that we're
        -: 2760:               --  going to deallocate, we don't deallocate it until we have
        -: 2761:               --  successfully allocated a new one. If there is an exception
        -: 2762:               --  during allocation (either because there is not enough
        -: 2763:               --  storage, or because initialization of the elements fails),
        -: 2764:               --  we let it propagate without causing any side-effect.
        -: 2765:
    #####: 2766:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2767:
        -: 2768:               --  We have successfully allocated a new internal array (with a
        -: 2769:               --  smaller length than the old one, and containing a copy of
        -: 2770:               --  just the active elements in the container), so it is now
        -: 2771:               --  safe to attempt to deallocate the old array. The old array
        -: 2772:               --  has been isolated, and container invariants have been
        -: 2773:               --  restored, so if the deallocation fails (because finalization
        -: 2774:               --  of the elements fails), we simply let it propagate.
        -: 2775:
    #####: 2776:               Free (X);
        -: 2777:            end;
        -: 2778:         end if;
        -: 2779:
    #####: 2780:         return;
        -: 2781:      end if;
        -: 2782:
        -: 2783:      --  The requested capacity is larger than the container length (the
        -: 2784:      --  number of active elements). Whether this represents a request for
        -: 2785:      --  expansion or contraction of the current capacity depends on what the
        -: 2786:      --  current capacity is.
        -: 2787:
    #####: 2788:      if Capacity = Container.Elements.EA'Length then
        -: 2789:
        -: 2790:         --  The requested capacity matches the existing capacity, so there's
        -: 2791:         --  nothing to do here. We treat this case as a no-op, and simply
        -: 2792:         --  return without checking the busy bit.
        -: 2793:
    #####: 2794:         return;
        -: 2795:      end if;
        -: 2796:
        -: 2797:      --  There is a change in the capacity of a non-empty container, so a new
        -: 2798:      --  internal array will be allocated. (The length of the new internal
        -: 2799:      --  array could be less or greater than the old internal array. We know
        -: 2800:      --  only that the length of the new internal array is greater than the
        -: 2801:      --  number of active elements in the container.) We must check whether
        -: 2802:      --  the container is busy before doing anything else.
        -: 2803:
    #####: 2804:      TC_Check (Container.TC);
        -: 2805:
        -: 2806:      --  We now allocate a new internal array, having a length different from
        -: 2807:      --  its current value.
        -: 2808:
        -: 2809:      declare
    #####: 2810:         E : Elements_Access := new Elements_Type (Last);
        -: 2811:
        -: 2812:      begin
        -: 2813:         --  We have successfully allocated the new internal array. We first
        -: 2814:         --  attempt to copy the existing elements from the old internal array
        -: 2815:         --  ("src" elements) onto the new internal array ("tgt" elements).
        -: 2816:
        -: 2817:         declare
    #####: 2818:            subtype Index_Subtype is Index_Type'Base range
    #####: 2819:              Index_Type'First .. Container.Last;
        -: 2820:
    #####: 2821:            Src : Elements_Array renames
    #####: 2822:                    Container.Elements.EA (Index_Subtype);
        -: 2823:
    #####: 2824:            Tgt : Elements_Array renames E.EA (Index_Subtype);
        -: 2825:
        -: 2826:         begin
    #####: 2827:            Tgt := Src;
        -: 2828:
        -: 2829:         exception
        -: 2830:            when others =>
        -: 2831:               Free (E);
        -: 2832:               raise;
        -: 2833:         end;
        -: 2834:
        -: 2835:         --  We have successfully copied the existing elements onto the new
        -: 2836:         --  internal array, so now we can attempt to deallocate the old one.
        -: 2837:
        -: 2838:         declare
    #####: 2839:            X : Elements_Access := Container.Elements;
        -: 2840:
        -: 2841:         begin
        -: 2842:            --  First we isolate the old internal array, and replace it in the
        -: 2843:            --  container with the new internal array.
        -: 2844:
    #####: 2845:            Container.Elements := E;
        -: 2846:
        -: 2847:            --  Container invariants have been restored, so it is now safe to
        -: 2848:            --  attempt to deallocate the old internal array.
        -: 2849:
    #####: 2850:            Free (X);
        -: 2851:         end;
        -: 2852:      end;
        -: 2853:   end Reserve_Capacity;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reserve_capacity.114:
    #####: 2553:   procedure Reserve_Capacity
        -: 2554:     (Container : in out Vector;
        -: 2555:      Capacity  : Count_Type)
        -: 2556:   is
    #####: 2557:      N : constant Count_Type := Length (Container);
        -: 2558:
        -: 2559:      Index : Count_Type'Base;
        -: 2560:      Last  : Index_Type'Base;
        -: 2561:
        -: 2562:   begin
        -: 2563:      --  Reserve_Capacity can be used to either expand the storage available
        -: 2564:      --  for elements (this would be its typical use, in anticipation of
        -: 2565:      --  future insertion), or to trim back storage. In the latter case,
        -: 2566:      --  storage can only be trimmed back to the limit of the container
        -: 2567:      --  length. Note that Reserve_Capacity neither deletes (active) elements
        -: 2568:      --  nor inserts elements; it only affects container capacity, never
        -: 2569:      --  container length.
        -: 2570:
    #####: 2571:      if Capacity = 0 then
        -: 2572:
        -: 2573:         --  This is a request to trim back storage, to the minimum amount
        -: 2574:         --  possible given the current state of the container.
        -: 2575:
    #####: 2576:         if N = 0 then
        -: 2577:
        -: 2578:            --  The container is empty, so in this unique case we can
        -: 2579:            --  deallocate the entire internal array. Note that an empty
        -: 2580:            --  container can never be busy, so there's no need to check the
        -: 2581:            --  tampering bits.
        -: 2582:
        -: 2583:            declare
    #####: 2584:               X : Elements_Access := Container.Elements;
        -: 2585:
        -: 2586:            begin
        -: 2587:               --  First we remove the internal array from the container, to
        -: 2588:               --  handle the case when the deallocation raises an exception.
        -: 2589:
    #####: 2590:               Container.Elements := null;
        -: 2591:
        -: 2592:               --  Container invariants have been restored, so it is now safe
        -: 2593:               --  to attempt to deallocate the internal array.
        -: 2594:
    #####: 2595:               Free (X);
        -: 2596:            end;
        -: 2597:
    #####: 2598:         elsif N < Container.Elements.EA'Length then
        -: 2599:
        -: 2600:            --  The container is not empty, and the current length is less than
        -: 2601:            --  the current capacity, so there's storage available to trim. In
        -: 2602:            --  this case, we allocate a new internal array having a length
        -: 2603:            --  that exactly matches the number of items in the
        -: 2604:            --  container. (Reserve_Capacity does not delete active elements,
        -: 2605:            --  so this is the best we can do with respect to minimizing
        -: 2606:            --  storage).
        -: 2607:
    #####: 2608:            TC_Check (Container.TC);
        -: 2609:
        -: 2610:            declare
    #####: 2611:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2612:                 Index_Type'First .. Container.Last;
        -: 2613:
    #####: 2614:               Src : Elements_Array renames
    #####: 2615:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2616:
    #####: 2617:               X : Elements_Access := Container.Elements;
        -: 2618:
        -: 2619:            begin
        -: 2620:               --  Although we have isolated the old internal array that we're
        -: 2621:               --  going to deallocate, we don't deallocate it until we have
        -: 2622:               --  successfully allocated a new one. If there is an exception
        -: 2623:               --  during allocation (either because there is not enough
        -: 2624:               --  storage, or because initialization of the elements fails),
        -: 2625:               --  we let it propagate without causing any side-effect.
        -: 2626:
    #####: 2627:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2628:
        -: 2629:               --  We have successfully allocated a new internal array (with a
        -: 2630:               --  smaller length than the old one, and containing a copy of
        -: 2631:               --  just the active elements in the container), so it is now
        -: 2632:               --  safe to attempt to deallocate the old array. The old array
        -: 2633:               --  has been isolated, and container invariants have been
        -: 2634:               --  restored, so if the deallocation fails (because finalization
        -: 2635:               --  of the elements fails), we simply let it propagate.
        -: 2636:
    #####: 2637:               Free (X);
        -: 2638:            end;
        -: 2639:         end if;
        -: 2640:
    #####: 2641:         return;
        -: 2642:      end if;
        -: 2643:
        -: 2644:      --  Reserve_Capacity can be used to expand the storage available for
        -: 2645:      --  elements, but we do not let the capacity grow beyond the number of
        -: 2646:      --  values in Index_Type'Range. (Were it otherwise, there would be no way
        -: 2647:      --  to refer to the elements with an index value greater than
        -: 2648:      --  Index_Type'Last, so that storage would be wasted.) Here we compute
        -: 2649:      --  the Last index value of the new internal array, in a way that avoids
        -: 2650:      --  any possibility of overflow.
        -: 2651:
        -: 2652:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 2653:
        -: 2654:         --  We perform a two-part test. First we determine whether the
        -: 2655:         --  computed Last value lies in the base range of the type, and then
        -: 2656:         --  determine whether it lies in the range of the index (sub)type.
        -: 2657:
        -: 2658:         --  Last must satisfy this relation:
        -: 2659:         --    First + Length - 1 <= Last
        -: 2660:         --  We regroup terms:
        -: 2661:         --    First - 1 <= Last - Length
        -: 2662:         --  Which can rewrite as:
        -: 2663:         --    No_Index <= Last - Length
        -: 2664:
        -: 2665:         if Checks and then
    #####: 2666:           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index
        -: 2667:         then
    #####: 2668:            raise Constraint_Error with "Capacity is out of range";
        -: 2669:         end if;
        -: 2670:
        -: 2671:         --  We now know that the computed value of Last is within the base
        -: 2672:         --  range of the type, so it is safe to compute its value:
        -: 2673:
    #####: 2674:         Last := No_Index + Index_Type'Base (Capacity);
        -: 2675:
        -: 2676:         --  Finally we test whether the value is within the range of the
        -: 2677:         --  generic actual index subtype:
        -: 2678:
        -: 2679:         if Checks and then Last > Index_Type'Last then
        -: 2680:            raise Constraint_Error with "Capacity is out of range";
        -: 2681:         end if;
        -: 2682:
        -: 2683:      elsif Index_Type'First <= 0 then
        -: 2684:
        -: 2685:         --  Here we can compute Last directly, in the normal way. We know that
        -: 2686:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 2687:         --  adding the (positive) value of Capacity.
        -: 2688:
        -: 2689:         Index := Count_Type'Base (No_Index) + Capacity;  -- Last
        -: 2690:
        -: 2691:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 2692:            raise Constraint_Error with "Capacity is out of range";
        -: 2693:         end if;
        -: 2694:
        -: 2695:         --  We know that the computed value (having type Count_Type) of Last
        -: 2696:         --  is within the range of the generic actual index subtype, so it is
        -: 2697:         --  safe to convert to Index_Type:
        -: 2698:
        -: 2699:         Last := Index_Type'Base (Index);
        -: 2700:
        -: 2701:      else
        -: 2702:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 2703:         --  must test the length indirectly (by working backwards from the
        -: 2704:         --  largest possible value of Last), in order to prevent overflow.
        -: 2705:
        -: 2706:         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index
        -: 2707:
        -: 2708:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 2709:            raise Constraint_Error with "Capacity is out of range";
        -: 2710:         end if;
        -: 2711:
        -: 2712:         --  We have determined that the value of Capacity would not create a
        -: 2713:         --  Last index value outside of the range of Index_Type, so we can now
        -: 2714:         --  safely compute its value.
        -: 2715:
        -: 2716:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);
        -: 2717:      end if;
        -: 2718:
        -: 2719:      --  The requested capacity is non-zero, but we don't know yet whether
        -: 2720:      --  this is a request for expansion or contraction of storage.
        -: 2721:
    #####: 2722:      if Container.Elements = null then
        -: 2723:
        -: 2724:         --  The container is empty (it doesn't even have an internal array),
        -: 2725:         --  so this represents a request to allocate (expand) storage having
        -: 2726:         --  the given capacity.
        -: 2727:
    #####: 2728:         Container.Elements := new Elements_Type (Last);
    #####: 2729:         return;
        -: 2730:      end if;
        -: 2731:
    #####: 2732:      if Capacity <= N then
        -: 2733:
        -: 2734:         --  This is a request to trim back storage, but only to the limit of
        -: 2735:         --  what's already in the container. (Reserve_Capacity never deletes
        -: 2736:         --  active elements, it only reclaims excess storage.)
        -: 2737:
    #####: 2738:         if N < Container.Elements.EA'Length then
        -: 2739:
        -: 2740:            --  The container is not empty (because the requested capacity is
        -: 2741:            --  positive, and less than or equal to the container length), and
        -: 2742:            --  the current length is less than the current capacity, so
        -: 2743:            --  there's storage available to trim. In this case, we allocate a
        -: 2744:            --  new internal array having a length that exactly matches the
        -: 2745:            --  number of items in the container.
        -: 2746:
    #####: 2747:            TC_Check (Container.TC);
        -: 2748:
        -: 2749:            declare
    #####: 2750:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2751:                 Index_Type'First .. Container.Last;
        -: 2752:
    #####: 2753:               Src : Elements_Array renames
    #####: 2754:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2755:
    #####: 2756:               X : Elements_Access := Container.Elements;
        -: 2757:
        -: 2758:            begin
        -: 2759:               --  Although we have isolated the old internal array that we're
        -: 2760:               --  going to deallocate, we don't deallocate it until we have
        -: 2761:               --  successfully allocated a new one. If there is an exception
        -: 2762:               --  during allocation (either because there is not enough
        -: 2763:               --  storage, or because initialization of the elements fails),
        -: 2764:               --  we let it propagate without causing any side-effect.
        -: 2765:
    #####: 2766:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2767:
        -: 2768:               --  We have successfully allocated a new internal array (with a
        -: 2769:               --  smaller length than the old one, and containing a copy of
        -: 2770:               --  just the active elements in the container), so it is now
        -: 2771:               --  safe to attempt to deallocate the old array. The old array
        -: 2772:               --  has been isolated, and container invariants have been
        -: 2773:               --  restored, so if the deallocation fails (because finalization
        -: 2774:               --  of the elements fails), we simply let it propagate.
        -: 2775:
    #####: 2776:               Free (X);
        -: 2777:            end;
        -: 2778:         end if;
        -: 2779:
    #####: 2780:         return;
        -: 2781:      end if;
        -: 2782:
        -: 2783:      --  The requested capacity is larger than the container length (the
        -: 2784:      --  number of active elements). Whether this represents a request for
        -: 2785:      --  expansion or contraction of the current capacity depends on what the
        -: 2786:      --  current capacity is.
        -: 2787:
    #####: 2788:      if Capacity = Container.Elements.EA'Length then
        -: 2789:
        -: 2790:         --  The requested capacity matches the existing capacity, so there's
        -: 2791:         --  nothing to do here. We treat this case as a no-op, and simply
        -: 2792:         --  return without checking the busy bit.
        -: 2793:
    #####: 2794:         return;
        -: 2795:      end if;
        -: 2796:
        -: 2797:      --  There is a change in the capacity of a non-empty container, so a new
        -: 2798:      --  internal array will be allocated. (The length of the new internal
        -: 2799:      --  array could be less or greater than the old internal array. We know
        -: 2800:      --  only that the length of the new internal array is greater than the
        -: 2801:      --  number of active elements in the container.) We must check whether
        -: 2802:      --  the container is busy before doing anything else.
        -: 2803:
    #####: 2804:      TC_Check (Container.TC);
        -: 2805:
        -: 2806:      --  We now allocate a new internal array, having a length different from
        -: 2807:      --  its current value.
        -: 2808:
        -: 2809:      declare
    #####: 2810:         E : Elements_Access := new Elements_Type (Last);
        -: 2811:
        -: 2812:      begin
        -: 2813:         --  We have successfully allocated the new internal array. We first
        -: 2814:         --  attempt to copy the existing elements from the old internal array
        -: 2815:         --  ("src" elements) onto the new internal array ("tgt" elements).
        -: 2816:
        -: 2817:         declare
    #####: 2818:            subtype Index_Subtype is Index_Type'Base range
    #####: 2819:              Index_Type'First .. Container.Last;
        -: 2820:
    #####: 2821:            Src : Elements_Array renames
    #####: 2822:                    Container.Elements.EA (Index_Subtype);
        -: 2823:
    #####: 2824:            Tgt : Elements_Array renames E.EA (Index_Subtype);
        -: 2825:
        -: 2826:         begin
    #####: 2827:            Tgt := Src;
        -: 2828:
        -: 2829:         exception
        -: 2830:            when others =>
        -: 2831:               Free (E);
        -: 2832:               raise;
        -: 2833:         end;
        -: 2834:
        -: 2835:         --  We have successfully copied the existing elements onto the new
        -: 2836:         --  internal array, so now we can attempt to deallocate the old one.
        -: 2837:
        -: 2838:         declare
    #####: 2839:            X : Elements_Access := Container.Elements;
        -: 2840:
        -: 2841:         begin
        -: 2842:            --  First we isolate the old internal array, and replace it in the
        -: 2843:            --  container with the new internal array.
        -: 2844:
    #####: 2845:            Container.Elements := E;
        -: 2846:
        -: 2847:            --  Container invariants have been restored, so it is now safe to
        -: 2848:            --  attempt to deallocate the old internal array.
        -: 2849:
    #####: 2850:            Free (X);
        -: 2851:         end;
        -: 2852:      end;
        -: 2853:   end Reserve_Capacity;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reserve_capacity.241:
    #####: 2553:   procedure Reserve_Capacity
        -: 2554:     (Container : in out Vector;
        -: 2555:      Capacity  : Count_Type)
        -: 2556:   is
    #####: 2557:      N : constant Count_Type := Length (Container);
        -: 2558:
        -: 2559:      Index : Count_Type'Base;
        -: 2560:      Last  : Index_Type'Base;
        -: 2561:
        -: 2562:   begin
        -: 2563:      --  Reserve_Capacity can be used to either expand the storage available
        -: 2564:      --  for elements (this would be its typical use, in anticipation of
        -: 2565:      --  future insertion), or to trim back storage. In the latter case,
        -: 2566:      --  storage can only be trimmed back to the limit of the container
        -: 2567:      --  length. Note that Reserve_Capacity neither deletes (active) elements
        -: 2568:      --  nor inserts elements; it only affects container capacity, never
        -: 2569:      --  container length.
        -: 2570:
    #####: 2571:      if Capacity = 0 then
        -: 2572:
        -: 2573:         --  This is a request to trim back storage, to the minimum amount
        -: 2574:         --  possible given the current state of the container.
        -: 2575:
    #####: 2576:         if N = 0 then
        -: 2577:
        -: 2578:            --  The container is empty, so in this unique case we can
        -: 2579:            --  deallocate the entire internal array. Note that an empty
        -: 2580:            --  container can never be busy, so there's no need to check the
        -: 2581:            --  tampering bits.
        -: 2582:
        -: 2583:            declare
    #####: 2584:               X : Elements_Access := Container.Elements;
        -: 2585:
        -: 2586:            begin
        -: 2587:               --  First we remove the internal array from the container, to
        -: 2588:               --  handle the case when the deallocation raises an exception.
        -: 2589:
    #####: 2590:               Container.Elements := null;
        -: 2591:
        -: 2592:               --  Container invariants have been restored, so it is now safe
        -: 2593:               --  to attempt to deallocate the internal array.
        -: 2594:
    #####: 2595:               Free (X);
        -: 2596:            end;
        -: 2597:
    #####: 2598:         elsif N < Container.Elements.EA'Length then
        -: 2599:
        -: 2600:            --  The container is not empty, and the current length is less than
        -: 2601:            --  the current capacity, so there's storage available to trim. In
        -: 2602:            --  this case, we allocate a new internal array having a length
        -: 2603:            --  that exactly matches the number of items in the
        -: 2604:            --  container. (Reserve_Capacity does not delete active elements,
        -: 2605:            --  so this is the best we can do with respect to minimizing
        -: 2606:            --  storage).
        -: 2607:
    #####: 2608:            TC_Check (Container.TC);
        -: 2609:
        -: 2610:            declare
    #####: 2611:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2612:                 Index_Type'First .. Container.Last;
        -: 2613:
    #####: 2614:               Src : Elements_Array renames
    #####: 2615:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2616:
    #####: 2617:               X : Elements_Access := Container.Elements;
        -: 2618:
        -: 2619:            begin
        -: 2620:               --  Although we have isolated the old internal array that we're
        -: 2621:               --  going to deallocate, we don't deallocate it until we have
        -: 2622:               --  successfully allocated a new one. If there is an exception
        -: 2623:               --  during allocation (either because there is not enough
        -: 2624:               --  storage, or because initialization of the elements fails),
        -: 2625:               --  we let it propagate without causing any side-effect.
        -: 2626:
    #####: 2627:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2628:
        -: 2629:               --  We have successfully allocated a new internal array (with a
        -: 2630:               --  smaller length than the old one, and containing a copy of
        -: 2631:               --  just the active elements in the container), so it is now
        -: 2632:               --  safe to attempt to deallocate the old array. The old array
        -: 2633:               --  has been isolated, and container invariants have been
        -: 2634:               --  restored, so if the deallocation fails (because finalization
        -: 2635:               --  of the elements fails), we simply let it propagate.
        -: 2636:
    #####: 2637:               Free (X);
        -: 2638:            end;
        -: 2639:         end if;
        -: 2640:
    #####: 2641:         return;
        -: 2642:      end if;
        -: 2643:
        -: 2644:      --  Reserve_Capacity can be used to expand the storage available for
        -: 2645:      --  elements, but we do not let the capacity grow beyond the number of
        -: 2646:      --  values in Index_Type'Range. (Were it otherwise, there would be no way
        -: 2647:      --  to refer to the elements with an index value greater than
        -: 2648:      --  Index_Type'Last, so that storage would be wasted.) Here we compute
        -: 2649:      --  the Last index value of the new internal array, in a way that avoids
        -: 2650:      --  any possibility of overflow.
        -: 2651:
        -: 2652:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 2653:
        -: 2654:         --  We perform a two-part test. First we determine whether the
        -: 2655:         --  computed Last value lies in the base range of the type, and then
        -: 2656:         --  determine whether it lies in the range of the index (sub)type.
        -: 2657:
        -: 2658:         --  Last must satisfy this relation:
        -: 2659:         --    First + Length - 1 <= Last
        -: 2660:         --  We regroup terms:
        -: 2661:         --    First - 1 <= Last - Length
        -: 2662:         --  Which can rewrite as:
        -: 2663:         --    No_Index <= Last - Length
        -: 2664:
        -: 2665:         if Checks and then
    #####: 2666:           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index
        -: 2667:         then
    #####: 2668:            raise Constraint_Error with "Capacity is out of range";
        -: 2669:         end if;
        -: 2670:
        -: 2671:         --  We now know that the computed value of Last is within the base
        -: 2672:         --  range of the type, so it is safe to compute its value:
        -: 2673:
    #####: 2674:         Last := No_Index + Index_Type'Base (Capacity);
        -: 2675:
        -: 2676:         --  Finally we test whether the value is within the range of the
        -: 2677:         --  generic actual index subtype:
        -: 2678:
        -: 2679:         if Checks and then Last > Index_Type'Last then
        -: 2680:            raise Constraint_Error with "Capacity is out of range";
        -: 2681:         end if;
        -: 2682:
        -: 2683:      elsif Index_Type'First <= 0 then
        -: 2684:
        -: 2685:         --  Here we can compute Last directly, in the normal way. We know that
        -: 2686:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 2687:         --  adding the (positive) value of Capacity.
        -: 2688:
        -: 2689:         Index := Count_Type'Base (No_Index) + Capacity;  -- Last
        -: 2690:
        -: 2691:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 2692:            raise Constraint_Error with "Capacity is out of range";
        -: 2693:         end if;
        -: 2694:
        -: 2695:         --  We know that the computed value (having type Count_Type) of Last
        -: 2696:         --  is within the range of the generic actual index subtype, so it is
        -: 2697:         --  safe to convert to Index_Type:
        -: 2698:
        -: 2699:         Last := Index_Type'Base (Index);
        -: 2700:
        -: 2701:      else
        -: 2702:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 2703:         --  must test the length indirectly (by working backwards from the
        -: 2704:         --  largest possible value of Last), in order to prevent overflow.
        -: 2705:
        -: 2706:         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index
        -: 2707:
        -: 2708:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 2709:            raise Constraint_Error with "Capacity is out of range";
        -: 2710:         end if;
        -: 2711:
        -: 2712:         --  We have determined that the value of Capacity would not create a
        -: 2713:         --  Last index value outside of the range of Index_Type, so we can now
        -: 2714:         --  safely compute its value.
        -: 2715:
        -: 2716:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);
        -: 2717:      end if;
        -: 2718:
        -: 2719:      --  The requested capacity is non-zero, but we don't know yet whether
        -: 2720:      --  this is a request for expansion or contraction of storage.
        -: 2721:
    #####: 2722:      if Container.Elements = null then
        -: 2723:
        -: 2724:         --  The container is empty (it doesn't even have an internal array),
        -: 2725:         --  so this represents a request to allocate (expand) storage having
        -: 2726:         --  the given capacity.
        -: 2727:
    #####: 2728:         Container.Elements := new Elements_Type (Last);
    #####: 2729:         return;
        -: 2730:      end if;
        -: 2731:
    #####: 2732:      if Capacity <= N then
        -: 2733:
        -: 2734:         --  This is a request to trim back storage, but only to the limit of
        -: 2735:         --  what's already in the container. (Reserve_Capacity never deletes
        -: 2736:         --  active elements, it only reclaims excess storage.)
        -: 2737:
    #####: 2738:         if N < Container.Elements.EA'Length then
        -: 2739:
        -: 2740:            --  The container is not empty (because the requested capacity is
        -: 2741:            --  positive, and less than or equal to the container length), and
        -: 2742:            --  the current length is less than the current capacity, so
        -: 2743:            --  there's storage available to trim. In this case, we allocate a
        -: 2744:            --  new internal array having a length that exactly matches the
        -: 2745:            --  number of items in the container.
        -: 2746:
    #####: 2747:            TC_Check (Container.TC);
        -: 2748:
        -: 2749:            declare
    #####: 2750:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2751:                 Index_Type'First .. Container.Last;
        -: 2752:
    #####: 2753:               Src : Elements_Array renames
    #####: 2754:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2755:
    #####: 2756:               X : Elements_Access := Container.Elements;
        -: 2757:
        -: 2758:            begin
        -: 2759:               --  Although we have isolated the old internal array that we're
        -: 2760:               --  going to deallocate, we don't deallocate it until we have
        -: 2761:               --  successfully allocated a new one. If there is an exception
        -: 2762:               --  during allocation (either because there is not enough
        -: 2763:               --  storage, or because initialization of the elements fails),
        -: 2764:               --  we let it propagate without causing any side-effect.
        -: 2765:
    #####: 2766:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2767:
        -: 2768:               --  We have successfully allocated a new internal array (with a
        -: 2769:               --  smaller length than the old one, and containing a copy of
        -: 2770:               --  just the active elements in the container), so it is now
        -: 2771:               --  safe to attempt to deallocate the old array. The old array
        -: 2772:               --  has been isolated, and container invariants have been
        -: 2773:               --  restored, so if the deallocation fails (because finalization
        -: 2774:               --  of the elements fails), we simply let it propagate.
        -: 2775:
    #####: 2776:               Free (X);
        -: 2777:            end;
        -: 2778:         end if;
        -: 2779:
    #####: 2780:         return;
        -: 2781:      end if;
        -: 2782:
        -: 2783:      --  The requested capacity is larger than the container length (the
        -: 2784:      --  number of active elements). Whether this represents a request for
        -: 2785:      --  expansion or contraction of the current capacity depends on what the
        -: 2786:      --  current capacity is.
        -: 2787:
    #####: 2788:      if Capacity = Container.Elements.EA'Length then
        -: 2789:
        -: 2790:         --  The requested capacity matches the existing capacity, so there's
        -: 2791:         --  nothing to do here. We treat this case as a no-op, and simply
        -: 2792:         --  return without checking the busy bit.
        -: 2793:
    #####: 2794:         return;
        -: 2795:      end if;
        -: 2796:
        -: 2797:      --  There is a change in the capacity of a non-empty container, so a new
        -: 2798:      --  internal array will be allocated. (The length of the new internal
        -: 2799:      --  array could be less or greater than the old internal array. We know
        -: 2800:      --  only that the length of the new internal array is greater than the
        -: 2801:      --  number of active elements in the container.) We must check whether
        -: 2802:      --  the container is busy before doing anything else.
        -: 2803:
    #####: 2804:      TC_Check (Container.TC);
        -: 2805:
        -: 2806:      --  We now allocate a new internal array, having a length different from
        -: 2807:      --  its current value.
        -: 2808:
        -: 2809:      declare
    #####: 2810:         E : Elements_Access := new Elements_Type (Last);
        -: 2811:
        -: 2812:      begin
        -: 2813:         --  We have successfully allocated the new internal array. We first
        -: 2814:         --  attempt to copy the existing elements from the old internal array
        -: 2815:         --  ("src" elements) onto the new internal array ("tgt" elements).
        -: 2816:
        -: 2817:         declare
    #####: 2818:            subtype Index_Subtype is Index_Type'Base range
    #####: 2819:              Index_Type'First .. Container.Last;
        -: 2820:
    #####: 2821:            Src : Elements_Array renames
    #####: 2822:                    Container.Elements.EA (Index_Subtype);
        -: 2823:
    #####: 2824:            Tgt : Elements_Array renames E.EA (Index_Subtype);
        -: 2825:
        -: 2826:         begin
    #####: 2827:            Tgt := Src;
        -: 2828:
        -: 2829:         exception
        -: 2830:            when others =>
        -: 2831:               Free (E);
        -: 2832:               raise;
        -: 2833:         end;
        -: 2834:
        -: 2835:         --  We have successfully copied the existing elements onto the new
        -: 2836:         --  internal array, so now we can attempt to deallocate the old one.
        -: 2837:
        -: 2838:         declare
    #####: 2839:            X : Elements_Access := Container.Elements;
        -: 2840:
        -: 2841:         begin
        -: 2842:            --  First we isolate the old internal array, and replace it in the
        -: 2843:            --  container with the new internal array.
        -: 2844:
    #####: 2845:            Container.Elements := E;
        -: 2846:
        -: 2847:            --  Container invariants have been restored, so it is now safe to
        -: 2848:            --  attempt to deallocate the old internal array.
        -: 2849:
    #####: 2850:            Free (X);
        -: 2851:         end;
        -: 2852:      end;
        -: 2853:   end Reserve_Capacity;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reserve_capacity.473:
    #####: 2553:   procedure Reserve_Capacity
        -: 2554:     (Container : in out Vector;
        -: 2555:      Capacity  : Count_Type)
        -: 2556:   is
    #####: 2557:      N : constant Count_Type := Length (Container);
        -: 2558:
        -: 2559:      Index : Count_Type'Base;
        -: 2560:      Last  : Index_Type'Base;
        -: 2561:
        -: 2562:   begin
        -: 2563:      --  Reserve_Capacity can be used to either expand the storage available
        -: 2564:      --  for elements (this would be its typical use, in anticipation of
        -: 2565:      --  future insertion), or to trim back storage. In the latter case,
        -: 2566:      --  storage can only be trimmed back to the limit of the container
        -: 2567:      --  length. Note that Reserve_Capacity neither deletes (active) elements
        -: 2568:      --  nor inserts elements; it only affects container capacity, never
        -: 2569:      --  container length.
        -: 2570:
    #####: 2571:      if Capacity = 0 then
        -: 2572:
        -: 2573:         --  This is a request to trim back storage, to the minimum amount
        -: 2574:         --  possible given the current state of the container.
        -: 2575:
    #####: 2576:         if N = 0 then
        -: 2577:
        -: 2578:            --  The container is empty, so in this unique case we can
        -: 2579:            --  deallocate the entire internal array. Note that an empty
        -: 2580:            --  container can never be busy, so there's no need to check the
        -: 2581:            --  tampering bits.
        -: 2582:
        -: 2583:            declare
    #####: 2584:               X : Elements_Access := Container.Elements;
        -: 2585:
        -: 2586:            begin
        -: 2587:               --  First we remove the internal array from the container, to
        -: 2588:               --  handle the case when the deallocation raises an exception.
        -: 2589:
    #####: 2590:               Container.Elements := null;
        -: 2591:
        -: 2592:               --  Container invariants have been restored, so it is now safe
        -: 2593:               --  to attempt to deallocate the internal array.
        -: 2594:
    #####: 2595:               Free (X);
        -: 2596:            end;
        -: 2597:
    #####: 2598:         elsif N < Container.Elements.EA'Length then
        -: 2599:
        -: 2600:            --  The container is not empty, and the current length is less than
        -: 2601:            --  the current capacity, so there's storage available to trim. In
        -: 2602:            --  this case, we allocate a new internal array having a length
        -: 2603:            --  that exactly matches the number of items in the
        -: 2604:            --  container. (Reserve_Capacity does not delete active elements,
        -: 2605:            --  so this is the best we can do with respect to minimizing
        -: 2606:            --  storage).
        -: 2607:
    #####: 2608:            TC_Check (Container.TC);
        -: 2609:
        -: 2610:            declare
    #####: 2611:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2612:                 Index_Type'First .. Container.Last;
        -: 2613:
    #####: 2614:               Src : Elements_Array renames
    #####: 2615:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2616:
    #####: 2617:               X : Elements_Access := Container.Elements;
        -: 2618:
        -: 2619:            begin
        -: 2620:               --  Although we have isolated the old internal array that we're
        -: 2621:               --  going to deallocate, we don't deallocate it until we have
        -: 2622:               --  successfully allocated a new one. If there is an exception
        -: 2623:               --  during allocation (either because there is not enough
        -: 2624:               --  storage, or because initialization of the elements fails),
        -: 2625:               --  we let it propagate without causing any side-effect.
        -: 2626:
    #####: 2627:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2628:
        -: 2629:               --  We have successfully allocated a new internal array (with a
        -: 2630:               --  smaller length than the old one, and containing a copy of
        -: 2631:               --  just the active elements in the container), so it is now
        -: 2632:               --  safe to attempt to deallocate the old array. The old array
        -: 2633:               --  has been isolated, and container invariants have been
        -: 2634:               --  restored, so if the deallocation fails (because finalization
        -: 2635:               --  of the elements fails), we simply let it propagate.
        -: 2636:
    #####: 2637:               Free (X);
        -: 2638:            end;
        -: 2639:         end if;
        -: 2640:
    #####: 2641:         return;
        -: 2642:      end if;
        -: 2643:
        -: 2644:      --  Reserve_Capacity can be used to expand the storage available for
        -: 2645:      --  elements, but we do not let the capacity grow beyond the number of
        -: 2646:      --  values in Index_Type'Range. (Were it otherwise, there would be no way
        -: 2647:      --  to refer to the elements with an index value greater than
        -: 2648:      --  Index_Type'Last, so that storage would be wasted.) Here we compute
        -: 2649:      --  the Last index value of the new internal array, in a way that avoids
        -: 2650:      --  any possibility of overflow.
        -: 2651:
        -: 2652:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 2653:
        -: 2654:         --  We perform a two-part test. First we determine whether the
        -: 2655:         --  computed Last value lies in the base range of the type, and then
        -: 2656:         --  determine whether it lies in the range of the index (sub)type.
        -: 2657:
        -: 2658:         --  Last must satisfy this relation:
        -: 2659:         --    First + Length - 1 <= Last
        -: 2660:         --  We regroup terms:
        -: 2661:         --    First - 1 <= Last - Length
        -: 2662:         --  Which can rewrite as:
        -: 2663:         --    No_Index <= Last - Length
        -: 2664:
        -: 2665:         if Checks and then
    #####: 2666:           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index
        -: 2667:         then
    #####: 2668:            raise Constraint_Error with "Capacity is out of range";
        -: 2669:         end if;
        -: 2670:
        -: 2671:         --  We now know that the computed value of Last is within the base
        -: 2672:         --  range of the type, so it is safe to compute its value:
        -: 2673:
    #####: 2674:         Last := No_Index + Index_Type'Base (Capacity);
        -: 2675:
        -: 2676:         --  Finally we test whether the value is within the range of the
        -: 2677:         --  generic actual index subtype:
        -: 2678:
        -: 2679:         if Checks and then Last > Index_Type'Last then
        -: 2680:            raise Constraint_Error with "Capacity is out of range";
        -: 2681:         end if;
        -: 2682:
        -: 2683:      elsif Index_Type'First <= 0 then
        -: 2684:
        -: 2685:         --  Here we can compute Last directly, in the normal way. We know that
        -: 2686:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 2687:         --  adding the (positive) value of Capacity.
        -: 2688:
        -: 2689:         Index := Count_Type'Base (No_Index) + Capacity;  -- Last
        -: 2690:
        -: 2691:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 2692:            raise Constraint_Error with "Capacity is out of range";
        -: 2693:         end if;
        -: 2694:
        -: 2695:         --  We know that the computed value (having type Count_Type) of Last
        -: 2696:         --  is within the range of the generic actual index subtype, so it is
        -: 2697:         --  safe to convert to Index_Type:
        -: 2698:
        -: 2699:         Last := Index_Type'Base (Index);
        -: 2700:
        -: 2701:      else
        -: 2702:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 2703:         --  must test the length indirectly (by working backwards from the
        -: 2704:         --  largest possible value of Last), in order to prevent overflow.
        -: 2705:
        -: 2706:         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index
        -: 2707:
        -: 2708:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 2709:            raise Constraint_Error with "Capacity is out of range";
        -: 2710:         end if;
        -: 2711:
        -: 2712:         --  We have determined that the value of Capacity would not create a
        -: 2713:         --  Last index value outside of the range of Index_Type, so we can now
        -: 2714:         --  safely compute its value.
        -: 2715:
        -: 2716:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);
        -: 2717:      end if;
        -: 2718:
        -: 2719:      --  The requested capacity is non-zero, but we don't know yet whether
        -: 2720:      --  this is a request for expansion or contraction of storage.
        -: 2721:
    #####: 2722:      if Container.Elements = null then
        -: 2723:
        -: 2724:         --  The container is empty (it doesn't even have an internal array),
        -: 2725:         --  so this represents a request to allocate (expand) storage having
        -: 2726:         --  the given capacity.
        -: 2727:
    #####: 2728:         Container.Elements := new Elements_Type (Last);
    #####: 2729:         return;
        -: 2730:      end if;
        -: 2731:
    #####: 2732:      if Capacity <= N then
        -: 2733:
        -: 2734:         --  This is a request to trim back storage, but only to the limit of
        -: 2735:         --  what's already in the container. (Reserve_Capacity never deletes
        -: 2736:         --  active elements, it only reclaims excess storage.)
        -: 2737:
    #####: 2738:         if N < Container.Elements.EA'Length then
        -: 2739:
        -: 2740:            --  The container is not empty (because the requested capacity is
        -: 2741:            --  positive, and less than or equal to the container length), and
        -: 2742:            --  the current length is less than the current capacity, so
        -: 2743:            --  there's storage available to trim. In this case, we allocate a
        -: 2744:            --  new internal array having a length that exactly matches the
        -: 2745:            --  number of items in the container.
        -: 2746:
    #####: 2747:            TC_Check (Container.TC);
        -: 2748:
        -: 2749:            declare
    #####: 2750:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2751:                 Index_Type'First .. Container.Last;
        -: 2752:
    #####: 2753:               Src : Elements_Array renames
    #####: 2754:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2755:
    #####: 2756:               X : Elements_Access := Container.Elements;
        -: 2757:
        -: 2758:            begin
        -: 2759:               --  Although we have isolated the old internal array that we're
        -: 2760:               --  going to deallocate, we don't deallocate it until we have
        -: 2761:               --  successfully allocated a new one. If there is an exception
        -: 2762:               --  during allocation (either because there is not enough
        -: 2763:               --  storage, or because initialization of the elements fails),
        -: 2764:               --  we let it propagate without causing any side-effect.
        -: 2765:
    #####: 2766:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2767:
        -: 2768:               --  We have successfully allocated a new internal array (with a
        -: 2769:               --  smaller length than the old one, and containing a copy of
        -: 2770:               --  just the active elements in the container), so it is now
        -: 2771:               --  safe to attempt to deallocate the old array. The old array
        -: 2772:               --  has been isolated, and container invariants have been
        -: 2773:               --  restored, so if the deallocation fails (because finalization
        -: 2774:               --  of the elements fails), we simply let it propagate.
        -: 2775:
    #####: 2776:               Free (X);
        -: 2777:            end;
        -: 2778:         end if;
        -: 2779:
    #####: 2780:         return;
        -: 2781:      end if;
        -: 2782:
        -: 2783:      --  The requested capacity is larger than the container length (the
        -: 2784:      --  number of active elements). Whether this represents a request for
        -: 2785:      --  expansion or contraction of the current capacity depends on what the
        -: 2786:      --  current capacity is.
        -: 2787:
    #####: 2788:      if Capacity = Container.Elements.EA'Length then
        -: 2789:
        -: 2790:         --  The requested capacity matches the existing capacity, so there's
        -: 2791:         --  nothing to do here. We treat this case as a no-op, and simply
        -: 2792:         --  return without checking the busy bit.
        -: 2793:
    #####: 2794:         return;
        -: 2795:      end if;
        -: 2796:
        -: 2797:      --  There is a change in the capacity of a non-empty container, so a new
        -: 2798:      --  internal array will be allocated. (The length of the new internal
        -: 2799:      --  array could be less or greater than the old internal array. We know
        -: 2800:      --  only that the length of the new internal array is greater than the
        -: 2801:      --  number of active elements in the container.) We must check whether
        -: 2802:      --  the container is busy before doing anything else.
        -: 2803:
    #####: 2804:      TC_Check (Container.TC);
        -: 2805:
        -: 2806:      --  We now allocate a new internal array, having a length different from
        -: 2807:      --  its current value.
        -: 2808:
        -: 2809:      declare
    #####: 2810:         E : Elements_Access := new Elements_Type (Last);
        -: 2811:
        -: 2812:      begin
        -: 2813:         --  We have successfully allocated the new internal array. We first
        -: 2814:         --  attempt to copy the existing elements from the old internal array
        -: 2815:         --  ("src" elements) onto the new internal array ("tgt" elements).
        -: 2816:
        -: 2817:         declare
    #####: 2818:            subtype Index_Subtype is Index_Type'Base range
    #####: 2819:              Index_Type'First .. Container.Last;
        -: 2820:
    #####: 2821:            Src : Elements_Array renames
    #####: 2822:                    Container.Elements.EA (Index_Subtype);
        -: 2823:
    #####: 2824:            Tgt : Elements_Array renames E.EA (Index_Subtype);
        -: 2825:
        -: 2826:         begin
    #####: 2827:            Tgt := Src;
        -: 2828:
        -: 2829:         exception
        -: 2830:            when others =>
        -: 2831:               Free (E);
        -: 2832:               raise;
        -: 2833:         end;
        -: 2834:
        -: 2835:         --  We have successfully copied the existing elements onto the new
        -: 2836:         --  internal array, so now we can attempt to deallocate the old one.
        -: 2837:
        -: 2838:         declare
    #####: 2839:            X : Elements_Access := Container.Elements;
        -: 2840:
        -: 2841:         begin
        -: 2842:            --  First we isolate the old internal array, and replace it in the
        -: 2843:            --  container with the new internal array.
        -: 2844:
    #####: 2845:            Container.Elements := E;
        -: 2846:
        -: 2847:            --  Container invariants have been restored, so it is now safe to
        -: 2848:            --  attempt to deallocate the old internal array.
        -: 2849:
    #####: 2850:            Free (X);
        -: 2851:         end;
        -: 2852:      end;
        -: 2853:   end Reserve_Capacity;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reserve_capacity.600:
    #####: 2553:   procedure Reserve_Capacity
        -: 2554:     (Container : in out Vector;
        -: 2555:      Capacity  : Count_Type)
        -: 2556:   is
    #####: 2557:      N : constant Count_Type := Length (Container);
        -: 2558:
        -: 2559:      Index : Count_Type'Base;
        -: 2560:      Last  : Index_Type'Base;
        -: 2561:
        -: 2562:   begin
        -: 2563:      --  Reserve_Capacity can be used to either expand the storage available
        -: 2564:      --  for elements (this would be its typical use, in anticipation of
        -: 2565:      --  future insertion), or to trim back storage. In the latter case,
        -: 2566:      --  storage can only be trimmed back to the limit of the container
        -: 2567:      --  length. Note that Reserve_Capacity neither deletes (active) elements
        -: 2568:      --  nor inserts elements; it only affects container capacity, never
        -: 2569:      --  container length.
        -: 2570:
    #####: 2571:      if Capacity = 0 then
        -: 2572:
        -: 2573:         --  This is a request to trim back storage, to the minimum amount
        -: 2574:         --  possible given the current state of the container.
        -: 2575:
    #####: 2576:         if N = 0 then
        -: 2577:
        -: 2578:            --  The container is empty, so in this unique case we can
        -: 2579:            --  deallocate the entire internal array. Note that an empty
        -: 2580:            --  container can never be busy, so there's no need to check the
        -: 2581:            --  tampering bits.
        -: 2582:
        -: 2583:            declare
    #####: 2584:               X : Elements_Access := Container.Elements;
        -: 2585:
        -: 2586:            begin
        -: 2587:               --  First we remove the internal array from the container, to
        -: 2588:               --  handle the case when the deallocation raises an exception.
        -: 2589:
    #####: 2590:               Container.Elements := null;
        -: 2591:
        -: 2592:               --  Container invariants have been restored, so it is now safe
        -: 2593:               --  to attempt to deallocate the internal array.
        -: 2594:
    #####: 2595:               Free (X);
        -: 2596:            end;
        -: 2597:
    #####: 2598:         elsif N < Container.Elements.EA'Length then
        -: 2599:
        -: 2600:            --  The container is not empty, and the current length is less than
        -: 2601:            --  the current capacity, so there's storage available to trim. In
        -: 2602:            --  this case, we allocate a new internal array having a length
        -: 2603:            --  that exactly matches the number of items in the
        -: 2604:            --  container. (Reserve_Capacity does not delete active elements,
        -: 2605:            --  so this is the best we can do with respect to minimizing
        -: 2606:            --  storage).
        -: 2607:
    #####: 2608:            TC_Check (Container.TC);
        -: 2609:
        -: 2610:            declare
    #####: 2611:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2612:                 Index_Type'First .. Container.Last;
        -: 2613:
    #####: 2614:               Src : Elements_Array renames
    #####: 2615:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2616:
    #####: 2617:               X : Elements_Access := Container.Elements;
        -: 2618:
        -: 2619:            begin
        -: 2620:               --  Although we have isolated the old internal array that we're
        -: 2621:               --  going to deallocate, we don't deallocate it until we have
        -: 2622:               --  successfully allocated a new one. If there is an exception
        -: 2623:               --  during allocation (either because there is not enough
        -: 2624:               --  storage, or because initialization of the elements fails),
        -: 2625:               --  we let it propagate without causing any side-effect.
        -: 2626:
    #####: 2627:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2628:
        -: 2629:               --  We have successfully allocated a new internal array (with a
        -: 2630:               --  smaller length than the old one, and containing a copy of
        -: 2631:               --  just the active elements in the container), so it is now
        -: 2632:               --  safe to attempt to deallocate the old array. The old array
        -: 2633:               --  has been isolated, and container invariants have been
        -: 2634:               --  restored, so if the deallocation fails (because finalization
        -: 2635:               --  of the elements fails), we simply let it propagate.
        -: 2636:
    #####: 2637:               Free (X);
        -: 2638:            end;
        -: 2639:         end if;
        -: 2640:
    #####: 2641:         return;
        -: 2642:      end if;
        -: 2643:
        -: 2644:      --  Reserve_Capacity can be used to expand the storage available for
        -: 2645:      --  elements, but we do not let the capacity grow beyond the number of
        -: 2646:      --  values in Index_Type'Range. (Were it otherwise, there would be no way
        -: 2647:      --  to refer to the elements with an index value greater than
        -: 2648:      --  Index_Type'Last, so that storage would be wasted.) Here we compute
        -: 2649:      --  the Last index value of the new internal array, in a way that avoids
        -: 2650:      --  any possibility of overflow.
        -: 2651:
        -: 2652:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 2653:
        -: 2654:         --  We perform a two-part test. First we determine whether the
        -: 2655:         --  computed Last value lies in the base range of the type, and then
        -: 2656:         --  determine whether it lies in the range of the index (sub)type.
        -: 2657:
        -: 2658:         --  Last must satisfy this relation:
        -: 2659:         --    First + Length - 1 <= Last
        -: 2660:         --  We regroup terms:
        -: 2661:         --    First - 1 <= Last - Length
        -: 2662:         --  Which can rewrite as:
        -: 2663:         --    No_Index <= Last - Length
        -: 2664:
        -: 2665:         if Checks and then
    #####: 2666:           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index
        -: 2667:         then
    #####: 2668:            raise Constraint_Error with "Capacity is out of range";
        -: 2669:         end if;
        -: 2670:
        -: 2671:         --  We now know that the computed value of Last is within the base
        -: 2672:         --  range of the type, so it is safe to compute its value:
        -: 2673:
    #####: 2674:         Last := No_Index + Index_Type'Base (Capacity);
        -: 2675:
        -: 2676:         --  Finally we test whether the value is within the range of the
        -: 2677:         --  generic actual index subtype:
        -: 2678:
        -: 2679:         if Checks and then Last > Index_Type'Last then
        -: 2680:            raise Constraint_Error with "Capacity is out of range";
        -: 2681:         end if;
        -: 2682:
        -: 2683:      elsif Index_Type'First <= 0 then
        -: 2684:
        -: 2685:         --  Here we can compute Last directly, in the normal way. We know that
        -: 2686:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 2687:         --  adding the (positive) value of Capacity.
        -: 2688:
        -: 2689:         Index := Count_Type'Base (No_Index) + Capacity;  -- Last
        -: 2690:
        -: 2691:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 2692:            raise Constraint_Error with "Capacity is out of range";
        -: 2693:         end if;
        -: 2694:
        -: 2695:         --  We know that the computed value (having type Count_Type) of Last
        -: 2696:         --  is within the range of the generic actual index subtype, so it is
        -: 2697:         --  safe to convert to Index_Type:
        -: 2698:
        -: 2699:         Last := Index_Type'Base (Index);
        -: 2700:
        -: 2701:      else
        -: 2702:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 2703:         --  must test the length indirectly (by working backwards from the
        -: 2704:         --  largest possible value of Last), in order to prevent overflow.
        -: 2705:
        -: 2706:         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index
        -: 2707:
        -: 2708:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 2709:            raise Constraint_Error with "Capacity is out of range";
        -: 2710:         end if;
        -: 2711:
        -: 2712:         --  We have determined that the value of Capacity would not create a
        -: 2713:         --  Last index value outside of the range of Index_Type, so we can now
        -: 2714:         --  safely compute its value.
        -: 2715:
        -: 2716:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);
        -: 2717:      end if;
        -: 2718:
        -: 2719:      --  The requested capacity is non-zero, but we don't know yet whether
        -: 2720:      --  this is a request for expansion or contraction of storage.
        -: 2721:
    #####: 2722:      if Container.Elements = null then
        -: 2723:
        -: 2724:         --  The container is empty (it doesn't even have an internal array),
        -: 2725:         --  so this represents a request to allocate (expand) storage having
        -: 2726:         --  the given capacity.
        -: 2727:
    #####: 2728:         Container.Elements := new Elements_Type (Last);
    #####: 2729:         return;
        -: 2730:      end if;
        -: 2731:
    #####: 2732:      if Capacity <= N then
        -: 2733:
        -: 2734:         --  This is a request to trim back storage, but only to the limit of
        -: 2735:         --  what's already in the container. (Reserve_Capacity never deletes
        -: 2736:         --  active elements, it only reclaims excess storage.)
        -: 2737:
    #####: 2738:         if N < Container.Elements.EA'Length then
        -: 2739:
        -: 2740:            --  The container is not empty (because the requested capacity is
        -: 2741:            --  positive, and less than or equal to the container length), and
        -: 2742:            --  the current length is less than the current capacity, so
        -: 2743:            --  there's storage available to trim. In this case, we allocate a
        -: 2744:            --  new internal array having a length that exactly matches the
        -: 2745:            --  number of items in the container.
        -: 2746:
    #####: 2747:            TC_Check (Container.TC);
        -: 2748:
        -: 2749:            declare
    #####: 2750:               subtype Src_Index_Subtype is Index_Type'Base range
    #####: 2751:                 Index_Type'First .. Container.Last;
        -: 2752:
    #####: 2753:               Src : Elements_Array renames
    #####: 2754:                       Container.Elements.EA (Src_Index_Subtype);
        -: 2755:
    #####: 2756:               X : Elements_Access := Container.Elements;
        -: 2757:
        -: 2758:            begin
        -: 2759:               --  Although we have isolated the old internal array that we're
        -: 2760:               --  going to deallocate, we don't deallocate it until we have
        -: 2761:               --  successfully allocated a new one. If there is an exception
        -: 2762:               --  during allocation (either because there is not enough
        -: 2763:               --  storage, or because initialization of the elements fails),
        -: 2764:               --  we let it propagate without causing any side-effect.
        -: 2765:
    #####: 2766:               Container.Elements := new Elements_Type'(Container.Last, Src);
        -: 2767:
        -: 2768:               --  We have successfully allocated a new internal array (with a
        -: 2769:               --  smaller length than the old one, and containing a copy of
        -: 2770:               --  just the active elements in the container), so it is now
        -: 2771:               --  safe to attempt to deallocate the old array. The old array
        -: 2772:               --  has been isolated, and container invariants have been
        -: 2773:               --  restored, so if the deallocation fails (because finalization
        -: 2774:               --  of the elements fails), we simply let it propagate.
        -: 2775:
    #####: 2776:               Free (X);
        -: 2777:            end;
        -: 2778:         end if;
        -: 2779:
    #####: 2780:         return;
        -: 2781:      end if;
        -: 2782:
        -: 2783:      --  The requested capacity is larger than the container length (the
        -: 2784:      --  number of active elements). Whether this represents a request for
        -: 2785:      --  expansion or contraction of the current capacity depends on what the
        -: 2786:      --  current capacity is.
        -: 2787:
    #####: 2788:      if Capacity = Container.Elements.EA'Length then
        -: 2789:
        -: 2790:         --  The requested capacity matches the existing capacity, so there's
        -: 2791:         --  nothing to do here. We treat this case as a no-op, and simply
        -: 2792:         --  return without checking the busy bit.
        -: 2793:
    #####: 2794:         return;
        -: 2795:      end if;
        -: 2796:
        -: 2797:      --  There is a change in the capacity of a non-empty container, so a new
        -: 2798:      --  internal array will be allocated. (The length of the new internal
        -: 2799:      --  array could be less or greater than the old internal array. We know
        -: 2800:      --  only that the length of the new internal array is greater than the
        -: 2801:      --  number of active elements in the container.) We must check whether
        -: 2802:      --  the container is busy before doing anything else.
        -: 2803:
    #####: 2804:      TC_Check (Container.TC);
        -: 2805:
        -: 2806:      --  We now allocate a new internal array, having a length different from
        -: 2807:      --  its current value.
        -: 2808:
        -: 2809:      declare
    #####: 2810:         E : Elements_Access := new Elements_Type (Last);
        -: 2811:
        -: 2812:      begin
        -: 2813:         --  We have successfully allocated the new internal array. We first
        -: 2814:         --  attempt to copy the existing elements from the old internal array
        -: 2815:         --  ("src" elements) onto the new internal array ("tgt" elements).
        -: 2816:
        -: 2817:         declare
    #####: 2818:            subtype Index_Subtype is Index_Type'Base range
    #####: 2819:              Index_Type'First .. Container.Last;
        -: 2820:
    #####: 2821:            Src : Elements_Array renames
    #####: 2822:                    Container.Elements.EA (Index_Subtype);
        -: 2823:
    #####: 2824:            Tgt : Elements_Array renames E.EA (Index_Subtype);
        -: 2825:
        -: 2826:         begin
    #####: 2827:            Tgt := Src;
        -: 2828:
        -: 2829:         exception
        -: 2830:            when others =>
        -: 2831:               Free (E);
        -: 2832:               raise;
        -: 2833:         end;
        -: 2834:
        -: 2835:         --  We have successfully copied the existing elements onto the new
        -: 2836:         --  internal array, so now we can attempt to deallocate the old one.
        -: 2837:
        -: 2838:         declare
    #####: 2839:            X : Elements_Access := Container.Elements;
        -: 2840:
        -: 2841:         begin
        -: 2842:            --  First we isolate the old internal array, and replace it in the
        -: 2843:            --  container with the new internal array.
        -: 2844:
    #####: 2845:            Container.Elements := E;
        -: 2846:
        -: 2847:            --  Container invariants have been restored, so it is now safe to
        -: 2848:            --  attempt to deallocate the old internal array.
        -: 2849:
    #####: 2850:            Free (X);
        -: 2851:         end;
        -: 2852:      end;
        -: 2853:   end Reserve_Capacity;
------------------
        -: 2854:
        -: 2855:   ----------------------
        -: 2856:   -- Reverse_Elements --
        -: 2857:   ----------------------
        -: 2858:
    #####: 2859:   procedure Reverse_Elements (Container : in out Vector) is
        -: 2860:   begin
    #####: 2861:      if Container.Length <= 1 then
    #####: 2862:         return;
        -: 2863:      end if;
        -: 2864:
        -: 2865:      --  The exception behavior for the vector container must match that for
        -: 2866:      --  the list container, so we check for cursor tampering here (which will
        -: 2867:      --  catch more things) instead of for element tampering (which will catch
        -: 2868:      --  fewer things). It's true that the elements of this vector container
        -: 2869:      --  could be safely moved around while (say) an iteration is taking place
        -: 2870:      --  (iteration only increments the busy counter), and so technically
        -: 2871:      --  all we would need here is a test for element tampering (indicated
        -: 2872:      --  by the lock counter), that's simply an artifact of our array-based
        -: 2873:      --  implementation. Logically Reverse_Elements requires a check for
        -: 2874:      --  cursor tampering.
        -: 2875:
    #####: 2876:      TC_Check (Container.TC);
        -: 2877:
        -: 2878:      declare
        -: 2879:         K : Index_Type;
        -: 2880:         J : Index_Type;
    #####: 2881:         E : Elements_Type renames Container.Elements.all;
        -: 2882:
        -: 2883:      begin
    #####: 2884:         K := Index_Type'First;
    #####: 2885:         J := Container.Last;
    #####: 2886:         while K < J loop
        -: 2887:            declare
    #####: 2888:               EK : constant Element_Type := E.EA (K);
        -: 2889:            begin
    #####: 2890:               E.EA (K) := E.EA (J);
    #####: 2891:               E.EA (J) := EK;
    #####: 2892:            end;
        -: 2893:
    #####: 2894:            K := K + 1;
    #####: 2895:            J := J - 1;
    #####: 2896:         end loop;
        -: 2897:      end;
        -: 2898:   end Reverse_Elements;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reverse_elements.112:
    #####: 2859:   procedure Reverse_Elements (Container : in out Vector) is
        -: 2860:   begin
    #####: 2861:      if Container.Length <= 1 then
    #####: 2862:         return;
        -: 2863:      end if;
        -: 2864:
        -: 2865:      --  The exception behavior for the vector container must match that for
        -: 2866:      --  the list container, so we check for cursor tampering here (which will
        -: 2867:      --  catch more things) instead of for element tampering (which will catch
        -: 2868:      --  fewer things). It's true that the elements of this vector container
        -: 2869:      --  could be safely moved around while (say) an iteration is taking place
        -: 2870:      --  (iteration only increments the busy counter), and so technically
        -: 2871:      --  all we would need here is a test for element tampering (indicated
        -: 2872:      --  by the lock counter), that's simply an artifact of our array-based
        -: 2873:      --  implementation. Logically Reverse_Elements requires a check for
        -: 2874:      --  cursor tampering.
        -: 2875:
    #####: 2876:      TC_Check (Container.TC);
        -: 2877:
        -: 2878:      declare
        -: 2879:         K : Index_Type;
        -: 2880:         J : Index_Type;
    #####: 2881:         E : Elements_Type renames Container.Elements.all;
        -: 2882:
        -: 2883:      begin
    #####: 2884:         K := Index_Type'First;
    #####: 2885:         J := Container.Last;
    #####: 2886:         while K < J loop
        -: 2887:            declare
    #####: 2888:               EK : constant Element_Type := E.EA (K);
        -: 2889:            begin
    #####: 2890:               E.EA (K) := E.EA (J);
    #####: 2891:               E.EA (J) := EK;
        -: 2892:            end;
        -: 2893:
    #####: 2894:            K := K + 1;
    #####: 2895:            J := J - 1;
    #####: 2896:         end loop;
        -: 2897:      end;
        -: 2898:   end Reverse_Elements;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reverse_elements.239:
    #####: 2859:   procedure Reverse_Elements (Container : in out Vector) is
        -: 2860:   begin
    #####: 2861:      if Container.Length <= 1 then
    #####: 2862:         return;
        -: 2863:      end if;
        -: 2864:
        -: 2865:      --  The exception behavior for the vector container must match that for
        -: 2866:      --  the list container, so we check for cursor tampering here (which will
        -: 2867:      --  catch more things) instead of for element tampering (which will catch
        -: 2868:      --  fewer things). It's true that the elements of this vector container
        -: 2869:      --  could be safely moved around while (say) an iteration is taking place
        -: 2870:      --  (iteration only increments the busy counter), and so technically
        -: 2871:      --  all we would need here is a test for element tampering (indicated
        -: 2872:      --  by the lock counter), that's simply an artifact of our array-based
        -: 2873:      --  implementation. Logically Reverse_Elements requires a check for
        -: 2874:      --  cursor tampering.
        -: 2875:
    #####: 2876:      TC_Check (Container.TC);
        -: 2877:
        -: 2878:      declare
        -: 2879:         K : Index_Type;
        -: 2880:         J : Index_Type;
    #####: 2881:         E : Elements_Type renames Container.Elements.all;
        -: 2882:
        -: 2883:      begin
    #####: 2884:         K := Index_Type'First;
    #####: 2885:         J := Container.Last;
    #####: 2886:         while K < J loop
        -: 2887:            declare
    #####: 2888:               EK : constant Element_Type := E.EA (K);
        -: 2889:            begin
    #####: 2890:               E.EA (K) := E.EA (J);
    #####: 2891:               E.EA (J) := EK;
    #####: 2892:            end;
        -: 2893:
    #####: 2894:            K := K + 1;
    #####: 2895:            J := J - 1;
    #####: 2896:         end loop;
        -: 2897:      end;
        -: 2898:   end Reverse_Elements;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reverse_elements.471:
    #####: 2859:   procedure Reverse_Elements (Container : in out Vector) is
        -: 2860:   begin
    #####: 2861:      if Container.Length <= 1 then
    #####: 2862:         return;
        -: 2863:      end if;
        -: 2864:
        -: 2865:      --  The exception behavior for the vector container must match that for
        -: 2866:      --  the list container, so we check for cursor tampering here (which will
        -: 2867:      --  catch more things) instead of for element tampering (which will catch
        -: 2868:      --  fewer things). It's true that the elements of this vector container
        -: 2869:      --  could be safely moved around while (say) an iteration is taking place
        -: 2870:      --  (iteration only increments the busy counter), and so technically
        -: 2871:      --  all we would need here is a test for element tampering (indicated
        -: 2872:      --  by the lock counter), that's simply an artifact of our array-based
        -: 2873:      --  implementation. Logically Reverse_Elements requires a check for
        -: 2874:      --  cursor tampering.
        -: 2875:
    #####: 2876:      TC_Check (Container.TC);
        -: 2877:
        -: 2878:      declare
        -: 2879:         K : Index_Type;
        -: 2880:         J : Index_Type;
    #####: 2881:         E : Elements_Type renames Container.Elements.all;
        -: 2882:
        -: 2883:      begin
    #####: 2884:         K := Index_Type'First;
    #####: 2885:         J := Container.Last;
    #####: 2886:         while K < J loop
        -: 2887:            declare
    #####: 2888:               EK : constant Element_Type := E.EA (K);
        -: 2889:            begin
    #####: 2890:               E.EA (K) := E.EA (J);
    #####: 2891:               E.EA (J) := EK;
        -: 2892:            end;
        -: 2893:
    #####: 2894:            K := K + 1;
    #####: 2895:            J := J - 1;
    #####: 2896:         end loop;
        -: 2897:      end;
        -: 2898:   end Reverse_Elements;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reverse_elements.598:
    #####: 2859:   procedure Reverse_Elements (Container : in out Vector) is
        -: 2860:   begin
    #####: 2861:      if Container.Length <= 1 then
    #####: 2862:         return;
        -: 2863:      end if;
        -: 2864:
        -: 2865:      --  The exception behavior for the vector container must match that for
        -: 2866:      --  the list container, so we check for cursor tampering here (which will
        -: 2867:      --  catch more things) instead of for element tampering (which will catch
        -: 2868:      --  fewer things). It's true that the elements of this vector container
        -: 2869:      --  could be safely moved around while (say) an iteration is taking place
        -: 2870:      --  (iteration only increments the busy counter), and so technically
        -: 2871:      --  all we would need here is a test for element tampering (indicated
        -: 2872:      --  by the lock counter), that's simply an artifact of our array-based
        -: 2873:      --  implementation. Logically Reverse_Elements requires a check for
        -: 2874:      --  cursor tampering.
        -: 2875:
    #####: 2876:      TC_Check (Container.TC);
        -: 2877:
        -: 2878:      declare
        -: 2879:         K : Index_Type;
        -: 2880:         J : Index_Type;
    #####: 2881:         E : Elements_Type renames Container.Elements.all;
        -: 2882:
        -: 2883:      begin
    #####: 2884:         K := Index_Type'First;
    #####: 2885:         J := Container.Last;
    #####: 2886:         while K < J loop
        -: 2887:            declare
    #####: 2888:               EK : constant Element_Type := E.EA (K);
        -: 2889:            begin
    #####: 2890:               E.EA (K) := E.EA (J);
    #####: 2891:               E.EA (J) := EK;
    #####: 2892:            end;
        -: 2893:
    #####: 2894:            K := K + 1;
    #####: 2895:            J := J - 1;
    #####: 2896:         end loop;
        -: 2897:      end;
        -: 2898:   end Reverse_Elements;
------------------
        -: 2899:
        -: 2900:   ------------------
        -: 2901:   -- Reverse_Find --
        -: 2902:   ------------------
        -: 2903:
    #####: 2904:   function Reverse_Find
        -: 2905:     (Container : Vector;
        -: 2906:      Item      : Element_Type;
        -: 2907:      Position  : Cursor := No_Element) return Cursor
        -: 2908:   is
        -: 2909:      Last : Index_Type'Base;
        -: 2910:
        -: 2911:   begin
    #####: 2912:      if Checks and then Position.Container /= null
    #####: 2913:        and then Position.Container /= Container'Unrestricted_Access
        -: 2914:      then
    #####: 2915:         raise Program_Error with "Position cursor denotes wrong container";
        -: 2916:      end if;
        -: 2917:
    #####: 2918:      Last :=
    #####: 2919:        (if Position.Container = null or else Position.Index > Container.Last
        -: 2920:         then Container.Last
        -: 2921:         else Position.Index);
        -: 2922:
        -: 2923:      --  Per AI05-0022, the container implementation is required to detect
        -: 2924:      --  element tampering by a generic actual subprogram.
        -: 2925:
    #####: 2926:      declare
    #####: 2927:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2928:      begin
    #####: 2929:         for Indx in reverse Index_Type'First .. Last loop
    #####: 2930:            if Container.Elements.EA (Indx) = Item then
    #####: 2931:               return Cursor'(Container'Unrestricted_Access, Indx);
        -: 2932:            end if;
    #####: 2933:         end loop;
        -: 2934:
    #####: 2935:         return No_Element;
    #####: 2936:      end;
        -: 2937:   end Reverse_Find;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reverse_find.110:
    #####: 2904:   function Reverse_Find
        -: 2905:     (Container : Vector;
        -: 2906:      Item      : Element_Type;
        -: 2907:      Position  : Cursor := No_Element) return Cursor
        -: 2908:   is
        -: 2909:      Last : Index_Type'Base;
        -: 2910:
        -: 2911:   begin
    #####: 2912:      if Checks and then Position.Container /= null
    #####: 2913:        and then Position.Container /= Container'Unrestricted_Access
        -: 2914:      then
    #####: 2915:         raise Program_Error with "Position cursor denotes wrong container";
        -: 2916:      end if;
        -: 2917:
    #####: 2918:      Last :=
    #####: 2919:        (if Position.Container = null or else Position.Index > Container.Last
        -: 2920:         then Container.Last
        -: 2921:         else Position.Index);
        -: 2922:
        -: 2923:      --  Per AI05-0022, the container implementation is required to detect
        -: 2924:      --  element tampering by a generic actual subprogram.
        -: 2925:
    #####: 2926:      declare
    #####: 2927:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2928:      begin
    #####: 2929:         for Indx in reverse Index_Type'First .. Last loop
    #####: 2930:            if Container.Elements.EA (Indx) = Item then
    #####: 2931:               return Cursor'(Container'Unrestricted_Access, Indx);
        -: 2932:            end if;
    #####: 2933:         end loop;
        -: 2934:
    #####: 2935:         return No_Element;
    #####: 2936:      end;
        -: 2937:   end Reverse_Find;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reverse_find.237:
    #####: 2904:   function Reverse_Find
        -: 2905:     (Container : Vector;
        -: 2906:      Item      : Element_Type;
        -: 2907:      Position  : Cursor := No_Element) return Cursor
        -: 2908:   is
        -: 2909:      Last : Index_Type'Base;
        -: 2910:
        -: 2911:   begin
    #####: 2912:      if Checks and then Position.Container /= null
    #####: 2913:        and then Position.Container /= Container'Unrestricted_Access
        -: 2914:      then
    #####: 2915:         raise Program_Error with "Position cursor denotes wrong container";
        -: 2916:      end if;
        -: 2917:
    #####: 2918:      Last :=
    #####: 2919:        (if Position.Container = null or else Position.Index > Container.Last
        -: 2920:         then Container.Last
        -: 2921:         else Position.Index);
        -: 2922:
        -: 2923:      --  Per AI05-0022, the container implementation is required to detect
        -: 2924:      --  element tampering by a generic actual subprogram.
        -: 2925:
    #####: 2926:      declare
    #####: 2927:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2928:      begin
    #####: 2929:         for Indx in reverse Index_Type'First .. Last loop
    #####: 2930:            if Container.Elements.EA (Indx) = Item then
    #####: 2931:               return Cursor'(Container'Unrestricted_Access, Indx);
        -: 2932:            end if;
    #####: 2933:         end loop;
        -: 2934:
    #####: 2935:         return No_Element;
    #####: 2936:      end;
        -: 2937:   end Reverse_Find;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reverse_find.469:
    #####: 2904:   function Reverse_Find
        -: 2905:     (Container : Vector;
        -: 2906:      Item      : Element_Type;
        -: 2907:      Position  : Cursor := No_Element) return Cursor
        -: 2908:   is
        -: 2909:      Last : Index_Type'Base;
        -: 2910:
        -: 2911:   begin
    #####: 2912:      if Checks and then Position.Container /= null
    #####: 2913:        and then Position.Container /= Container'Unrestricted_Access
        -: 2914:      then
    #####: 2915:         raise Program_Error with "Position cursor denotes wrong container";
        -: 2916:      end if;
        -: 2917:
    #####: 2918:      Last :=
    #####: 2919:        (if Position.Container = null or else Position.Index > Container.Last
        -: 2920:         then Container.Last
        -: 2921:         else Position.Index);
        -: 2922:
        -: 2923:      --  Per AI05-0022, the container implementation is required to detect
        -: 2924:      --  element tampering by a generic actual subprogram.
        -: 2925:
    #####: 2926:      declare
    #####: 2927:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2928:      begin
    #####: 2929:         for Indx in reverse Index_Type'First .. Last loop
    #####: 2930:            if Container.Elements.EA (Indx) = Item then
    #####: 2931:               return Cursor'(Container'Unrestricted_Access, Indx);
        -: 2932:            end if;
    #####: 2933:         end loop;
        -: 2934:
    #####: 2935:         return No_Element;
    #####: 2936:      end;
        -: 2937:   end Reverse_Find;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reverse_find.596:
    #####: 2904:   function Reverse_Find
        -: 2905:     (Container : Vector;
        -: 2906:      Item      : Element_Type;
        -: 2907:      Position  : Cursor := No_Element) return Cursor
        -: 2908:   is
        -: 2909:      Last : Index_Type'Base;
        -: 2910:
        -: 2911:   begin
    #####: 2912:      if Checks and then Position.Container /= null
    #####: 2913:        and then Position.Container /= Container'Unrestricted_Access
        -: 2914:      then
    #####: 2915:         raise Program_Error with "Position cursor denotes wrong container";
        -: 2916:      end if;
        -: 2917:
    #####: 2918:      Last :=
    #####: 2919:        (if Position.Container = null or else Position.Index > Container.Last
        -: 2920:         then Container.Last
        -: 2921:         else Position.Index);
        -: 2922:
        -: 2923:      --  Per AI05-0022, the container implementation is required to detect
        -: 2924:      --  element tampering by a generic actual subprogram.
        -: 2925:
    #####: 2926:      declare
    #####: 2927:         Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2928:      begin
    #####: 2929:         for Indx in reverse Index_Type'First .. Last loop
    #####: 2930:            if Container.Elements.EA (Indx) = Item then
    #####: 2931:               return Cursor'(Container'Unrestricted_Access, Indx);
        -: 2932:            end if;
    #####: 2933:         end loop;
        -: 2934:
    #####: 2935:         return No_Element;
    #####: 2936:      end;
        -: 2937:   end Reverse_Find;
------------------
        -: 2938:
        -: 2939:   ------------------------
        -: 2940:   -- Reverse_Find_Index --
        -: 2941:   ------------------------
        -: 2942:
    #####: 2943:   function Reverse_Find_Index
        -: 2944:     (Container : Vector;
        -: 2945:      Item      : Element_Type;
        -: 2946:      Index     : Index_Type := Index_Type'Last) return Extended_Index
        -: 2947:   is
        -: 2948:      --  Per AI05-0022, the container implementation is required to detect
        -: 2949:      --  element tampering by a generic actual subprogram.
        -: 2950:
    #####: 2951:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2952:
    #####: 2953:      Last : constant Index_Type'Base :=
    #####: 2954:        Index_Type'Min (Container.Last, Index);
        -: 2955:
        -: 2956:   begin
    #####: 2957:      for Indx in reverse Index_Type'First .. Last loop
    #####: 2958:         if Container.Elements.EA (Indx) = Item then
    #####: 2959:            return Indx;
        -: 2960:         end if;
    #####: 2961:      end loop;
        -: 2962:
    #####: 2963:      return No_Index;
    #####: 2964:   end Reverse_Find_Index;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reverse_find_index.108:
    #####: 2943:   function Reverse_Find_Index
        -: 2944:     (Container : Vector;
        -: 2945:      Item      : Element_Type;
        -: 2946:      Index     : Index_Type := Index_Type'Last) return Extended_Index
        -: 2947:   is
        -: 2948:      --  Per AI05-0022, the container implementation is required to detect
        -: 2949:      --  element tampering by a generic actual subprogram.
        -: 2950:
    #####: 2951:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2952:
    #####: 2953:      Last : constant Index_Type'Base :=
    #####: 2954:        Index_Type'Min (Container.Last, Index);
        -: 2955:
        -: 2956:   begin
    #####: 2957:      for Indx in reverse Index_Type'First .. Last loop
    #####: 2958:         if Container.Elements.EA (Indx) = Item then
    #####: 2959:            return Indx;
        -: 2960:         end if;
    #####: 2961:      end loop;
        -: 2962:
    #####: 2963:      return No_Index;
    #####: 2964:   end Reverse_Find_Index;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reverse_find_index.235:
    #####: 2943:   function Reverse_Find_Index
        -: 2944:     (Container : Vector;
        -: 2945:      Item      : Element_Type;
        -: 2946:      Index     : Index_Type := Index_Type'Last) return Extended_Index
        -: 2947:   is
        -: 2948:      --  Per AI05-0022, the container implementation is required to detect
        -: 2949:      --  element tampering by a generic actual subprogram.
        -: 2950:
    #####: 2951:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2952:
    #####: 2953:      Last : constant Index_Type'Base :=
    #####: 2954:        Index_Type'Min (Container.Last, Index);
        -: 2955:
        -: 2956:   begin
    #####: 2957:      for Indx in reverse Index_Type'First .. Last loop
    #####: 2958:         if Container.Elements.EA (Indx) = Item then
    #####: 2959:            return Indx;
        -: 2960:         end if;
    #####: 2961:      end loop;
        -: 2962:
    #####: 2963:      return No_Index;
    #####: 2964:   end Reverse_Find_Index;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reverse_find_index.467:
    #####: 2943:   function Reverse_Find_Index
        -: 2944:     (Container : Vector;
        -: 2945:      Item      : Element_Type;
        -: 2946:      Index     : Index_Type := Index_Type'Last) return Extended_Index
        -: 2947:   is
        -: 2948:      --  Per AI05-0022, the container implementation is required to detect
        -: 2949:      --  element tampering by a generic actual subprogram.
        -: 2950:
    #####: 2951:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2952:
    #####: 2953:      Last : constant Index_Type'Base :=
    #####: 2954:        Index_Type'Min (Container.Last, Index);
        -: 2955:
        -: 2956:   begin
    #####: 2957:      for Indx in reverse Index_Type'First .. Last loop
    #####: 2958:         if Container.Elements.EA (Indx) = Item then
    #####: 2959:            return Indx;
        -: 2960:         end if;
    #####: 2961:      end loop;
        -: 2962:
    #####: 2963:      return No_Index;
    #####: 2964:   end Reverse_Find_Index;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reverse_find_index.594:
    #####: 2943:   function Reverse_Find_Index
        -: 2944:     (Container : Vector;
        -: 2945:      Item      : Element_Type;
        -: 2946:      Index     : Index_Type := Index_Type'Last) return Extended_Index
        -: 2947:   is
        -: 2948:      --  Per AI05-0022, the container implementation is required to detect
        -: 2949:      --  element tampering by a generic actual subprogram.
        -: 2950:
    #####: 2951:      Lock : With_Lock (Container.TC'Unrestricted_Access);
        -: 2952:
    #####: 2953:      Last : constant Index_Type'Base :=
    #####: 2954:        Index_Type'Min (Container.Last, Index);
        -: 2955:
        -: 2956:   begin
    #####: 2957:      for Indx in reverse Index_Type'First .. Last loop
    #####: 2958:         if Container.Elements.EA (Indx) = Item then
    #####: 2959:            return Indx;
        -: 2960:         end if;
    #####: 2961:      end loop;
        -: 2962:
    #####: 2963:      return No_Index;
    #####: 2964:   end Reverse_Find_Index;
------------------
        -: 2965:
        -: 2966:   ---------------------
        -: 2967:   -- Reverse_Iterate --
        -: 2968:   ---------------------
        -: 2969:
    #####: 2970:   procedure Reverse_Iterate
        -: 2971:     (Container : Vector;
        -: 2972:      Process   : not null access procedure (Position : Cursor))
        -: 2973:   is
    #####: 2974:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2975:   begin
    #####: 2976:      for Indx in reverse Index_Type'First .. Container.Last loop
    #####: 2977:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2978:      end loop;
    #####: 2979:   end Reverse_Iterate;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__reverse_iterate.105:
    #####: 2970:   procedure Reverse_Iterate
        -: 2971:     (Container : Vector;
        -: 2972:      Process   : not null access procedure (Position : Cursor))
        -: 2973:   is
    #####: 2974:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2975:   begin
    #####: 2976:      for Indx in reverse Index_Type'First .. Container.Last loop
    #####: 2977:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2978:      end loop;
    #####: 2979:   end Reverse_Iterate;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__reverse_iterate.232:
    #####: 2970:   procedure Reverse_Iterate
        -: 2971:     (Container : Vector;
        -: 2972:      Process   : not null access procedure (Position : Cursor))
        -: 2973:   is
    #####: 2974:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2975:   begin
    #####: 2976:      for Indx in reverse Index_Type'First .. Container.Last loop
    #####: 2977:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2978:      end loop;
    #####: 2979:   end Reverse_Iterate;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__reverse_iterate.464:
    #####: 2970:   procedure Reverse_Iterate
        -: 2971:     (Container : Vector;
        -: 2972:      Process   : not null access procedure (Position : Cursor))
        -: 2973:   is
    #####: 2974:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2975:   begin
    #####: 2976:      for Indx in reverse Index_Type'First .. Container.Last loop
    #####: 2977:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2978:      end loop;
    #####: 2979:   end Reverse_Iterate;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__reverse_iterate.591:
    #####: 2970:   procedure Reverse_Iterate
        -: 2971:     (Container : Vector;
        -: 2972:      Process   : not null access procedure (Position : Cursor))
        -: 2973:   is
    #####: 2974:      Busy : With_Busy (Container.TC'Unrestricted_Access);
        -: 2975:   begin
    #####: 2976:      for Indx in reverse Index_Type'First .. Container.Last loop
    #####: 2977:         Process (Cursor'(Container'Unrestricted_Access, Indx));
    #####: 2978:      end loop;
    #####: 2979:   end Reverse_Iterate;
------------------
        -: 2980:
        -: 2981:   ----------------
        -: 2982:   -- Set_Length --
        -: 2983:   ----------------
        -: 2984:
    #####: 2985:   procedure Set_Length (Container : in out Vector; Length : Count_Type) is
    #####: 2986:      Count : constant Count_Type'Base := Container.Length - Length;
        -: 2987:
        -: 2988:   begin
        -: 2989:      --  Set_Length allows the user to set the length explicitly, instead
        -: 2990:      --  of implicitly as a side-effect of deletion or insertion. If the
        -: 2991:      --  requested length is less than the current length, this is equivalent
        -: 2992:      --  to deleting items from the back end of the vector. If the requested
        -: 2993:      --  length is greater than the current length, then this is equivalent
        -: 2994:      --  to inserting "space" (nonce items) at the end.
        -: 2995:
    #####: 2996:      if Count >= 0 then
    #####: 2997:         Container.Delete_Last (Count);
        -: 2998:
    #####: 2999:      elsif Checks and then Container.Last >= Index_Type'Last then
    #####: 3000:         raise Constraint_Error with "vector is already at its maximum length";
        -: 3001:
        -: 3002:      else
    #####: 3003:         Container.Insert_Space (Container.Last + 1, -Count);
        -: 3004:      end if;
    #####: 3005:   end Set_Length;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__set_length.104:
    #####: 2985:   procedure Set_Length (Container : in out Vector; Length : Count_Type) is
    #####: 2986:      Count : constant Count_Type'Base := Container.Length - Length;
        -: 2987:
        -: 2988:   begin
        -: 2989:      --  Set_Length allows the user to set the length explicitly, instead
        -: 2990:      --  of implicitly as a side-effect of deletion or insertion. If the
        -: 2991:      --  requested length is less than the current length, this is equivalent
        -: 2992:      --  to deleting items from the back end of the vector. If the requested
        -: 2993:      --  length is greater than the current length, then this is equivalent
        -: 2994:      --  to inserting "space" (nonce items) at the end.
        -: 2995:
    #####: 2996:      if Count >= 0 then
    #####: 2997:         Container.Delete_Last (Count);
        -: 2998:
    #####: 2999:      elsif Checks and then Container.Last >= Index_Type'Last then
    #####: 3000:         raise Constraint_Error with "vector is already at its maximum length";
        -: 3001:
        -: 3002:      else
    #####: 3003:         Container.Insert_Space (Container.Last + 1, -Count);
        -: 3004:      end if;
    #####: 3005:   end Set_Length;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__set_length.231:
    #####: 2985:   procedure Set_Length (Container : in out Vector; Length : Count_Type) is
    #####: 2986:      Count : constant Count_Type'Base := Container.Length - Length;
        -: 2987:
        -: 2988:   begin
        -: 2989:      --  Set_Length allows the user to set the length explicitly, instead
        -: 2990:      --  of implicitly as a side-effect of deletion or insertion. If the
        -: 2991:      --  requested length is less than the current length, this is equivalent
        -: 2992:      --  to deleting items from the back end of the vector. If the requested
        -: 2993:      --  length is greater than the current length, then this is equivalent
        -: 2994:      --  to inserting "space" (nonce items) at the end.
        -: 2995:
    #####: 2996:      if Count >= 0 then
    #####: 2997:         Container.Delete_Last (Count);
        -: 2998:
    #####: 2999:      elsif Checks and then Container.Last >= Index_Type'Last then
    #####: 3000:         raise Constraint_Error with "vector is already at its maximum length";
        -: 3001:
        -: 3002:      else
    #####: 3003:         Container.Insert_Space (Container.Last + 1, -Count);
        -: 3004:      end if;
    #####: 3005:   end Set_Length;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__set_length.463:
    #####: 2985:   procedure Set_Length (Container : in out Vector; Length : Count_Type) is
    #####: 2986:      Count : constant Count_Type'Base := Container.Length - Length;
        -: 2987:
        -: 2988:   begin
        -: 2989:      --  Set_Length allows the user to set the length explicitly, instead
        -: 2990:      --  of implicitly as a side-effect of deletion or insertion. If the
        -: 2991:      --  requested length is less than the current length, this is equivalent
        -: 2992:      --  to deleting items from the back end of the vector. If the requested
        -: 2993:      --  length is greater than the current length, then this is equivalent
        -: 2994:      --  to inserting "space" (nonce items) at the end.
        -: 2995:
    #####: 2996:      if Count >= 0 then
    #####: 2997:         Container.Delete_Last (Count);
        -: 2998:
    #####: 2999:      elsif Checks and then Container.Last >= Index_Type'Last then
    #####: 3000:         raise Constraint_Error with "vector is already at its maximum length";
        -: 3001:
        -: 3002:      else
    #####: 3003:         Container.Insert_Space (Container.Last + 1, -Count);
        -: 3004:      end if;
    #####: 3005:   end Set_Length;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__set_length.590:
    #####: 2985:   procedure Set_Length (Container : in out Vector; Length : Count_Type) is
    #####: 2986:      Count : constant Count_Type'Base := Container.Length - Length;
        -: 2987:
        -: 2988:   begin
        -: 2989:      --  Set_Length allows the user to set the length explicitly, instead
        -: 2990:      --  of implicitly as a side-effect of deletion or insertion. If the
        -: 2991:      --  requested length is less than the current length, this is equivalent
        -: 2992:      --  to deleting items from the back end of the vector. If the requested
        -: 2993:      --  length is greater than the current length, then this is equivalent
        -: 2994:      --  to inserting "space" (nonce items) at the end.
        -: 2995:
    #####: 2996:      if Count >= 0 then
    #####: 2997:         Container.Delete_Last (Count);
        -: 2998:
    #####: 2999:      elsif Checks and then Container.Last >= Index_Type'Last then
    #####: 3000:         raise Constraint_Error with "vector is already at its maximum length";
        -: 3001:
        -: 3002:      else
    #####: 3003:         Container.Insert_Space (Container.Last + 1, -Count);
        -: 3004:      end if;
    #####: 3005:   end Set_Length;
------------------
        -: 3006:
        -: 3007:   ----------
        -: 3008:   -- Swap --
        -: 3009:   ----------
        -: 3010:
    #####: 3011:   procedure Swap (Container : in out Vector; I, J : Index_Type) is
        -: 3012:   begin
    #####: 3013:      TE_Check (Container.TC);
        -: 3014:
        -: 3015:      if Checks then
    #####: 3016:         if I > Container.Last then
    #####: 3017:            raise Constraint_Error with "I index is out of range";
        -: 3018:         end if;
        -: 3019:
    #####: 3020:         if J > Container.Last then
    #####: 3021:            raise Constraint_Error with "J index is out of range";
        -: 3022:         end if;
        -: 3023:      end if;
        -: 3024:
    #####: 3025:      if I = J then
    #####: 3026:         return;
        -: 3027:      end if;
        -: 3028:
        -: 3029:      declare
    #####: 3030:         EI_Copy : constant Element_Type := Container.Elements.EA (I);
        -: 3031:      begin
    #####: 3032:         Container.Elements.EA (I) := Container.Elements.EA (J);
    #####: 3033:         Container.Elements.EA (J) := EI_Copy;
    #####: 3034:      end;
        -: 3035:   end Swap;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__swap.102:
    #####: 3011:   procedure Swap (Container : in out Vector; I, J : Index_Type) is
        -: 3012:   begin
    #####: 3013:      TE_Check (Container.TC);
        -: 3014:
        -: 3015:      if Checks then
    #####: 3016:         if I > Container.Last then
    #####: 3017:            raise Constraint_Error with "I index is out of range";
        -: 3018:         end if;
        -: 3019:
    #####: 3020:         if J > Container.Last then
    #####: 3021:            raise Constraint_Error with "J index is out of range";
        -: 3022:         end if;
        -: 3023:      end if;
        -: 3024:
    #####: 3025:      if I = J then
    #####: 3026:         return;
        -: 3027:      end if;
        -: 3028:
        -: 3029:      declare
    #####: 3030:         EI_Copy : constant Element_Type := Container.Elements.EA (I);
        -: 3031:      begin
    #####: 3032:         Container.Elements.EA (I) := Container.Elements.EA (J);
    #####: 3033:         Container.Elements.EA (J) := EI_Copy;
        -: 3034:      end;
        -: 3035:   end Swap;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__swap.229:
    #####: 3011:   procedure Swap (Container : in out Vector; I, J : Index_Type) is
        -: 3012:   begin
    #####: 3013:      TE_Check (Container.TC);
        -: 3014:
        -: 3015:      if Checks then
    #####: 3016:         if I > Container.Last then
    #####: 3017:            raise Constraint_Error with "I index is out of range";
        -: 3018:         end if;
        -: 3019:
    #####: 3020:         if J > Container.Last then
    #####: 3021:            raise Constraint_Error with "J index is out of range";
        -: 3022:         end if;
        -: 3023:      end if;
        -: 3024:
    #####: 3025:      if I = J then
    #####: 3026:         return;
        -: 3027:      end if;
        -: 3028:
        -: 3029:      declare
    #####: 3030:         EI_Copy : constant Element_Type := Container.Elements.EA (I);
        -: 3031:      begin
    #####: 3032:         Container.Elements.EA (I) := Container.Elements.EA (J);
    #####: 3033:         Container.Elements.EA (J) := EI_Copy;
    #####: 3034:      end;
        -: 3035:   end Swap;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__swap.461:
    #####: 3011:   procedure Swap (Container : in out Vector; I, J : Index_Type) is
        -: 3012:   begin
    #####: 3013:      TE_Check (Container.TC);
        -: 3014:
        -: 3015:      if Checks then
    #####: 3016:         if I > Container.Last then
    #####: 3017:            raise Constraint_Error with "I index is out of range";
        -: 3018:         end if;
        -: 3019:
    #####: 3020:         if J > Container.Last then
    #####: 3021:            raise Constraint_Error with "J index is out of range";
        -: 3022:         end if;
        -: 3023:      end if;
        -: 3024:
    #####: 3025:      if I = J then
    #####: 3026:         return;
        -: 3027:      end if;
        -: 3028:
        -: 3029:      declare
    #####: 3030:         EI_Copy : constant Element_Type := Container.Elements.EA (I);
        -: 3031:      begin
    #####: 3032:         Container.Elements.EA (I) := Container.Elements.EA (J);
    #####: 3033:         Container.Elements.EA (J) := EI_Copy;
        -: 3034:      end;
        -: 3035:   end Swap;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__swap.588:
    #####: 3011:   procedure Swap (Container : in out Vector; I, J : Index_Type) is
        -: 3012:   begin
    #####: 3013:      TE_Check (Container.TC);
        -: 3014:
        -: 3015:      if Checks then
    #####: 3016:         if I > Container.Last then
    #####: 3017:            raise Constraint_Error with "I index is out of range";
        -: 3018:         end if;
        -: 3019:
    #####: 3020:         if J > Container.Last then
    #####: 3021:            raise Constraint_Error with "J index is out of range";
        -: 3022:         end if;
        -: 3023:      end if;
        -: 3024:
    #####: 3025:      if I = J then
    #####: 3026:         return;
        -: 3027:      end if;
        -: 3028:
        -: 3029:      declare
    #####: 3030:         EI_Copy : constant Element_Type := Container.Elements.EA (I);
        -: 3031:      begin
    #####: 3032:         Container.Elements.EA (I) := Container.Elements.EA (J);
    #####: 3033:         Container.Elements.EA (J) := EI_Copy;
    #####: 3034:      end;
        -: 3035:   end Swap;
------------------
        -: 3036:
    #####: 3037:   procedure Swap (Container : in out Vector; I, J : Cursor) is
        -: 3038:   begin
        -: 3039:      if Checks then
    #####: 3040:         if I.Container = null then
    #####: 3041:            raise Constraint_Error with "I cursor has no element";
        -: 3042:
    #####: 3043:         elsif J.Container = null then
    #####: 3044:            raise Constraint_Error with "J cursor has no element";
        -: 3045:
    #####: 3046:         elsif I.Container /= Container'Unrestricted_Access then
    #####: 3047:            raise Program_Error with "I cursor denotes wrong container";
        -: 3048:
    #####: 3049:         elsif J.Container /= Container'Unrestricted_Access then
    #####: 3050:            raise Program_Error with "J cursor denotes wrong container";
        -: 3051:         end if;
        -: 3052:      end if;
        -: 3053:
    #####: 3054:      Swap (Container, I.Index, J.Index);
    #####: 3055:   end Swap;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__swap__2.101:
    #####: 3037:   procedure Swap (Container : in out Vector; I, J : Cursor) is
        -: 3038:   begin
        -: 3039:      if Checks then
    #####: 3040:         if I.Container = null then
    #####: 3041:            raise Constraint_Error with "I cursor has no element";
        -: 3042:
    #####: 3043:         elsif J.Container = null then
    #####: 3044:            raise Constraint_Error with "J cursor has no element";
        -: 3045:
    #####: 3046:         elsif I.Container /= Container'Unrestricted_Access then
    #####: 3047:            raise Program_Error with "I cursor denotes wrong container";
        -: 3048:
    #####: 3049:         elsif J.Container /= Container'Unrestricted_Access then
    #####: 3050:            raise Program_Error with "J cursor denotes wrong container";
        -: 3051:         end if;
        -: 3052:      end if;
        -: 3053:
    #####: 3054:      Swap (Container, I.Index, J.Index);
    #####: 3055:   end Swap;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__swap__2.228:
    #####: 3037:   procedure Swap (Container : in out Vector; I, J : Cursor) is
        -: 3038:   begin
        -: 3039:      if Checks then
    #####: 3040:         if I.Container = null then
    #####: 3041:            raise Constraint_Error with "I cursor has no element";
        -: 3042:
    #####: 3043:         elsif J.Container = null then
    #####: 3044:            raise Constraint_Error with "J cursor has no element";
        -: 3045:
    #####: 3046:         elsif I.Container /= Container'Unrestricted_Access then
    #####: 3047:            raise Program_Error with "I cursor denotes wrong container";
        -: 3048:
    #####: 3049:         elsif J.Container /= Container'Unrestricted_Access then
    #####: 3050:            raise Program_Error with "J cursor denotes wrong container";
        -: 3051:         end if;
        -: 3052:      end if;
        -: 3053:
    #####: 3054:      Swap (Container, I.Index, J.Index);
    #####: 3055:   end Swap;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__swap__2.460:
    #####: 3037:   procedure Swap (Container : in out Vector; I, J : Cursor) is
        -: 3038:   begin
        -: 3039:      if Checks then
    #####: 3040:         if I.Container = null then
    #####: 3041:            raise Constraint_Error with "I cursor has no element";
        -: 3042:
    #####: 3043:         elsif J.Container = null then
    #####: 3044:            raise Constraint_Error with "J cursor has no element";
        -: 3045:
    #####: 3046:         elsif I.Container /= Container'Unrestricted_Access then
    #####: 3047:            raise Program_Error with "I cursor denotes wrong container";
        -: 3048:
    #####: 3049:         elsif J.Container /= Container'Unrestricted_Access then
    #####: 3050:            raise Program_Error with "J cursor denotes wrong container";
        -: 3051:         end if;
        -: 3052:      end if;
        -: 3053:
    #####: 3054:      Swap (Container, I.Index, J.Index);
    #####: 3055:   end Swap;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__swap__2.587:
    #####: 3037:   procedure Swap (Container : in out Vector; I, J : Cursor) is
        -: 3038:   begin
        -: 3039:      if Checks then
    #####: 3040:         if I.Container = null then
    #####: 3041:            raise Constraint_Error with "I cursor has no element";
        -: 3042:
    #####: 3043:         elsif J.Container = null then
    #####: 3044:            raise Constraint_Error with "J cursor has no element";
        -: 3045:
    #####: 3046:         elsif I.Container /= Container'Unrestricted_Access then
    #####: 3047:            raise Program_Error with "I cursor denotes wrong container";
        -: 3048:
    #####: 3049:         elsif J.Container /= Container'Unrestricted_Access then
    #####: 3050:            raise Program_Error with "J cursor denotes wrong container";
        -: 3051:         end if;
        -: 3052:      end if;
        -: 3053:
    #####: 3054:      Swap (Container, I.Index, J.Index);
    #####: 3055:   end Swap;
------------------
        -: 3056:
        -: 3057:   ---------------
        -: 3058:   -- To_Cursor --
        -: 3059:   ---------------
        -: 3060:
    #####: 3061:   function To_Cursor
        -: 3062:     (Container : Vector;
        -: 3063:      Index     : Extended_Index) return Cursor
        -: 3064:   is
        -: 3065:   begin
    #####: 3066:      if Index not in Index_Type'First .. Container.Last then
    #####: 3067:         return No_Element;
        -: 3068:      else
    #####: 3069:         return (Container'Unrestricted_Access, Index);
        -: 3070:      end if;
        -: 3071:   end To_Cursor;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__to_cursor.100:
    #####: 3061:   function To_Cursor
        -: 3062:     (Container : Vector;
        -: 3063:      Index     : Extended_Index) return Cursor
        -: 3064:   is
        -: 3065:   begin
    #####: 3066:      if Index not in Index_Type'First .. Container.Last then
    #####: 3067:         return No_Element;
        -: 3068:      else
    #####: 3069:         return (Container'Unrestricted_Access, Index);
        -: 3070:      end if;
        -: 3071:   end To_Cursor;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__to_cursor.227:
    #####: 3061:   function To_Cursor
        -: 3062:     (Container : Vector;
        -: 3063:      Index     : Extended_Index) return Cursor
        -: 3064:   is
        -: 3065:   begin
    #####: 3066:      if Index not in Index_Type'First .. Container.Last then
    #####: 3067:         return No_Element;
        -: 3068:      else
    #####: 3069:         return (Container'Unrestricted_Access, Index);
        -: 3070:      end if;
        -: 3071:   end To_Cursor;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__to_cursor.459:
    #####: 3061:   function To_Cursor
        -: 3062:     (Container : Vector;
        -: 3063:      Index     : Extended_Index) return Cursor
        -: 3064:   is
        -: 3065:   begin
    #####: 3066:      if Index not in Index_Type'First .. Container.Last then
    #####: 3067:         return No_Element;
        -: 3068:      else
    #####: 3069:         return (Container'Unrestricted_Access, Index);
        -: 3070:      end if;
        -: 3071:   end To_Cursor;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__to_cursor.586:
    #####: 3061:   function To_Cursor
        -: 3062:     (Container : Vector;
        -: 3063:      Index     : Extended_Index) return Cursor
        -: 3064:   is
        -: 3065:   begin
    #####: 3066:      if Index not in Index_Type'First .. Container.Last then
    #####: 3067:         return No_Element;
        -: 3068:      else
    #####: 3069:         return (Container'Unrestricted_Access, Index);
        -: 3070:      end if;
        -: 3071:   end To_Cursor;
------------------
        -: 3072:
        -: 3073:   --------------
        -: 3074:   -- To_Index --
        -: 3075:   --------------
        -: 3076:
        -: 3077:   function To_Index (Position : Cursor) return Extended_Index is
        -: 3078:   begin
        -: 3079:      if Position.Container = null then
        -: 3080:         return No_Index;
        -: 3081:      elsif Position.Index <= Position.Container.Last then
        -: 3082:         return Position.Index;
        -: 3083:      else
        -: 3084:         return No_Index;
        -: 3085:      end if;
        -: 3086:   end To_Index;
        -: 3087:
        -: 3088:   ---------------
        -: 3089:   -- To_Vector --
        -: 3090:   ---------------
        -: 3091:
    #####: 3092:   function To_Vector (Length : Count_Type) return Vector is
    =====: 3093:      Index    : Count_Type'Base;
        -: 3094:      Last     : Index_Type'Base;
    #####: 3095:      Elements : Elements_Access;
        -: 3096:
        -: 3097:   begin
    #####: 3098:      if Length = 0 then
    #####: 3099:         return Empty_Vector;
        -: 3100:      end if;
        -: 3101:
        -: 3102:      --  We create a vector object with a capacity that matches the specified
        -: 3103:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3104:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3105:      --  (otherwise, there would be no way to refer to those components via an
        -: 3106:      --  index).  We must therefore check whether the specified Length would
        -: 3107:      --  create a Last index value greater than Index_Type'Last.
        -: 3108:
        -: 3109:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3110:
        -: 3111:         --  We perform a two-part test. First we determine whether the
        -: 3112:         --  computed Last value lies in the base range of the type, and then
        -: 3113:         --  determine whether it lies in the range of the index (sub)type.
        -: 3114:
        -: 3115:         --  Last must satisfy this relation:
        -: 3116:         --    First + Length - 1 <= Last
        -: 3117:         --  We regroup terms:
        -: 3118:         --    First - 1 <= Last - Length
        -: 3119:         --  Which can rewrite as:
        -: 3120:         --    No_Index <= Last - Length
        -: 3121:
        -: 3122:         if Checks and then
    #####: 3123:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3124:         then
    #####: 3125:            raise Constraint_Error with "Length is out of range";
        -: 3126:         end if;
        -: 3127:
        -: 3128:         --  We now know that the computed value of Last is within the base
        -: 3129:         --  range of the type, so it is safe to compute its value:
        -: 3130:
    #####: 3131:         Last := No_Index + Index_Type'Base (Length);
        -: 3132:
        -: 3133:         --  Finally we test whether the value is within the range of the
        -: 3134:         --  generic actual index subtype:
        -: 3135:
        -: 3136:         if Checks and then Last > Index_Type'Last then
        -: 3137:            raise Constraint_Error with "Length is out of range";
        -: 3138:         end if;
        -: 3139:
        -: 3140:      elsif Index_Type'First <= 0 then
        -: 3141:
        -: 3142:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3143:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3144:         --  adding the (positive) value of Length.
        -: 3145:
        -: 3146:         Index := Count_Type'Base (No_Index) + Length;  -- Last
        -: 3147:
        -: 3148:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3149:            raise Constraint_Error with "Length is out of range";
        -: 3150:         end if;
        -: 3151:
        -: 3152:         --  We know that the computed value (having type Count_Type) of Last
        -: 3153:         --  is within the range of the generic actual index subtype, so it is
        -: 3154:         --  safe to convert to Index_Type:
        -: 3155:
        -: 3156:         Last := Index_Type'Base (Index);
        -: 3157:
        -: 3158:      else
        -: 3159:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3160:         --  must test the length indirectly (by working backwards from the
        -: 3161:         --  largest possible value of Last), in order to prevent overflow.
        -: 3162:
        -: 3163:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3164:
        -: 3165:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3166:            raise Constraint_Error with "Length is out of range";
        -: 3167:         end if;
        -: 3168:
        -: 3169:         --  We have determined that the value of Length would not create a
        -: 3170:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3171:         --  safely compute its value.
        -: 3172:
        -: 3173:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3174:      end if;
        -: 3175:
    #####: 3176:      Elements := new Elements_Type (Last);
        -: 3177:
    #####: 3178:      return Vector'(Controlled with Elements, Last, TC => <>);
    #####: 3179:   end To_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__to_vector.97:
    #####: 3092:   function To_Vector (Length : Count_Type) return Vector is
    =====: 3093:      Index    : Count_Type'Base;
        -: 3094:      Last     : Index_Type'Base;
    #####: 3095:      Elements : Elements_Access;
        -: 3096:
        -: 3097:   begin
    #####: 3098:      if Length = 0 then
    #####: 3099:         return Empty_Vector;
        -: 3100:      end if;
        -: 3101:
        -: 3102:      --  We create a vector object with a capacity that matches the specified
        -: 3103:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3104:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3105:      --  (otherwise, there would be no way to refer to those components via an
        -: 3106:      --  index).  We must therefore check whether the specified Length would
        -: 3107:      --  create a Last index value greater than Index_Type'Last.
        -: 3108:
        -: 3109:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3110:
        -: 3111:         --  We perform a two-part test. First we determine whether the
        -: 3112:         --  computed Last value lies in the base range of the type, and then
        -: 3113:         --  determine whether it lies in the range of the index (sub)type.
        -: 3114:
        -: 3115:         --  Last must satisfy this relation:
        -: 3116:         --    First + Length - 1 <= Last
        -: 3117:         --  We regroup terms:
        -: 3118:         --    First - 1 <= Last - Length
        -: 3119:         --  Which can rewrite as:
        -: 3120:         --    No_Index <= Last - Length
        -: 3121:
        -: 3122:         if Checks and then
    #####: 3123:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3124:         then
    #####: 3125:            raise Constraint_Error with "Length is out of range";
        -: 3126:         end if;
        -: 3127:
        -: 3128:         --  We now know that the computed value of Last is within the base
        -: 3129:         --  range of the type, so it is safe to compute its value:
        -: 3130:
    #####: 3131:         Last := No_Index + Index_Type'Base (Length);
        -: 3132:
        -: 3133:         --  Finally we test whether the value is within the range of the
        -: 3134:         --  generic actual index subtype:
        -: 3135:
        -: 3136:         if Checks and then Last > Index_Type'Last then
        -: 3137:            raise Constraint_Error with "Length is out of range";
        -: 3138:         end if;
        -: 3139:
        -: 3140:      elsif Index_Type'First <= 0 then
        -: 3141:
        -: 3142:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3143:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3144:         --  adding the (positive) value of Length.
        -: 3145:
        -: 3146:         Index := Count_Type'Base (No_Index) + Length;  -- Last
        -: 3147:
        -: 3148:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3149:            raise Constraint_Error with "Length is out of range";
        -: 3150:         end if;
        -: 3151:
        -: 3152:         --  We know that the computed value (having type Count_Type) of Last
        -: 3153:         --  is within the range of the generic actual index subtype, so it is
        -: 3154:         --  safe to convert to Index_Type:
        -: 3155:
        -: 3156:         Last := Index_Type'Base (Index);
        -: 3157:
        -: 3158:      else
        -: 3159:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3160:         --  must test the length indirectly (by working backwards from the
        -: 3161:         --  largest possible value of Last), in order to prevent overflow.
        -: 3162:
        -: 3163:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3164:
        -: 3165:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3166:            raise Constraint_Error with "Length is out of range";
        -: 3167:         end if;
        -: 3168:
        -: 3169:         --  We have determined that the value of Length would not create a
        -: 3170:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3171:         --  safely compute its value.
        -: 3172:
        -: 3173:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3174:      end if;
        -: 3175:
    #####: 3176:      Elements := new Elements_Type (Last);
        -: 3177:
    #####: 3178:      return Vector'(Controlled with Elements, Last, TC => <>);
    #####: 3179:   end To_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__to_vector.222:
    #####: 3092:   function To_Vector (Length : Count_Type) return Vector is
    =====: 3093:      Index    : Count_Type'Base;
        -: 3094:      Last     : Index_Type'Base;
    #####: 3095:      Elements : Elements_Access;
        -: 3096:
        -: 3097:   begin
    #####: 3098:      if Length = 0 then
    #####: 3099:         return Empty_Vector;
        -: 3100:      end if;
        -: 3101:
        -: 3102:      --  We create a vector object with a capacity that matches the specified
        -: 3103:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3104:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3105:      --  (otherwise, there would be no way to refer to those components via an
        -: 3106:      --  index).  We must therefore check whether the specified Length would
        -: 3107:      --  create a Last index value greater than Index_Type'Last.
        -: 3108:
        -: 3109:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3110:
        -: 3111:         --  We perform a two-part test. First we determine whether the
        -: 3112:         --  computed Last value lies in the base range of the type, and then
        -: 3113:         --  determine whether it lies in the range of the index (sub)type.
        -: 3114:
        -: 3115:         --  Last must satisfy this relation:
        -: 3116:         --    First + Length - 1 <= Last
        -: 3117:         --  We regroup terms:
        -: 3118:         --    First - 1 <= Last - Length
        -: 3119:         --  Which can rewrite as:
        -: 3120:         --    No_Index <= Last - Length
        -: 3121:
        -: 3122:         if Checks and then
    #####: 3123:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3124:         then
    #####: 3125:            raise Constraint_Error with "Length is out of range";
        -: 3126:         end if;
        -: 3127:
        -: 3128:         --  We now know that the computed value of Last is within the base
        -: 3129:         --  range of the type, so it is safe to compute its value:
        -: 3130:
    #####: 3131:         Last := No_Index + Index_Type'Base (Length);
        -: 3132:
        -: 3133:         --  Finally we test whether the value is within the range of the
        -: 3134:         --  generic actual index subtype:
        -: 3135:
        -: 3136:         if Checks and then Last > Index_Type'Last then
        -: 3137:            raise Constraint_Error with "Length is out of range";
        -: 3138:         end if;
        -: 3139:
        -: 3140:      elsif Index_Type'First <= 0 then
        -: 3141:
        -: 3142:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3143:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3144:         --  adding the (positive) value of Length.
        -: 3145:
        -: 3146:         Index := Count_Type'Base (No_Index) + Length;  -- Last
        -: 3147:
        -: 3148:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3149:            raise Constraint_Error with "Length is out of range";
        -: 3150:         end if;
        -: 3151:
        -: 3152:         --  We know that the computed value (having type Count_Type) of Last
        -: 3153:         --  is within the range of the generic actual index subtype, so it is
        -: 3154:         --  safe to convert to Index_Type:
        -: 3155:
        -: 3156:         Last := Index_Type'Base (Index);
        -: 3157:
        -: 3158:      else
        -: 3159:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3160:         --  must test the length indirectly (by working backwards from the
        -: 3161:         --  largest possible value of Last), in order to prevent overflow.
        -: 3162:
        -: 3163:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3164:
        -: 3165:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3166:            raise Constraint_Error with "Length is out of range";
        -: 3167:         end if;
        -: 3168:
        -: 3169:         --  We have determined that the value of Length would not create a
        -: 3170:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3171:         --  safely compute its value.
        -: 3172:
        -: 3173:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3174:      end if;
        -: 3175:
    #####: 3176:      Elements := new Elements_Type (Last);
        -: 3177:
    #####: 3178:      return Vector'(Controlled with Elements, Last, TC => <>);
    #####: 3179:   end To_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__to_vector.456:
    #####: 3092:   function To_Vector (Length : Count_Type) return Vector is
    =====: 3093:      Index    : Count_Type'Base;
        -: 3094:      Last     : Index_Type'Base;
    #####: 3095:      Elements : Elements_Access;
        -: 3096:
        -: 3097:   begin
    #####: 3098:      if Length = 0 then
    #####: 3099:         return Empty_Vector;
        -: 3100:      end if;
        -: 3101:
        -: 3102:      --  We create a vector object with a capacity that matches the specified
        -: 3103:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3104:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3105:      --  (otherwise, there would be no way to refer to those components via an
        -: 3106:      --  index).  We must therefore check whether the specified Length would
        -: 3107:      --  create a Last index value greater than Index_Type'Last.
        -: 3108:
        -: 3109:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3110:
        -: 3111:         --  We perform a two-part test. First we determine whether the
        -: 3112:         --  computed Last value lies in the base range of the type, and then
        -: 3113:         --  determine whether it lies in the range of the index (sub)type.
        -: 3114:
        -: 3115:         --  Last must satisfy this relation:
        -: 3116:         --    First + Length - 1 <= Last
        -: 3117:         --  We regroup terms:
        -: 3118:         --    First - 1 <= Last - Length
        -: 3119:         --  Which can rewrite as:
        -: 3120:         --    No_Index <= Last - Length
        -: 3121:
        -: 3122:         if Checks and then
    #####: 3123:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3124:         then
    #####: 3125:            raise Constraint_Error with "Length is out of range";
        -: 3126:         end if;
        -: 3127:
        -: 3128:         --  We now know that the computed value of Last is within the base
        -: 3129:         --  range of the type, so it is safe to compute its value:
        -: 3130:
    #####: 3131:         Last := No_Index + Index_Type'Base (Length);
        -: 3132:
        -: 3133:         --  Finally we test whether the value is within the range of the
        -: 3134:         --  generic actual index subtype:
        -: 3135:
        -: 3136:         if Checks and then Last > Index_Type'Last then
        -: 3137:            raise Constraint_Error with "Length is out of range";
        -: 3138:         end if;
        -: 3139:
        -: 3140:      elsif Index_Type'First <= 0 then
        -: 3141:
        -: 3142:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3143:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3144:         --  adding the (positive) value of Length.
        -: 3145:
        -: 3146:         Index := Count_Type'Base (No_Index) + Length;  -- Last
        -: 3147:
        -: 3148:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3149:            raise Constraint_Error with "Length is out of range";
        -: 3150:         end if;
        -: 3151:
        -: 3152:         --  We know that the computed value (having type Count_Type) of Last
        -: 3153:         --  is within the range of the generic actual index subtype, so it is
        -: 3154:         --  safe to convert to Index_Type:
        -: 3155:
        -: 3156:         Last := Index_Type'Base (Index);
        -: 3157:
        -: 3158:      else
        -: 3159:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3160:         --  must test the length indirectly (by working backwards from the
        -: 3161:         --  largest possible value of Last), in order to prevent overflow.
        -: 3162:
        -: 3163:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3164:
        -: 3165:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3166:            raise Constraint_Error with "Length is out of range";
        -: 3167:         end if;
        -: 3168:
        -: 3169:         --  We have determined that the value of Length would not create a
        -: 3170:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3171:         --  safely compute its value.
        -: 3172:
        -: 3173:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3174:      end if;
        -: 3175:
    #####: 3176:      Elements := new Elements_Type (Last);
        -: 3177:
    #####: 3178:      return Vector'(Controlled with Elements, Last, TC => <>);
    #####: 3179:   end To_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__to_vector.581:
    #####: 3092:   function To_Vector (Length : Count_Type) return Vector is
    =====: 3093:      Index    : Count_Type'Base;
        -: 3094:      Last     : Index_Type'Base;
    #####: 3095:      Elements : Elements_Access;
        -: 3096:
        -: 3097:   begin
    #####: 3098:      if Length = 0 then
    #####: 3099:         return Empty_Vector;
        -: 3100:      end if;
        -: 3101:
        -: 3102:      --  We create a vector object with a capacity that matches the specified
        -: 3103:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3104:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3105:      --  (otherwise, there would be no way to refer to those components via an
        -: 3106:      --  index).  We must therefore check whether the specified Length would
        -: 3107:      --  create a Last index value greater than Index_Type'Last.
        -: 3108:
        -: 3109:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3110:
        -: 3111:         --  We perform a two-part test. First we determine whether the
        -: 3112:         --  computed Last value lies in the base range of the type, and then
        -: 3113:         --  determine whether it lies in the range of the index (sub)type.
        -: 3114:
        -: 3115:         --  Last must satisfy this relation:
        -: 3116:         --    First + Length - 1 <= Last
        -: 3117:         --  We regroup terms:
        -: 3118:         --    First - 1 <= Last - Length
        -: 3119:         --  Which can rewrite as:
        -: 3120:         --    No_Index <= Last - Length
        -: 3121:
        -: 3122:         if Checks and then
    #####: 3123:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3124:         then
    #####: 3125:            raise Constraint_Error with "Length is out of range";
        -: 3126:         end if;
        -: 3127:
        -: 3128:         --  We now know that the computed value of Last is within the base
        -: 3129:         --  range of the type, so it is safe to compute its value:
        -: 3130:
    #####: 3131:         Last := No_Index + Index_Type'Base (Length);
        -: 3132:
        -: 3133:         --  Finally we test whether the value is within the range of the
        -: 3134:         --  generic actual index subtype:
        -: 3135:
        -: 3136:         if Checks and then Last > Index_Type'Last then
        -: 3137:            raise Constraint_Error with "Length is out of range";
        -: 3138:         end if;
        -: 3139:
        -: 3140:      elsif Index_Type'First <= 0 then
        -: 3141:
        -: 3142:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3143:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3144:         --  adding the (positive) value of Length.
        -: 3145:
        -: 3146:         Index := Count_Type'Base (No_Index) + Length;  -- Last
        -: 3147:
        -: 3148:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3149:            raise Constraint_Error with "Length is out of range";
        -: 3150:         end if;
        -: 3151:
        -: 3152:         --  We know that the computed value (having type Count_Type) of Last
        -: 3153:         --  is within the range of the generic actual index subtype, so it is
        -: 3154:         --  safe to convert to Index_Type:
        -: 3155:
        -: 3156:         Last := Index_Type'Base (Index);
        -: 3157:
        -: 3158:      else
        -: 3159:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3160:         --  must test the length indirectly (by working backwards from the
        -: 3161:         --  largest possible value of Last), in order to prevent overflow.
        -: 3162:
        -: 3163:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3164:
        -: 3165:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3166:            raise Constraint_Error with "Length is out of range";
        -: 3167:         end if;
        -: 3168:
        -: 3169:         --  We have determined that the value of Length would not create a
        -: 3170:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3171:         --  safely compute its value.
        -: 3172:
        -: 3173:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3174:      end if;
        -: 3175:
    #####: 3176:      Elements := new Elements_Type (Last);
        -: 3177:
    #####: 3178:      return Vector'(Controlled with Elements, Last, TC => <>);
    #####: 3179:   end To_Vector;
------------------
        -: 3180:
    #####: 3181:   function To_Vector
        -: 3182:     (New_Item : Element_Type;
        -: 3183:      Length   : Count_Type) return Vector
        -: 3184:   is
    #####: 3185:      Index    : Count_Type'Base;
        -: 3186:      Last     : Index_Type'Base;
    #####: 3187:      Elements : Elements_Access;
        -: 3188:
        -: 3189:   begin
    #####: 3190:      if Length = 0 then
    #####: 3191:         return Empty_Vector;
        -: 3192:      end if;
        -: 3193:
        -: 3194:      --  We create a vector object with a capacity that matches the specified
        -: 3195:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3196:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3197:      --  (otherwise, there would be no way to refer to those components via an
        -: 3198:      --  index). We must therefore check whether the specified Length would
        -: 3199:      --  create a Last index value greater than Index_Type'Last.
        -: 3200:
        -: 3201:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3202:
        -: 3203:         --  We perform a two-part test. First we determine whether the
        -: 3204:         --  computed Last value lies in the base range of the type, and then
        -: 3205:         --  determine whether it lies in the range of the index (sub)type.
        -: 3206:
        -: 3207:         --  Last must satisfy this relation:
        -: 3208:         --    First + Length - 1 <= Last
        -: 3209:         --  We regroup terms:
        -: 3210:         --    First - 1 <= Last - Length
        -: 3211:         --  Which can rewrite as:
        -: 3212:         --    No_Index <= Last - Length
        -: 3213:
        -: 3214:         if Checks and then
    #####: 3215:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3216:         then
    #####: 3217:            raise Constraint_Error with "Length is out of range";
        -: 3218:         end if;
        -: 3219:
        -: 3220:         --  We now know that the computed value of Last is within the base
        -: 3221:         --  range of the type, so it is safe to compute its value:
        -: 3222:
    #####: 3223:         Last := No_Index + Index_Type'Base (Length);
        -: 3224:
        -: 3225:         --  Finally we test whether the value is within the range of the
        -: 3226:         --  generic actual index subtype:
        -: 3227:
        -: 3228:         if Checks and then Last > Index_Type'Last then
        -: 3229:            raise Constraint_Error with "Length is out of range";
        -: 3230:         end if;
        -: 3231:
        -: 3232:      elsif Index_Type'First <= 0 then
        -: 3233:
        -: 3234:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3235:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3236:         --  adding the (positive) value of Length.
        -: 3237:
        -: 3238:         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last
        -: 3239:
        -: 3240:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3241:            raise Constraint_Error with "Length is out of range";
        -: 3242:         end if;
        -: 3243:
        -: 3244:         --  We know that the computed value (having type Count_Type) of Last
        -: 3245:         --  is within the range of the generic actual index subtype, so it is
        -: 3246:         --  safe to convert to Index_Type:
        -: 3247:
        -: 3248:         Last := Index_Type'Base (Index);
        -: 3249:
        -: 3250:      else
        -: 3251:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3252:         --  must test the length indirectly (by working backwards from the
        -: 3253:         --  largest possible value of Last), in order to prevent overflow.
        -: 3254:
        -: 3255:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3256:
        -: 3257:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3258:            raise Constraint_Error with "Length is out of range";
        -: 3259:         end if;
        -: 3260:
        -: 3261:         --  We have determined that the value of Length would not create a
        -: 3262:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3263:         --  safely compute its value.
        -: 3264:
        -: 3265:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3266:      end if;
        -: 3267:
    #####: 3268:      Elements := new Elements_Type'(Last, EA => (others => New_Item));
        -: 3269:
    #####: 3270:      return (Controlled with Elements, Last, TC => <>);
    #####: 3271:   end To_Vector;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__to_vector__2.95:
    #####: 3181:   function To_Vector
        -: 3182:     (New_Item : Element_Type;
        -: 3183:      Length   : Count_Type) return Vector
        -: 3184:   is
    #####: 3185:      Index    : Count_Type'Base;
        -: 3186:      Last     : Index_Type'Base;
    #####: 3187:      Elements : Elements_Access;
        -: 3188:
        -: 3189:   begin
    #####: 3190:      if Length = 0 then
    #####: 3191:         return Empty_Vector;
        -: 3192:      end if;
        -: 3193:
        -: 3194:      --  We create a vector object with a capacity that matches the specified
        -: 3195:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3196:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3197:      --  (otherwise, there would be no way to refer to those components via an
        -: 3198:      --  index). We must therefore check whether the specified Length would
        -: 3199:      --  create a Last index value greater than Index_Type'Last.
        -: 3200:
        -: 3201:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3202:
        -: 3203:         --  We perform a two-part test. First we determine whether the
        -: 3204:         --  computed Last value lies in the base range of the type, and then
        -: 3205:         --  determine whether it lies in the range of the index (sub)type.
        -: 3206:
        -: 3207:         --  Last must satisfy this relation:
        -: 3208:         --    First + Length - 1 <= Last
        -: 3209:         --  We regroup terms:
        -: 3210:         --    First - 1 <= Last - Length
        -: 3211:         --  Which can rewrite as:
        -: 3212:         --    No_Index <= Last - Length
        -: 3213:
        -: 3214:         if Checks and then
    #####: 3215:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3216:         then
    #####: 3217:            raise Constraint_Error with "Length is out of range";
        -: 3218:         end if;
        -: 3219:
        -: 3220:         --  We now know that the computed value of Last is within the base
        -: 3221:         --  range of the type, so it is safe to compute its value:
        -: 3222:
    #####: 3223:         Last := No_Index + Index_Type'Base (Length);
        -: 3224:
        -: 3225:         --  Finally we test whether the value is within the range of the
        -: 3226:         --  generic actual index subtype:
        -: 3227:
        -: 3228:         if Checks and then Last > Index_Type'Last then
        -: 3229:            raise Constraint_Error with "Length is out of range";
        -: 3230:         end if;
        -: 3231:
        -: 3232:      elsif Index_Type'First <= 0 then
        -: 3233:
        -: 3234:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3235:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3236:         --  adding the (positive) value of Length.
        -: 3237:
        -: 3238:         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last
        -: 3239:
        -: 3240:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3241:            raise Constraint_Error with "Length is out of range";
        -: 3242:         end if;
        -: 3243:
        -: 3244:         --  We know that the computed value (having type Count_Type) of Last
        -: 3245:         --  is within the range of the generic actual index subtype, so it is
        -: 3246:         --  safe to convert to Index_Type:
        -: 3247:
        -: 3248:         Last := Index_Type'Base (Index);
        -: 3249:
        -: 3250:      else
        -: 3251:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3252:         --  must test the length indirectly (by working backwards from the
        -: 3253:         --  largest possible value of Last), in order to prevent overflow.
        -: 3254:
        -: 3255:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3256:
        -: 3257:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3258:            raise Constraint_Error with "Length is out of range";
        -: 3259:         end if;
        -: 3260:
        -: 3261:         --  We have determined that the value of Length would not create a
        -: 3262:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3263:         --  safely compute its value.
        -: 3264:
        -: 3265:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3266:      end if;
        -: 3267:
    #####: 3268:      Elements := new Elements_Type'(Last, EA => (others => New_Item));
        -: 3269:
    #####: 3270:      return (Controlled with Elements, Last, TC => <>);
    #####: 3271:   end To_Vector;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__to_vector__2.220:
    #####: 3181:   function To_Vector
        -: 3182:     (New_Item : Element_Type;
        -: 3183:      Length   : Count_Type) return Vector
        -: 3184:   is
    #####: 3185:      Index    : Count_Type'Base;
        -: 3186:      Last     : Index_Type'Base;
    #####: 3187:      Elements : Elements_Access;
        -: 3188:
        -: 3189:   begin
    #####: 3190:      if Length = 0 then
    #####: 3191:         return Empty_Vector;
        -: 3192:      end if;
        -: 3193:
        -: 3194:      --  We create a vector object with a capacity that matches the specified
        -: 3195:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3196:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3197:      --  (otherwise, there would be no way to refer to those components via an
        -: 3198:      --  index). We must therefore check whether the specified Length would
        -: 3199:      --  create a Last index value greater than Index_Type'Last.
        -: 3200:
        -: 3201:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3202:
        -: 3203:         --  We perform a two-part test. First we determine whether the
        -: 3204:         --  computed Last value lies in the base range of the type, and then
        -: 3205:         --  determine whether it lies in the range of the index (sub)type.
        -: 3206:
        -: 3207:         --  Last must satisfy this relation:
        -: 3208:         --    First + Length - 1 <= Last
        -: 3209:         --  We regroup terms:
        -: 3210:         --    First - 1 <= Last - Length
        -: 3211:         --  Which can rewrite as:
        -: 3212:         --    No_Index <= Last - Length
        -: 3213:
        -: 3214:         if Checks and then
    #####: 3215:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3216:         then
    #####: 3217:            raise Constraint_Error with "Length is out of range";
        -: 3218:         end if;
        -: 3219:
        -: 3220:         --  We now know that the computed value of Last is within the base
        -: 3221:         --  range of the type, so it is safe to compute its value:
        -: 3222:
    #####: 3223:         Last := No_Index + Index_Type'Base (Length);
        -: 3224:
        -: 3225:         --  Finally we test whether the value is within the range of the
        -: 3226:         --  generic actual index subtype:
        -: 3227:
        -: 3228:         if Checks and then Last > Index_Type'Last then
        -: 3229:            raise Constraint_Error with "Length is out of range";
        -: 3230:         end if;
        -: 3231:
        -: 3232:      elsif Index_Type'First <= 0 then
        -: 3233:
        -: 3234:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3235:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3236:         --  adding the (positive) value of Length.
        -: 3237:
        -: 3238:         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last
        -: 3239:
        -: 3240:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3241:            raise Constraint_Error with "Length is out of range";
        -: 3242:         end if;
        -: 3243:
        -: 3244:         --  We know that the computed value (having type Count_Type) of Last
        -: 3245:         --  is within the range of the generic actual index subtype, so it is
        -: 3246:         --  safe to convert to Index_Type:
        -: 3247:
        -: 3248:         Last := Index_Type'Base (Index);
        -: 3249:
        -: 3250:      else
        -: 3251:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3252:         --  must test the length indirectly (by working backwards from the
        -: 3253:         --  largest possible value of Last), in order to prevent overflow.
        -: 3254:
        -: 3255:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3256:
        -: 3257:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3258:            raise Constraint_Error with "Length is out of range";
        -: 3259:         end if;
        -: 3260:
        -: 3261:         --  We have determined that the value of Length would not create a
        -: 3262:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3263:         --  safely compute its value.
        -: 3264:
        -: 3265:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3266:      end if;
        -: 3267:
    #####: 3268:      Elements := new Elements_Type'(Last, EA => (others => New_Item));
        -: 3269:
    #####: 3270:      return (Controlled with Elements, Last, TC => <>);
    #####: 3271:   end To_Vector;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__to_vector__2.454:
    #####: 3181:   function To_Vector
        -: 3182:     (New_Item : Element_Type;
        -: 3183:      Length   : Count_Type) return Vector
        -: 3184:   is
    #####: 3185:      Index    : Count_Type'Base;
        -: 3186:      Last     : Index_Type'Base;
    #####: 3187:      Elements : Elements_Access;
        -: 3188:
        -: 3189:   begin
    #####: 3190:      if Length = 0 then
    #####: 3191:         return Empty_Vector;
        -: 3192:      end if;
        -: 3193:
        -: 3194:      --  We create a vector object with a capacity that matches the specified
        -: 3195:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3196:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3197:      --  (otherwise, there would be no way to refer to those components via an
        -: 3198:      --  index). We must therefore check whether the specified Length would
        -: 3199:      --  create a Last index value greater than Index_Type'Last.
        -: 3200:
        -: 3201:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3202:
        -: 3203:         --  We perform a two-part test. First we determine whether the
        -: 3204:         --  computed Last value lies in the base range of the type, and then
        -: 3205:         --  determine whether it lies in the range of the index (sub)type.
        -: 3206:
        -: 3207:         --  Last must satisfy this relation:
        -: 3208:         --    First + Length - 1 <= Last
        -: 3209:         --  We regroup terms:
        -: 3210:         --    First - 1 <= Last - Length
        -: 3211:         --  Which can rewrite as:
        -: 3212:         --    No_Index <= Last - Length
        -: 3213:
        -: 3214:         if Checks and then
    #####: 3215:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3216:         then
    #####: 3217:            raise Constraint_Error with "Length is out of range";
        -: 3218:         end if;
        -: 3219:
        -: 3220:         --  We now know that the computed value of Last is within the base
        -: 3221:         --  range of the type, so it is safe to compute its value:
        -: 3222:
    #####: 3223:         Last := No_Index + Index_Type'Base (Length);
        -: 3224:
        -: 3225:         --  Finally we test whether the value is within the range of the
        -: 3226:         --  generic actual index subtype:
        -: 3227:
        -: 3228:         if Checks and then Last > Index_Type'Last then
        -: 3229:            raise Constraint_Error with "Length is out of range";
        -: 3230:         end if;
        -: 3231:
        -: 3232:      elsif Index_Type'First <= 0 then
        -: 3233:
        -: 3234:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3235:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3236:         --  adding the (positive) value of Length.
        -: 3237:
        -: 3238:         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last
        -: 3239:
        -: 3240:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3241:            raise Constraint_Error with "Length is out of range";
        -: 3242:         end if;
        -: 3243:
        -: 3244:         --  We know that the computed value (having type Count_Type) of Last
        -: 3245:         --  is within the range of the generic actual index subtype, so it is
        -: 3246:         --  safe to convert to Index_Type:
        -: 3247:
        -: 3248:         Last := Index_Type'Base (Index);
        -: 3249:
        -: 3250:      else
        -: 3251:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3252:         --  must test the length indirectly (by working backwards from the
        -: 3253:         --  largest possible value of Last), in order to prevent overflow.
        -: 3254:
        -: 3255:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3256:
        -: 3257:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3258:            raise Constraint_Error with "Length is out of range";
        -: 3259:         end if;
        -: 3260:
        -: 3261:         --  We have determined that the value of Length would not create a
        -: 3262:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3263:         --  safely compute its value.
        -: 3264:
        -: 3265:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3266:      end if;
        -: 3267:
    #####: 3268:      Elements := new Elements_Type'(Last, EA => (others => New_Item));
        -: 3269:
    #####: 3270:      return (Controlled with Elements, Last, TC => <>);
    #####: 3271:   end To_Vector;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__to_vector__2.579:
    #####: 3181:   function To_Vector
        -: 3182:     (New_Item : Element_Type;
        -: 3183:      Length   : Count_Type) return Vector
        -: 3184:   is
    #####: 3185:      Index    : Count_Type'Base;
        -: 3186:      Last     : Index_Type'Base;
    #####: 3187:      Elements : Elements_Access;
        -: 3188:
        -: 3189:   begin
    #####: 3190:      if Length = 0 then
    #####: 3191:         return Empty_Vector;
        -: 3192:      end if;
        -: 3193:
        -: 3194:      --  We create a vector object with a capacity that matches the specified
        -: 3195:      --  Length, but we do not allow the vector capacity (the length of the
        -: 3196:      --  internal array) to exceed the number of values in Index_Type'Range
        -: 3197:      --  (otherwise, there would be no way to refer to those components via an
        -: 3198:      --  index). We must therefore check whether the specified Length would
        -: 3199:      --  create a Last index value greater than Index_Type'Last.
        -: 3200:
        -: 3201:      if Index_Type'Base'Last >= Count_Type_Last then
        -: 3202:
        -: 3203:         --  We perform a two-part test. First we determine whether the
        -: 3204:         --  computed Last value lies in the base range of the type, and then
        -: 3205:         --  determine whether it lies in the range of the index (sub)type.
        -: 3206:
        -: 3207:         --  Last must satisfy this relation:
        -: 3208:         --    First + Length - 1 <= Last
        -: 3209:         --  We regroup terms:
        -: 3210:         --    First - 1 <= Last - Length
        -: 3211:         --  Which can rewrite as:
        -: 3212:         --    No_Index <= Last - Length
        -: 3213:
        -: 3214:         if Checks and then
    #####: 3215:           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index
        -: 3216:         then
    #####: 3217:            raise Constraint_Error with "Length is out of range";
        -: 3218:         end if;
        -: 3219:
        -: 3220:         --  We now know that the computed value of Last is within the base
        -: 3221:         --  range of the type, so it is safe to compute its value:
        -: 3222:
    #####: 3223:         Last := No_Index + Index_Type'Base (Length);
        -: 3224:
        -: 3225:         --  Finally we test whether the value is within the range of the
        -: 3226:         --  generic actual index subtype:
        -: 3227:
        -: 3228:         if Checks and then Last > Index_Type'Last then
        -: 3229:            raise Constraint_Error with "Length is out of range";
        -: 3230:         end if;
        -: 3231:
        -: 3232:      elsif Index_Type'First <= 0 then
        -: 3233:
        -: 3234:         --  Here we can compute Last directly, in the normal way. We know that
        -: 3235:         --  No_Index is less than 0, so there is no danger of overflow when
        -: 3236:         --  adding the (positive) value of Length.
        -: 3237:
        -: 3238:         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last
        -: 3239:
        -: 3240:         if Checks and then Index > Count_Type'Base (Index_Type'Last) then
        -: 3241:            raise Constraint_Error with "Length is out of range";
        -: 3242:         end if;
        -: 3243:
        -: 3244:         --  We know that the computed value (having type Count_Type) of Last
        -: 3245:         --  is within the range of the generic actual index subtype, so it is
        -: 3246:         --  safe to convert to Index_Type:
        -: 3247:
        -: 3248:         Last := Index_Type'Base (Index);
        -: 3249:
        -: 3250:      else
        -: 3251:         --  Here Index_Type'First (and Index_Type'Last) is positive, so we
        -: 3252:         --  must test the length indirectly (by working backwards from the
        -: 3253:         --  largest possible value of Last), in order to prevent overflow.
        -: 3254:
        -: 3255:         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index
        -: 3256:
        -: 3257:         if Checks and then Index < Count_Type'Base (No_Index) then
        -: 3258:            raise Constraint_Error with "Length is out of range";
        -: 3259:         end if;
        -: 3260:
        -: 3261:         --  We have determined that the value of Length would not create a
        -: 3262:         --  Last index value outside of the range of Index_Type, so we can now
        -: 3263:         --  safely compute its value.
        -: 3264:
        -: 3265:         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);
        -: 3266:      end if;
        -: 3267:
    #####: 3268:      Elements := new Elements_Type'(Last, EA => (others => New_Item));
        -: 3269:
    #####: 3270:      return (Controlled with Elements, Last, TC => <>);
    #####: 3271:   end To_Vector;
------------------
        -: 3272:
        -: 3273:   --------------------
        -: 3274:   -- Update_Element --
        -: 3275:   --------------------
        -: 3276:
    #####: 3277:   procedure Update_Element
        -: 3278:     (Container : in out Vector;
        -: 3279:      Index     : Index_Type;
        -: 3280:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3281:   is
    #####: 3282:      Lock : With_Lock (Container.TC'Unchecked_Access);
        -: 3283:   begin
    #####: 3284:      if Checks and then Index > Container.Last then
    #####: 3285:         raise Constraint_Error with "Index is out of range";
        -: 3286:      end if;
        -: 3287:
    #####: 3288:      Process (Container.Elements.EA (Index));
    #####: 3289:   end Update_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__update_element.92:
    #####: 3277:   procedure Update_Element
        -: 3278:     (Container : in out Vector;
        -: 3279:      Index     : Index_Type;
        -: 3280:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3281:   is
    #####: 3282:      Lock : With_Lock (Container.TC'Unchecked_Access);
        -: 3283:   begin
    #####: 3284:      if Checks and then Index > Container.Last then
    #####: 3285:         raise Constraint_Error with "Index is out of range";
        -: 3286:      end if;
        -: 3287:
    #####: 3288:      Process (Container.Elements.EA (Index));
    #####: 3289:   end Update_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__update_element.217:
    #####: 3277:   procedure Update_Element
        -: 3278:     (Container : in out Vector;
        -: 3279:      Index     : Index_Type;
        -: 3280:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3281:   is
    #####: 3282:      Lock : With_Lock (Container.TC'Unchecked_Access);
        -: 3283:   begin
    #####: 3284:      if Checks and then Index > Container.Last then
    #####: 3285:         raise Constraint_Error with "Index is out of range";
        -: 3286:      end if;
        -: 3287:
    #####: 3288:      Process (Container.Elements.EA (Index));
    #####: 3289:   end Update_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__update_element.451:
    #####: 3277:   procedure Update_Element
        -: 3278:     (Container : in out Vector;
        -: 3279:      Index     : Index_Type;
        -: 3280:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3281:   is
    #####: 3282:      Lock : With_Lock (Container.TC'Unchecked_Access);
        -: 3283:   begin
    #####: 3284:      if Checks and then Index > Container.Last then
    #####: 3285:         raise Constraint_Error with "Index is out of range";
        -: 3286:      end if;
        -: 3287:
    #####: 3288:      Process (Container.Elements.EA (Index));
    #####: 3289:   end Update_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__update_element.576:
    #####: 3277:   procedure Update_Element
        -: 3278:     (Container : in out Vector;
        -: 3279:      Index     : Index_Type;
        -: 3280:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3281:   is
    #####: 3282:      Lock : With_Lock (Container.TC'Unchecked_Access);
        -: 3283:   begin
    #####: 3284:      if Checks and then Index > Container.Last then
    #####: 3285:         raise Constraint_Error with "Index is out of range";
        -: 3286:      end if;
        -: 3287:
    #####: 3288:      Process (Container.Elements.EA (Index));
    #####: 3289:   end Update_Element;
------------------
        -: 3290:
    #####: 3291:   procedure Update_Element
        -: 3292:     (Container : in out Vector;
        -: 3293:      Position  : Cursor;
        -: 3294:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3295:   is
        -: 3296:   begin
        -: 3297:      if Checks then
    #####: 3298:         if Position.Container = null then
    #####: 3299:            raise Constraint_Error with "Position cursor has no element";
    #####: 3300:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 3301:            raise Program_Error with "Position cursor denotes wrong container";
        -: 3302:         end if;
        -: 3303:      end if;
        -: 3304:
    #####: 3305:      Update_Element (Container, Position.Index, Process);
    #####: 3306:   end Update_Element;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__update_element__2.91:
    #####: 3291:   procedure Update_Element
        -: 3292:     (Container : in out Vector;
        -: 3293:      Position  : Cursor;
        -: 3294:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3295:   is
        -: 3296:   begin
        -: 3297:      if Checks then
    #####: 3298:         if Position.Container = null then
    #####: 3299:            raise Constraint_Error with "Position cursor has no element";
    #####: 3300:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 3301:            raise Program_Error with "Position cursor denotes wrong container";
        -: 3302:         end if;
        -: 3303:      end if;
        -: 3304:
    #####: 3305:      Update_Element (Container, Position.Index, Process);
    #####: 3306:   end Update_Element;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__update_element__2.216:
    #####: 3291:   procedure Update_Element
        -: 3292:     (Container : in out Vector;
        -: 3293:      Position  : Cursor;
        -: 3294:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3295:   is
        -: 3296:   begin
        -: 3297:      if Checks then
    #####: 3298:         if Position.Container = null then
    #####: 3299:            raise Constraint_Error with "Position cursor has no element";
    #####: 3300:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 3301:            raise Program_Error with "Position cursor denotes wrong container";
        -: 3302:         end if;
        -: 3303:      end if;
        -: 3304:
    #####: 3305:      Update_Element (Container, Position.Index, Process);
    #####: 3306:   end Update_Element;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__update_element__2.450:
    #####: 3291:   procedure Update_Element
        -: 3292:     (Container : in out Vector;
        -: 3293:      Position  : Cursor;
        -: 3294:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3295:   is
        -: 3296:   begin
        -: 3297:      if Checks then
    #####: 3298:         if Position.Container = null then
    #####: 3299:            raise Constraint_Error with "Position cursor has no element";
    #####: 3300:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 3301:            raise Program_Error with "Position cursor denotes wrong container";
        -: 3302:         end if;
        -: 3303:      end if;
        -: 3304:
    #####: 3305:      Update_Element (Container, Position.Index, Process);
    #####: 3306:   end Update_Element;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__update_element__2.575:
    #####: 3291:   procedure Update_Element
        -: 3292:     (Container : in out Vector;
        -: 3293:      Position  : Cursor;
        -: 3294:      Process   : not null access procedure (Element : in out Element_Type))
        -: 3295:   is
        -: 3296:   begin
        -: 3297:      if Checks then
    #####: 3298:         if Position.Container = null then
    #####: 3299:            raise Constraint_Error with "Position cursor has no element";
    #####: 3300:         elsif Position.Container /= Container'Unrestricted_Access then
    #####: 3301:            raise Program_Error with "Position cursor denotes wrong container";
        -: 3302:         end if;
        -: 3303:      end if;
        -: 3304:
    #####: 3305:      Update_Element (Container, Position.Index, Process);
    #####: 3306:   end Update_Element;
------------------
        -: 3307:
        -: 3308:   -----------
        -: 3309:   -- Write --
        -: 3310:   -----------
        -: 3311:
    #####: 3312:   procedure Write
        -: 3313:     (Stream    : not null access Root_Stream_Type'Class;
        -: 3314:      Container : Vector)
        -: 3315:   is
        -: 3316:   begin
    #####: 3317:      Count_Type'Base'Write (Stream, Length (Container));
        -: 3318:
    #####: 3319:      for J in Index_Type'First .. Container.Last loop
    #####: 3320:         Element_Type'Write (Stream, Container.Elements.EA (J));
    #####: 3321:      end loop;
    #####: 3322:   end Write;
------------------
graphalg_test_tg__B_8__test_graph__vertex_vectors__write.90:
    #####: 3312:   procedure Write
        -: 3313:     (Stream    : not null access Root_Stream_Type'Class;
        -: 3314:      Container : Vector)
        -: 3315:   is
        -: 3316:   begin
    #####: 3317:      Count_Type'Base'Write (Stream, Length (Container));
        -: 3318:
    #####: 3319:      for J in Index_Type'First .. Container.Last loop
    #####: 3320:         Element_Type'Write (Stream, Container.Elements.EA (J));
    #####: 3321:      end loop;
    #####: 3322:   end Write;
------------------
graphalg_test_tg__B_8__test_graph__edge_vectors__write.214:
    #####: 3312:   procedure Write
        -: 3313:     (Stream    : not null access Root_Stream_Type'Class;
        -: 3314:      Container : Vector)
        -: 3315:   is
        -: 3316:   begin
    #####: 3317:      Count_Type'Base'Write (Stream, Length (Container));
        -: 3318:
    #####: 3319:      for J in Index_Type'First .. Container.Last loop
    #####: 3320:         Element_Type'Write (Stream, Container.Elements.EA (J));
    #####: 3321:      end loop;
    #####: 3322:   end Write;
------------------
graphalg_test_tg__B_4__test_graph__vertex_vectors__write.449:
    #####: 3312:   procedure Write
        -: 3313:     (Stream    : not null access Root_Stream_Type'Class;
        -: 3314:      Container : Vector)
        -: 3315:   is
        -: 3316:   begin
    #####: 3317:      Count_Type'Base'Write (Stream, Length (Container));
        -: 3318:
    #####: 3319:      for J in Index_Type'First .. Container.Last loop
    #####: 3320:         Element_Type'Write (Stream, Container.Elements.EA (J));
    #####: 3321:      end loop;
    #####: 3322:   end Write;
------------------
graphalg_test_tg__B_4__test_graph__edge_vectors__write.573:
    #####: 3312:   procedure Write
        -: 3313:     (Stream    : not null access Root_Stream_Type'Class;
        -: 3314:      Container : Vector)
        -: 3315:   is
        -: 3316:   begin
    #####: 3317:      Count_Type'Base'Write (Stream, Length (Container));
        -: 3318:
    #####: 3319:      for J in Index_Type'First .. Container.Last loop
    #####: 3320:         Element_Type'Write (Stream, Container.Elements.EA (J));
    #####: 3321:      end loop;
    #####: 3322:   end Write;
------------------
        -: 3323:
        -: 3324:   procedure Write
        -: 3325:     (Stream   : not null access Root_Stream_Type'Class;
        -: 3326:      Position : Cursor)
        -: 3327:   is
        -: 3328:   begin
        -: 3329:      raise Program_Error with "attempt to stream vector cursor";
        -: 3330:   end Write;
        -: 3331:
        -: 3332:   procedure Write
        -: 3333:     (Stream : not null access Root_Stream_Type'Class;
        -: 3334:      Item   : Reference_Type)
        -: 3335:   is
        -: 3336:   begin
        -: 3337:      raise Program_Error with "attempt to stream reference";
        -: 3338:   end Write;
        -: 3339:
        -: 3340:   procedure Write
        -: 3341:     (Stream : not null access Root_Stream_Type'Class;
        -: 3342:      Item   : Constant_Reference_Type)
        -: 3343:   is
        -: 3344:   begin
        -: 3345:      raise Program_Error with "attempt to stream reference";
        -: 3346:   end Write;
        -: 3347:
        -: 3348:end Ada.Containers.Vectors;
