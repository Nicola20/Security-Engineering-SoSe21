        -:    0:Source:/home/philipp/opt/GNAT/2021/lib/gcc/x86_64-pc-linux-gnu/10.3.1/adainclude/a-convec.ads
        -:    0:Graph:/mnt/c/wsl_share/1_FS_Master/Security_Engineering/Security-Engineering-SoSe21/assignment7/p1/bin/graphalg_test_tg.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:------------------------------------------------------------------------------
        -:    2:--                                                                          --
        -:    3:--                         GNAT LIBRARY COMPONENTS                          --
        -:    4:--                                                                          --
        -:    5:--                A D A . C O N T A I N E R S . V E C T O R S               --
        -:    6:--                                                                          --
        -:    7:--                                 S p e c                                  --
        -:    8:--                                                                          --
        -:    9:--          Copyright (C) 2004-2021, Free Software Foundation, Inc.         --
        -:   10:--                                                                          --
        -:   11:-- This specification is derived from the Ada Reference Manual for use with --
        -:   12:-- GNAT. The copyright notice above, and the license provisions that follow --
        -:   13:-- apply solely to the  contents of the part following the private keyword. --
        -:   14:--                                                                          --
        -:   15:-- GNAT is free software;  you can  redistribute it  and/or modify it under --
        -:   16:-- terms of the  GNU General Public License as published  by the Free Soft- --
        -:   17:-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
        -:   18:-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
        -:   19:-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
        -:   20:-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
        -:   21:--                                                                          --
        -:   22:--                                                                          --
        -:   23:--                                                                          --
        -:   24:--                                                                          --
        -:   25:--                                                                          --
        -:   26:-- You should have received a copy of the GNU General Public License and    --
        -:   27:-- a copy of the GCC Runtime Library Exception along with this program;     --
        -:   28:-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
        -:   29:-- <http://www.gnu.org/licenses/>.                                          --
        -:   30:--                                                                          --
        -:   31:-- This unit was originally developed by Matthew J Heaney.                  --
        -:   32:------------------------------------------------------------------------------
        -:   33:
        -:   34:with Ada.Iterator_Interfaces;
        -:   35:
        -:   36:with Ada.Containers.Helpers;
        -:   37:private with Ada.Finalization;
        -:   38:private with Ada.Streams;
        -:   39:private with Ada.Strings.Text_Buffers;
        -:   40:
        -:   41:--  The language-defined generic package Containers.Vectors provides private
        -:   42:--  types Vector and Cursor, and a set of operations for each type. A vector
        -:   43:--  container allows insertion and deletion at any position, but it is
        -:   44:--  specifically optimized for insertion and deletion at the high end (the end
        -:   45:--  with the higher index) of the container. A vector container also provides
        -:   46:--  random access to its elements.
        -:   47:--
        -:   48:--  A vector container behaves conceptually as an array that expands as
        -:   49:--  necessary as items are inserted. The length of a vector is the number of
        -:   50:--  elements that the vector contains. The capacity of a vector is the maximum
        -:   51:--  number of elements that can be inserted into the vector prior to it being
        -:   52:--  automatically expanded.
        -:   53:--
        -:   54:--  Elements in a vector container can be referred to by an index value of a
        -:   55:--  generic formal type. The first element of a vector always has its index
        -:   56:--  value equal to the lower bound of the formal type.
        -:   57:--
        -:   58:--  A vector container may contain empty elements. Empty elements do not have a
        -:   59:--  specified value.
        -:   60:
        -:   61:generic
        -:   62:   type Index_Type is range <>;
        -:   63:   type Element_Type is private;
        -:   64:
        -:   65:   with function "=" (Left, Right : Element_Type) return Boolean is <>;
        -:   66:   --  The actual function for the generic formal function "=" on Element_Type
        -:   67:   --  values is expected to define a reflexive and symmetric relationship and
        -:   68:   --  return the same result value each time it is called with a particular
        -:   69:   --  pair of values. If it behaves in some other manner, the functions
        -:   70:   --  defined to use it return an unspecified value. The exact arguments and
        -:   71:   --  number of calls of this generic formal function by the functions defined
        -:   72:   --  to use it are unspecified.
        -:   73:
        -:   74:package Ada.Containers.Vectors with
        -:   75:  SPARK_Mode => Off
        -:   76:is
        -:   77:   pragma Annotate (CodePeer, Skip_Analysis);
        -:   78:   pragma Preelaborate;
        -:   79:   pragma Remote_Types;
        -:   80:
        -:   81:   subtype Extended_Index is Index_Type'Base
        -:   82:     range Index_Type'First - 1 ..
        -:   83:           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;
        -:   84:   --  The subtype Extended_Index includes the indices covered by Index_Type
        -:   85:   --  plus the value No_Index and, if it exists, the successor to the
        -:   86:   --  Index_Type'Last.
        -:   87:
    #####:   88:   No_Index : constant Extended_Index := Extended_Index'First;
        -:   89:   --  No_Index represents a position that does not correspond to any element.
        -:   90:
        -:   91:   type Vector is tagged private
        -:   92:   with
        -:   93:      Constant_Indexing => Constant_Reference,
        -:   94:      Variable_Indexing => Reference,
        -:   95:      Default_Iterator  => Iterate,
        -:   96:      Iterator_Element  => Element_Type,
        -:   97:      Aggregate         => (Empty          => Empty,
        -:   98:                            Add_Unnamed    => Append,
        -:   99:                            New_Indexed    => New_Vector,
        -:  100:                            Assign_Indexed => Replace_Element);
        -:  101:
        -:  102:   pragma Preelaborable_Initialization (Vector);
        -:  103:   --  Vector type, to be instantiated by users of this package. If an object
        -:  104:   --  of type Vector is not otherwise initialized, it is initialized to
        -:  105:   --  Empty_Vector.
        -:  106:
        -:  107:   type Cursor is private;
        -:  108:   pragma Preelaborable_Initialization (Cursor);
        -:  109:   --  Cursor pointing into an instance of vector. If an object of type Cursor
        -:  110:   --  is not otherwise initialized, it is initialized to No_Element
        -:  111:
        -:  112:   No_Element : constant Cursor;
        -:  113:   --  No_Element represents a cursor that designates no element.
        -:  114:
        -:  115:   function Has_Element (Position : Cursor) return Boolean;
        -:  116:   --  Returns True if Position designates an element, and returns False
        -:  117:   --  otherwise.
        -:  118:
        -:  119:   package Vector_Iterator_Interfaces is new
        -:  120:      Ada.Iterator_Interfaces (Cursor, Has_Element);
        -:  121:
        -:  122:   Empty_Vector : constant Vector;
        -:  123:   --  Empty_Vector represents the empty vector object. It has a length of 0.
        -:  124:
        -:  125:   function Empty (Capacity : Count_Type := 10) return Vector;
        -:  126:
        -:  127:   overriding function "=" (Left, Right : Vector) return Boolean;
        -:  128:   --  If Left and Right denote the same vector object, then the function
        -:  129:   --  returns True. If Left and Right have different lengths, then the
        -:  130:   --  function returns False. Otherwise, it compares each element in Left to
        -:  131:   --  the corresponding element in Right using the generic formal equality
        -:  132:   --  operator. If any such comparison returns False, the function returns
        -:  133:   --  False; otherwise it returns True. Any exception raised during evaluation
        -:  134:   --  of element equality is propagated.
        -:  135:
        -:  136:   function To_Vector (Length : Count_Type) return Vector;
        -:  137:   --  Returns a vector with a length of Length, filled with empty elements.
        -:  138:
        -:  139:   function To_Vector
        -:  140:     (New_Item : Element_Type;
        -:  141:      Length   : Count_Type) return Vector;
        -:  142:   --  Returns a vector with a length of Length, filled with elements
        -:  143:   --  initialized to the value New_Item.
        -:  144:
        -:  145:   function "&" (Left, Right : Vector) return Vector;
        -:  146:   --  Returns a vector comprising the elements of Left followed by the
        -:  147:   --  elements of Right.
        -:  148:
        -:  149:   function "&" (Left : Vector; Right : Element_Type) return Vector;
        -:  150:   --  Returns a vector comprising the elements of Left followed by the element
        -:  151:   --  Right.
        -:  152:
        -:  153:   function "&" (Left : Element_Type; Right : Vector) return Vector;
        -:  154:   --  Returns a vector comprising the element Left followed by the elements of
        -:  155:   --  Right.
        -:  156:
        -:  157:   function "&" (Left, Right : Element_Type) return Vector;
        -:  158:   --  Returns a vector comprising the element Left followed by the element
        -:  159:   --  Right.
        -:  160:
        -:  161:   function Capacity (Container : Vector) return Count_Type;
        -:  162:   --  Returns the capacity of Container.
        -:  163:
        -:  164:   procedure Reserve_Capacity
        -:  165:     (Container : in out Vector;
        -:  166:      Capacity  : Count_Type);
        -:  167:   --  Reserve_Capacity allocates new internal data structures such that the
        -:  168:   --  length of the resulting vector can become at least the value Capacity
        -:  169:   --  without requiring an additional call to Reserve_Capacity, and is large
        -:  170:   --  enough to hold the current length of Container. Reserve_Capacity then
        -:  171:   --  copies the elements into the new data structures and deallocates the old
        -:  172:   --  data structures. Any exception raised during allocation is propagated
        -:  173:   --  and Container is not modified.
        -:  174:
        -:  175:   function Length (Container : Vector) return Count_Type;
        -:  176:   --  Returns the number of elements in Container.
        -:  177:
        -:  178:   procedure Set_Length
        -:  179:     (Container : in out Vector;
        -:  180:      Length    : Count_Type);
        -:  181:   --  If Length is larger than the capacity of Container, Set_Length calls
        -:  182:   --  Reserve_Capacity (Container, Length), then sets the length of the
        -:  183:   --  Container to Length. If Length is greater than the original length of
        -:  184:   --  Container, empty elements are added to Container; otherwise elements are
        -:  185:   --  removed from Container.
        -:  186:
        -:  187:   function Is_Empty (Container : Vector) return Boolean;
        -:  188:   --  Equivalent to Length (Container) = 0.
        -:  189:
        -:  190:   procedure Clear (Container : in out Vector);
        -:  191:   --  Removes all the elements from Container. The capacity of Container does
        -:  192:   --  not change.
        -:  193:
        -:  194:   function To_Cursor
        -:  195:     (Container : Vector;
        -:  196:      Index     : Extended_Index) return Cursor;
        -:  197:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  198:   --  (Container), then No_Element is returned. Otherwise, a cursor
        -:  199:   --  designating the element at position Index in Container is returned.
        -:  200:
        -:  201:   function To_Index (Position : Cursor) return Extended_Index;
        -:  202:   --  If Position is No_Element, No_Index is returned. Otherwise, the index
        -:  203:   --  (within its containing vector) of the element designated by Position is
        -:  204:   --  returned.
        -:  205:
        -:  206:   function Element
        -:  207:     (Container : Vector;
        -:  208:      Index     : Index_Type) return Element_Type;
        -:  209:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  210:   --  (Container), then Constraint_Error is propagated. Otherwise, Element
        -:  211:   --  returns the element at position Index.
        -:  212:
        -:  213:   function Element (Position : Cursor) return Element_Type;
        -:  214:   --  If Position equals No_Element, then Constraint_Error is propagated.
        -:  215:   --  Otherwise, Element returns the element designated by Position.
        -:  216:
        -:  217:   procedure Replace_Element
        -:  218:     (Container : in out Vector;
        -:  219:      Index     : Index_Type;
        -:  220:      New_Item  : Element_Type);
        -:  221:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  222:   --  (Container), then Constraint_Error is propagated. Otherwise
        -:  223:   --  Replace_Element assigns the value New_Item to the element at position
        -:  224:   --  Index. Any exception raised during the assignment is propagated. The
        -:  225:   --  element at position Index is not an empty element after successful call
        -:  226:   --  to Replace_Element.
        -:  227:
        -:  228:   procedure Replace_Element
        -:  229:     (Container : in out Vector;
        -:  230:      Position  : Cursor;
        -:  231:      New_Item  : Element_Type);
        -:  232:   --  If Position equals No_Element, then Constraint_Error is propagated; if
        -:  233:   --  Position does not designate an element in Container, then Program_Error
        -:  234:   --  is propagated. Otherwise Replace_Element assigns New_Item to the element
        -:  235:   --  designated by Position. Any exception raised during the assignment is
        -:  236:   --  propagated. The element at Position is not an empty element after
        -:  237:   --  successful call to Replace_Element.
        -:  238:
        -:  239:   procedure Query_Element
        -:  240:     (Container : Vector;
        -:  241:      Index     : Index_Type;
        -:  242:      Process   : not null access procedure (Element : Element_Type));
        -:  243:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  244:   --  (Container), then Constraint_Error is propagated. Otherwise,
        -:  245:   --  Query_Element calls Process.all with the element at position Index as
        -:  246:   --  the argument. Program_Error is propagated if Process.all tampers with
        -:  247:   --  the elements of Container. Any exception raised by Process.all is
        -:  248:   --  propagated.
        -:  249:
        -:  250:   procedure Query_Element
        -:  251:     (Position : Cursor;
        -:  252:      Process  : not null access procedure (Element : Element_Type));
        -:  253:   --  If Position equals No_Element, then Constraint_Error is propagated.
        -:  254:   --  Otherwise, Query_Element calls Process.all with the element designated
        -:  255:   --  by Position as the argument. Program_Error is propagated if Process.all
        -:  256:   --  tampers with the elements of Container. Any exception raised by
        -:  257:   --  Process.all is propagated.
        -:  258:
        -:  259:   procedure Update_Element
        -:  260:     (Container : in out Vector;
        -:  261:      Index     : Index_Type;
        -:  262:      Process   : not null access procedure (Element : in out Element_Type));
        -:  263:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  264:   --  (Container), then Constraint_Error is propagated. Otherwise,
        -:  265:   --  Update_Element calls Process.all with the element at position Index as
        -:  266:   --  the argument. Program_Error is propagated if Process.all tampers with
        -:  267:   --  the elements of Container. Any exception raised by Process.all is
        -:  268:   --  propagated.
        -:  269:   --
        -:  270:   --  If Element_Type is unconstrained and definite, then the actual Element
        -:  271:   --  parameter of Process.all shall be unconstrained.
        -:  272:   --
        -:  273:   --  The element at position Index is not an empty element after successful
        -:  274:   --  completion of this operation.
        -:  275:
        -:  276:   procedure Update_Element
        -:  277:     (Container : in out Vector;
        -:  278:      Position  : Cursor;
        -:  279:      Process   : not null access procedure (Element : in out Element_Type));
        -:  280:   --  If Position equals No_Element, then Constraint_Error is propagated; if
        -:  281:   --  Position does not designate an element in Container, then Program_Error
        -:  282:   --  is propagated. Otherwise Update_Element calls Process.all with the
        -:  283:   --  element designated by Position as the argument. Program_Error is
        -:  284:   --  propagated if Process.all tampers with the elements of Container. Any
        -:  285:   --  exception raised by Process.all is propagated.
        -:  286:   --
        -:  287:   --  If Element_Type is unconstrained and definite, then the actual Element
        -:  288:   --  parameter of Process.all shall be unconstrained.
        -:  289:   --
        -:  290:   --  The element designated by Position is not an empty element after
        -:  291:   --  successful completion of this operation.
        -:  292:
        -:  293:   type Constant_Reference_Type
        -:  294:      (Element : not null access constant Element_Type) is
        -:  295:   private
        -:  296:   with
        -:  297:      Implicit_Dereference => Element;
        -:  298:
        -:  299:   type Reference_Type (Element : not null access Element_Type) is private
        -:  300:   with
        -:  301:      Implicit_Dereference => Element;
        -:  302:
        -:  303:   function Constant_Reference
        -:  304:     (Container : aliased Vector;
        -:  305:      Position  : Cursor) return Constant_Reference_Type;
        -:  306:   pragma Inline (Constant_Reference);
        -:  307:
        -:  308:   function Reference
        -:  309:     (Container : aliased in out Vector;
        -:  310:      Position  : Cursor) return Reference_Type;
        -:  311:   pragma Inline (Reference);
        -:  312:
        -:  313:   function Constant_Reference
        -:  314:     (Container : aliased Vector;
        -:  315:      Index     : Index_Type) return Constant_Reference_Type;
        -:  316:   pragma Inline (Constant_Reference);
        -:  317:
        -:  318:   function Reference
        -:  319:     (Container : aliased in out Vector;
        -:  320:      Index     : Index_Type) return Reference_Type;
        -:  321:   pragma Inline (Reference);
        -:  322:
        -:  323:   procedure Assign (Target : in out Vector; Source : Vector);
        -:  324:
        -:  325:   function Copy (Source : Vector; Capacity : Count_Type := 0) return Vector;
        -:  326:
        -:  327:   procedure Move (Target : in out Vector; Source : in out Vector);
        -:  328:   --  If Target denotes the same object as Source, then Move has no effect.
        -:  329:   --  Otherwise, Move first calls Clear (Target); then, each element from
        -:  330:   --  Source is removed from Source and inserted into Target in the original
        -:  331:   --  order. The length of Source is 0 after a successful call to Move.
        -:  332:
        -:  333:   function New_Vector (First, Last : Index_Type) return Vector
    #####:  334:     with Pre => First = Index_Type'First;
        -:  335:   --  Ada 2022 aggregate operation.
        -:  336:
        -:  337:   procedure Insert_Vector
        -:  338:     (Container : in out Vector;
        -:  339:      Before    : Extended_Index;
        -:  340:      New_Item  : Vector);
        -:  341:   --  If Before is not in the range First_Index (Container) .. Last_Index
        -:  342:   --  (Container) + 1, then Constraint_Error is propagated. If
        -:  343:   --  Length(New_Item) is 0, then Insert_Vector does nothing. Otherwise, it
        -:  344:   --  computes the new length NL as the sum of the current length and Length
        -:  345:   --  (New_Item); if the value of Last appropriate for length NL would be
        -:  346:   --  greater than Index_Type'Last then Constraint_Error is propagated.
        -:  347:   --
        -:  348:   --  If the current vector capacity is less than NL, Reserve_Capacity
        -:  349:   --  (Container, NL) is called to increase the vector capacity. Then
        -:  350:   --  Insert_Vector slides the elements in the range Before .. Last_Index
        -:  351:   --  (Container) up by Length(New_Item) positions, and then copies the
        -:  352:   --  elements of New_Item to the positions starting at Before. Any exception
        -:  353:   --  raised during the copying is propagated.
        -:  354:
        -:  355:   procedure Insert
        -:  356:     (Container : in out Vector;
        -:  357:      Before    : Extended_Index;
        -:  358:      New_Item  : Vector) renames Insert_Vector;
        -:  359:   --  Retained for now for compatibility; AI12-0400 will remove this.
        -:  360:
        -:  361:   procedure Insert_Vector
        -:  362:     (Container : in out Vector;
        -:  363:      Before    : Cursor;
        -:  364:      New_Item  : Vector);
        -:  365:   --  If Before is not No_Element, and does not designate an element in
        -:  366:   --  Container, then Program_Error is propagated. Otherwise, if
        -:  367:   --  Length(New_Item) is 0, then Insert_Vector does nothing. If Before is
        -:  368:   --  No_Element, then the call is equivalent to Insert_Vector (Container,
        -:  369:   --  Last_Index (Container) + 1, New_Item); otherwise the call is equivalent
        -:  370:   --  to Insert_Vector (Container, To_Index (Before), New_Item);
        -:  371:
        -:  372:   procedure Insert
        -:  373:     (Container : in out Vector;
        -:  374:      Before    : Cursor;
        -:  375:      New_Item  : Vector) renames Insert_Vector;
        -:  376:   --  Retained for now for compatibility; AI12-0400 will remove this.
        -:  377:
        -:  378:   procedure Insert_Vector
        -:  379:     (Container : in out Vector;
        -:  380:      Before    : Cursor;
        -:  381:      New_Item  : Vector;
        -:  382:      Position  : out Cursor);
        -:  383:   --  If Before is not No_Element, and does not designate an element in
        -:  384:   --  Container, then Program_Error is propagated. If Before equals
        -:  385:   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T
        -:  386:   --  be To_Index (Before). Insert_Vector (Container, T, New_Item) is called,
        -:  387:   --  and then Position is set to To_Cursor (Container, T).
        -:  388:
        -:  389:   procedure Insert
        -:  390:     (Container : in out Vector;
        -:  391:      Before    : Cursor;
        -:  392:      New_Item  : Vector;
        -:  393:      Position  : out Cursor) renames Insert_Vector;
        -:  394:   --  Retained for now for compatibility; AI12-0400 will remove this.
        -:  395:
        -:  396:   procedure Insert
        -:  397:     (Container : in out Vector;
        -:  398:      Before    : Extended_Index;
        -:  399:      New_Item  : Element_Type;
        -:  400:      Count     : Count_Type := 1);
        -:  401:   --  Equivalent to:
        -:  402:   --  Insert_Vector (Container, Before, To_Vector (New_Item, Count));
        -:  403:
        -:  404:   procedure Insert
        -:  405:     (Container : in out Vector;
        -:  406:      Before    : Cursor;
        -:  407:      New_Item  : Element_Type;
        -:  408:      Count     : Count_Type := 1);
        -:  409:   --  Equivalent to:
        -:  410:   --  Insert_Vector (Container, Before, To_Vector (New_Item, Count));
        -:  411:
        -:  412:   procedure Insert
        -:  413:     (Container : in out Vector;
        -:  414:      Before    : Cursor;
        -:  415:      New_Item  : Element_Type;
        -:  416:      Position  : out Cursor;
        -:  417:      Count     : Count_Type := 1);
        -:  418:   --  Equivalent to
        -:  419:   --  Insert_Vector (Container, Before, To_Vector (New_Item, Count), Position)
        -:  420:
        -:  421:   procedure Insert
        -:  422:     (Container : in out Vector;
        -:  423:      Before    : Extended_Index;
        -:  424:      Count     : Count_Type := 1);
        -:  425:   --  If Before is not in the range First_Index (Container) .. Last_Index
        -:  426:   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,
        -:  427:   --  then Insert does nothing. Otherwise, it computes the new length NL as
        -:  428:   --  the sum of the current length and Count; if the value of Last
        -:  429:   --  appropriate for length NL would be greater than Index_Type'Last then
        -:  430:   --  Constraint_Error is propagated.
        -:  431:   --
        -:  432:   --  If the current vector capacity is less than NL, Reserve_Capacity
        -:  433:   --  (Container, NL) is called to increase the vector capacity. Then Insert
        -:  434:   --  slides the elements in the range Before .. Last_Index (Container) up by
        -:  435:   --  Count positions, and then inserts elements that are initialized by
        -:  436:   --  default (see 3.3.1) in the positions starting at Before.
        -:  437:
        -:  438:   procedure Insert
        -:  439:     (Container : in out Vector;
        -:  440:      Before    : Cursor;
        -:  441:      Position  : out Cursor;
        -:  442:      Count     : Count_Type := 1);
        -:  443:   --  If Before is not No_Element, and does not designate an element in
        -:  444:   --  Container, then Program_Error is propagated. If Before equals
        -:  445:   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T
        -:  446:   --  be To_Index (Before). Insert (Container, T, Count) is called, and then
        -:  447:   --  Position is set to To_Cursor (Container, T).
        -:  448:
        -:  449:   procedure Prepend_Vector
        -:  450:     (Container : in out Vector;
        -:  451:      New_Item  : Vector);
        -:  452:   --  Equivalent to Insert (Container, First_Index (Container), New_Item).
        -:  453:
        -:  454:   procedure Prepend
        -:  455:     (Container : in out Vector;
        -:  456:      New_Item  : Vector) renames Prepend_Vector;
        -:  457:   --  Retained for now for compatibility; AI12-0400 will remove this.
        -:  458:
        -:  459:   procedure Prepend
        -:  460:     (Container : in out Vector;
        -:  461:      New_Item  : Element_Type;
        -:  462:      Count     : Count_Type := 1);
        -:  463:   --  Equivalent to Insert (Container, First_Index (Container), New_Item,
        -:  464:   --  Count).
        -:  465:
        -:  466:   procedure Append_Vector
        -:  467:     (Container : in out Vector;
        -:  468:      New_Item  : Vector);
        -:  469:   --  Equivalent to Insert (Container, Last_Index (Container) + 1, New_Item).
        -:  470:
        -:  471:   procedure Append
        -:  472:     (Container : in out Vector;
        -:  473:      New_Item  : Vector) renames Append_Vector;
        -:  474:   --  Retained for now for compatibility; AI12-0400 will remove this.
        -:  475:
        -:  476:   procedure Append
        -:  477:     (Container : in out Vector;
        -:  478:      New_Item  : Element_Type;
        -:  479:      Count     : Count_Type);
        -:  480:   --  Equivalent to Insert (Container, Last_Index (Container) + 1, New_Item,
        -:  481:   --  Count).
        -:  482:
        -:  483:   procedure Append (Container : in out Vector;
        -:  484:                     New_Item  :        Element_Type);
        -:  485:
        -:  486:   procedure Insert_Space
        -:  487:     (Container : in out Vector;
        -:  488:      Before    : Extended_Index;
        -:  489:      Count     : Count_Type := 1);
        -:  490:   --  If Before is not in the range First_Index (Container) .. Last_Index
        -:  491:   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,
        -:  492:   --  then Insert_Space does nothing. Otherwise, it computes the new length NL
        -:  493:   --  as the sum of the current length and Count; if the value of Last
        -:  494:   --  appropriate for length NL would be greater than Index_Type'Last then
        -:  495:   --  Constraint_Error is propagated.
        -:  496:   --
        -:  497:   --  If the current vector capacity is less than NL, Reserve_Capacity
        -:  498:   --  (Container, NL) is called to increase the vector capacity. Then
        -:  499:   --  Insert_Space slides the elements in the range Before .. Last_Index
        -:  500:   --  (Container) up by Count positions, and then inserts empty elements in
        -:  501:   --  the positions starting at Before.
        -:  502:
        -:  503:   procedure Insert_Space
        -:  504:     (Container : in out Vector;
        -:  505:      Before    : Cursor;
        -:  506:      Position  : out Cursor;
        -:  507:      Count     : Count_Type := 1);
        -:  508:   --  If Before is not No_Element, and does not designate an element in
        -:  509:   --  Container, then Program_Error is propagated. If Before equals
        -:  510:   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T
        -:  511:   --  be To_Index (Before). Insert_Space (Container, T, Count) is called, and
        -:  512:   --  then Position is set to To_Cursor (Container, T).
        -:  513:
        -:  514:   procedure Delete
        -:  515:     (Container : in out Vector;
        -:  516:      Index     : Extended_Index;
        -:  517:      Count     : Count_Type := 1);
        -:  518:   --  If Index is not in the range First_Index (Container) .. Last_Index
        -:  519:   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,
        -:  520:   --  Delete has no effect. Otherwise Delete slides the elements (if any)
        -:  521:   --  starting at position Index + Count down to Index. Any exception raised
        -:  522:   --  during element assignment is propagated.
        -:  523:
        -:  524:   procedure Delete
        -:  525:     (Container : in out Vector;
        -:  526:      Position  : in out Cursor;
        -:  527:      Count     : Count_Type := 1);
        -:  528:   --  If Position equals No_Element, then Constraint_Error is propagated. If
        -:  529:   --  Position does not designate an element in Container, then Program_Error
        -:  530:   --  is propagated. Otherwise, Delete (Container, To_Index (Position), Count)
        -:  531:   --  is called, and then Position is set to No_Element.
        -:  532:
        -:  533:   procedure Delete_First
        -:  534:     (Container : in out Vector;
        -:  535:      Count     : Count_Type := 1);
        -:  536:   --  Equivalent to Delete (Container, First_Index (Container), Count).
        -:  537:
        -:  538:   procedure Delete_Last
        -:  539:     (Container : in out Vector;
        -:  540:      Count     : Count_Type := 1);
        -:  541:   --  If Length (Container) <= Count then Delete_Last is equivalent to Clear
        -:  542:   --  (Container). Otherwise it is equivalent to Delete (Container,
        -:  543:   --  Index_Type'Val(Index_Type'Pos(Last_Index (Container)) - Count + 1),
        -:  544:   --  Count).
        -:  545:
        -:  546:   procedure Reverse_Elements (Container : in out Vector);
        -:  547:   --  Reorders the elements of Container in reverse order.
        -:  548:
        -:  549:   procedure Swap (Container : in out Vector; I, J : Index_Type);
        -:  550:   --  If either I or J is not in the range First_Index (Container) ..
        -:  551:   --  Last_Index (Container), then Constraint_Error is propagated. Otherwise,
        -:  552:   --  Swap exchanges the values of the elements at positions I and J.
        -:  553:
        -:  554:   procedure Swap (Container : in out Vector; I, J : Cursor);
        -:  555:   --  If either I or J is No_Element, then Constraint_Error is propagated. If
        -:  556:   --  either I or J do not designate an element in Container, then
        -:  557:   --  Program_Error is propagated. Otherwise, Swap exchanges the values of the
        -:  558:   --  elements designated by I and J.
        -:  559:
        -:  560:   function First_Index (Container : Vector) return Index_Type;
        -:  561:   --  Returns the value Index_Type'First.
        -:  562:
        -:  563:   function First (Container : Vector) return Cursor;
        -:  564:   --  If Container is empty, First returns No_Element. Otherwise, it returns a
        -:  565:   --  cursor that designates the first element in Container.
        -:  566:
        -:  567:   function First_Element (Container : Vector) return Element_Type;
        -:  568:   --  Equivalent to Element (Container, First_Index (Container)).
        -:  569:
        -:  570:   function Last_Index (Container : Vector) return Extended_Index;
        -:  571:   --  If Container is empty, Last_Index returns No_Index. Otherwise, it
        -:  572:   --  returns the position of the last element in Container.
        -:  573:
        -:  574:   function Last (Container : Vector) return Cursor;
        -:  575:   --  If Container is empty, Last returns No_Element. Otherwise, it returns a
        -:  576:   --  cursor that designates the last element in Container.
        -:  577:
        -:  578:   function Last_Element (Container : Vector) return Element_Type;
        -:  579:   --  Equivalent to Element (Container, Last_Index (Container)).
        -:  580:
        -:  581:   function Next (Position : Cursor) return Cursor;
        -:  582:   --  If Position equals No_Element or designates the last element of the
        -:  583:   --  container, then Next returns the value No_Element. Otherwise, it returns
        -:  584:   --  a cursor that designates the element with index To_Index (Position) + 1
        -:  585:   --  in the same vector as Position.
        -:  586:
        -:  587:   procedure Next (Position : in out Cursor);
        -:  588:   --  Equivalent to Position := Next (Position).
        -:  589:
        -:  590:   function Previous (Position : Cursor) return Cursor;
        -:  591:   --  If Position equals No_Element or designates the first element of the
        -:  592:   --  container, then Previous returns the value No_Element. Otherwise, it
        -:  593:   --  returns a cursor that designates the element with index To_Index
        -:  594:   --  (Position) - 1 in the same vector as Position.
        -:  595:
        -:  596:   procedure Previous (Position : in out Cursor);
        -:  597:   --  Equivalent to Position := Previous (Position).
        -:  598:
        -:  599:   function Find_Index
        -:  600:     (Container : Vector;
        -:  601:      Item      : Element_Type;
        -:  602:      Index     : Index_Type := Index_Type'First) return Extended_Index;
        -:  603:   --  Searches the elements of Container for an element equal to Item (using
        -:  604:   --  the generic formal equality operator). The search starts at position
        -:  605:   --  Index and proceeds towards Last_Index (Container). If no equal
        -:  606:   --  element is found, then Find_Index returns No_Index. Otherwise, it
        -:  607:   --  returns the index of the first equal element encountered.
        -:  608:
        -:  609:   function Find
        -:  610:     (Container : Vector;
        -:  611:      Item      : Element_Type;
        -:  612:      Position  : Cursor := No_Element) return Cursor;
        -:  613:   --  If Position is not No_Element, and does not designate an element in
        -:  614:   --  Container, then Program_Error is propagated. Otherwise Find searches
        -:  615:   --  the elements of Container for an element equal to Item (using the
        -:  616:   --  generic formal equality operator). The search starts at the first
        -:  617:   --  element if Position equals No_Element, and at the element designated
        -:  618:   --  by Position otherwise. It proceeds towards the last element of
        -:  619:   --  Container. If no equal element is found, then Find returns
        -:  620:   --  No_Element. Otherwise, it returns a cursor designating the first
        -:  621:   --  equal element encountered.
        -:  622:
        -:  623:   function Reverse_Find_Index
        -:  624:     (Container : Vector;
        -:  625:      Item      : Element_Type;
        -:  626:      Index     : Index_Type := Index_Type'Last) return Extended_Index;
        -:  627:   --  Searches the elements of Container for an element equal to Item (using
        -:  628:   --  the generic formal equality operator). The search starts at position
        -:  629:   --  Index or, if Index is greater than Last_Index (Container), at
        -:  630:   --  position Last_Index (Container). It proceeds towards First_Index
        -:  631:   --  (Container). If no equal element is found, then Reverse_Find_Index
        -:  632:   --  returns No_Index. Otherwise, it returns the index of the first equal
        -:  633:   --  element encountered.
        -:  634:
        -:  635:   function Reverse_Find
        -:  636:     (Container : Vector;
        -:  637:      Item      : Element_Type;
        -:  638:      Position  : Cursor := No_Element) return Cursor;
        -:  639:   --  If Position is not No_Element, and does not designate an element in
        -:  640:   --  Container, then Program_Error is propagated. Otherwise Reverse_Find
        -:  641:   --  searches the elements of Container for an element equal to Item
        -:  642:   --  (using the generic formal equality operator). The search starts at
        -:  643:   --  the last element if Position equals No_Element, and at the element
        -:  644:   --  designated by Position otherwise. It proceeds towards the first
        -:  645:   --  element of Container. If no equal element is found, then Reverse_Find
        -:  646:   --  returns No_Element. Otherwise, it returns a cursor designating the
        -:  647:   --  first equal element encountered.
        -:  648:
        -:  649:   function Contains
        -:  650:     (Container : Vector;
        -:  651:      Item      : Element_Type) return Boolean;
        -:  652:   --  Equivalent to Has_Element (Find (Container, Item)).
        -:  653:
        -:  654:   procedure Iterate
        -:  655:     (Container : Vector;
        -:  656:      Process   : not null access procedure (Position : Cursor));
        -:  657:   --  Invokes Process.all with a cursor that designates each element in
        -:  658:   --  Container, in index order. Program_Error is propagated if Process.all
        -:  659:   --  tampers with the cursors of Container. Any exception raised by Process
        -:  660:   --  is propagated.
        -:  661:
        -:  662:   procedure Reverse_Iterate
        -:  663:     (Container : Vector;
        -:  664:      Process   : not null access procedure (Position : Cursor));
        -:  665:   --  Iterates over the elements in Container as per Iterate, except that
        -:  666:   --  elements are traversed in reverse index order.
        -:  667:   --
        -:  668:
        -:  669:   function Iterate (Container : Vector)
        -:  670:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class;
        -:  671:
        -:  672:   function Iterate (Container : Vector; Start : Cursor)
        -:  673:      return Vector_Iterator_Interfaces.Reversible_Iterator'Class;
        -:  674:
        -:  675:   generic
        -:  676:      with function "<" (Left, Right : Element_Type) return Boolean is <>;
        -:  677:      --  The actual function for the generic formal function "<" of
        -:  678:      --  Generic_Sorting is expected to return the same value each time it is
        -:  679:      --  called with a particular pair of element values. It should define a
        -:  680:      --  strict ordering relationship, that is, be irreflexive, asymmetric,
        -:  681:      --  and transitive; it should not modify Container. If the actual for "<"
        -:  682:      --  behaves in some other manner, the behavior of the subprograms of
        -:  683:      --  Generic_Sorting are unspecified. How many times the subprograms of
        -:  684:      --  Generic_Sorting call "<" is unspecified.
        -:  685:   package Generic_Sorting is
        -:  686:
        -:  687:      function Is_Sorted (Container : Vector) return Boolean;
        -:  688:      --  Returns True if the elements are sorted smallest first as determined
        -:  689:      --  by the generic formal "<" operator; otherwise, Is_Sorted returns
        -:  690:      --  False. Any exception raised during evaluation of "<" is propagated.
        -:  691:
        -:  692:      procedure Sort (Container : in out Vector);
        -:  693:      --  Reorders the elements of Container such that the elements are sorted
        -:  694:      --  smallest first as determined by the generic formal "<" operator
        -:  695:      --  provided. Any exception raised during evaluation of "<" is
        -:  696:      --  propagated.
        -:  697:
        -:  698:      procedure Merge (Target : in out Vector; Source : in out Vector);
        -:  699:      --  Merge removes elements from Source and inserts them into Target;
        -:  700:      --  afterwards, Target contains the union of the elements that were
        -:  701:      --  initially in Source and Target; Source is left empty. If Target and
        -:  702:      --  Source are initially sorted smallest first, then Target is ordered
        -:  703:      --  smallest first as determined by the generic formal "<" operator;
        -:  704:      --  otherwise, the order of elements in Target is unspecified. Any
        -:  705:      --  exception raised during evaluation of "<" is propagated.
        -:  706:
        -:  707:   end Generic_Sorting;
        -:  708:
        -:  709:private
        -:  710:
        -:  711:   pragma Inline (Append);
        -:  712:   pragma Inline (First_Index);
        -:  713:   pragma Inline (Last_Index);
        -:  714:   pragma Inline (Element);
        -:  715:   pragma Inline (First_Element);
        -:  716:   pragma Inline (Last_Element);
        -:  717:   pragma Inline (Query_Element);
        -:  718:   pragma Inline (Update_Element);
        -:  719:   pragma Inline (Replace_Element);
        -:  720:   pragma Inline (Is_Empty);
        -:  721:   pragma Inline (Contains);
        -:  722:   pragma Inline (Next);
        -:  723:   pragma Inline (Previous);
        -:  724:
        -:  725:   use Ada.Containers.Helpers;
        -:  726:   package Implementation is new Generic_Implementation;
        -:  727:   use Implementation;
        -:  728:
        -:  729:   type Elements_Array is array (Index_Type range <>) of aliased Element_Type;
        -:  730:   function "=" (L, R : Elements_Array) return Boolean is abstract;
        -:  731:
        -:  732:   type Elements_Type (Last : Extended_Index) is limited record
        -:  733:      EA : Elements_Array (Index_Type'First .. Last);
        -:  734:   end record;
        -:  735:
        -:  736:   type Elements_Access is access all Elements_Type;
        -:  737:
        -:  738:   use Finalization;
        -:  739:   use Streams;
        -:  740:
    #####:  741:   type Vector is new Controlled with record
        -:  742:      Elements : Elements_Access := null;
        -:  743:      Last     : Extended_Index := No_Index;
        -:  744:      TC       : aliased Tamper_Counts;
        -:  745:   end record with Put_Image => Put_Image;
        -:  746:
        -:  747:   procedure Put_Image
        -:  748:     (S : in out Ada.Strings.Text_Buffers.Root_Buffer_Type'Class; V : Vector);
        -:  749:
        -:  750:   overriding procedure Adjust (Container : in out Vector);
        -:  751:   overriding procedure Finalize (Container : in out Vector);
        -:  752:
        -:  753:   procedure Write
        -:  754:     (Stream    : not null access Root_Stream_Type'Class;
        -:  755:      Container : Vector);
        -:  756:
        -:  757:   for Vector'Write use Write;
        -:  758:
        -:  759:   procedure Read
        -:  760:     (Stream    : not null access Root_Stream_Type'Class;
        -:  761:      Container : out Vector);
        -:  762:
        -:  763:   for Vector'Read use Read;
        -:  764:
        -:  765:   type Vector_Access is access all Vector;
        -:  766:   for Vector_Access'Storage_Size use 0;
        -:  767:
        -:  768:   type Cursor is record
        -:  769:      Container : Vector_Access;
        -:  770:      Index     : Index_Type := Index_Type'First;
        -:  771:   end record;
        -:  772:
        -:  773:   procedure Read
        -:  774:     (Stream   : not null access Root_Stream_Type'Class;
        -:  775:      Position : out Cursor);
        -:  776:
        -:  777:   for Cursor'Read use Read;
        -:  778:
        -:  779:   procedure Write
        -:  780:     (Stream   : not null access Root_Stream_Type'Class;
        -:  781:      Position : Cursor);
        -:  782:
        -:  783:   for Cursor'Write use Write;
        -:  784:
        -:  785:   subtype Reference_Control_Type is Implementation.Reference_Control_Type;
        -:  786:   --  It is necessary to rename this here, so that the compiler can find it
        -:  787:
        -:  788:   type Constant_Reference_Type
        -:  789:     (Element : not null access constant Element_Type) is
        -:  790:      record
        -:  791:         Control : Reference_Control_Type :=
        -:  792:           raise Program_Error with "uninitialized reference";
        -:  793:         --  The RM says, "The default initialization of an object of
        -:  794:         --  type Constant_Reference_Type or Reference_Type propagates
        -:  795:         --  Program_Error."
        -:  796:      end record;
        -:  797:
        -:  798:   procedure Write
        -:  799:     (Stream : not null access Root_Stream_Type'Class;
        -:  800:      Item   : Constant_Reference_Type);
        -:  801:
        -:  802:   for Constant_Reference_Type'Write use Write;
        -:  803:
        -:  804:   procedure Read
        -:  805:     (Stream : not null access Root_Stream_Type'Class;
        -:  806:      Item   : out Constant_Reference_Type);
        -:  807:
        -:  808:   for Constant_Reference_Type'Read use Read;
        -:  809:
        -:  810:   type Reference_Type
        -:  811:     (Element : not null access Element_Type) is
        -:  812:      record
        -:  813:         Control : Reference_Control_Type :=
        -:  814:           raise Program_Error with "uninitialized reference";
        -:  815:         --  The RM says, "The default initialization of an object of
        -:  816:         --  type Constant_Reference_Type or Reference_Type propagates
        -:  817:         --  Program_Error."
        -:  818:      end record;
        -:  819:
        -:  820:   procedure Write
        -:  821:     (Stream : not null access Root_Stream_Type'Class;
        -:  822:      Item   : Reference_Type);
        -:  823:
        -:  824:   for Reference_Type'Write use Write;
        -:  825:
        -:  826:   procedure Read
        -:  827:     (Stream : not null access Root_Stream_Type'Class;
        -:  828:      Item   : out Reference_Type);
        -:  829:
        -:  830:   for Reference_Type'Read use Read;
        -:  831:
        -:  832:   --  Three operations are used to optimize in the expansion of "for ... of"
        -:  833:   --  loops: the Next(Cursor) procedure in the visible part, and the following
        -:  834:   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for
        -:  835:   --  details.
        -:  836:
        -:  837:   function Pseudo_Reference
        -:  838:     (Container : aliased Vector'Class) return Reference_Control_Type;
        -:  839:   pragma Inline (Pseudo_Reference);
        -:  840:   --  Creates an object of type Reference_Control_Type pointing to the
        -:  841:   --  container, and increments the Lock. Finalization of this object will
        -:  842:   --  decrement the Lock.
        -:  843:
        -:  844:   type Element_Access is access all Element_Type;
        -:  845:
        -:  846:   function Get_Element_Access
        -:  847:     (Position : Cursor) return not null Element_Access;
        -:  848:   --  Returns a pointer to the element designated by Position.
        -:  849:
        -:  850:   No_Element : constant Cursor := Cursor'(null, Index_Type'First);
        -:  851:
    #####:  852:   Empty_Vector : constant Vector := (Controlled with others => <>);
        -:  853:
    #####:  854:   type Iterator is new Limited_Controlled and
        -:  855:     Vector_Iterator_Interfaces.Reversible_Iterator with
        -:  856:   record
        -:  857:      Container : Vector_Access;
        -:  858:      Index     : Index_Type'Base;
        -:  859:   end record
        -:  860:     with Disable_Controlled => not T_Check;
        -:  861:
        -:  862:   overriding procedure Finalize (Object : in out Iterator);
        -:  863:
        -:  864:   overriding function First (Object : Iterator) return Cursor;
        -:  865:   overriding function Last  (Object : Iterator) return Cursor;
        -:  866:
        -:  867:   overriding function Next
        -:  868:     (Object   : Iterator;
        -:  869:      Position : Cursor) return Cursor;
        -:  870:
    #####:  871:   overriding function Previous
        -:  872:     (Object   : Iterator;
        -:  873:      Position : Cursor) return Cursor;
        -:  874:
        -:  875:end Ada.Containers.Vectors;
